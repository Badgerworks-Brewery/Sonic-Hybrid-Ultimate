diff --git a/RSDKv4/Animation.cpp b/RSDKv4/Animation.cpp
index 0a6290d..3bcc5b8 100644
--- a/RSDKv4/Animation.cpp
+++ b/RSDKv4/Animation.cpp
@@ -109,6 +109,10 @@ void ClearAnimationData()
     animationCount     = 0;
     animationFileCount = 0;
     hitboxCount        = 0;
+
+    // Used for pause menu
+    LoadGIFFile("Data/Game/SystemText.gif", SURFACE_COUNT - 1);
+    StrCopy(gfxSurface[SURFACE_COUNT - 1].fileName, "Data/Game/SystemText.gif");
 }
 
 AnimationFile *AddAnimationFile(char *filePath)
@@ -117,7 +121,7 @@ AnimationFile *AddAnimationFile(char *filePath)
     StrCopy(path, "Data/Animations/");
     StrAdd(path, filePath);
 
-    for (int a = 0; a < ANIFILE_COUNT; ++a) {
+    for (int a = 0; a < 0x100; ++a) {
         if (StrLength(animationFileList[a].fileName) <= 0) {
             StrCopy(animationFileList[a].fileName, filePath);
             LoadAnimationFile(path);
diff --git a/RSDKv4/Animation.hpp b/RSDKv4/Animation.hpp
index 3a4a811..e1a385f 100644
--- a/RSDKv4/Animation.hpp
+++ b/RSDKv4/Animation.hpp
@@ -8,7 +8,7 @@
 #define HITBOX_COUNT     (0x20)
 #define HITBOX_DIR_COUNT (0x8)
 
-enum AnimRotationFlags { ROTSTYLE_NONE, ROTSTYLE_FULL, ROTSTYLE_45DEG, ROTSTYLE_STATICFRAMES };
+enum AnimrotationFlags { ROTSTYLE_NONE, ROTSTYLE_FULL, ROTSTYLE_45DEG, ROTSTYLE_STATICFRAMES };
 
 struct AnimationFile {
     char fileName[0x20];
@@ -57,10 +57,10 @@ extern int animationCount;
 extern Hitbox hitboxList[HITBOX_COUNT];
 extern int hitboxCount;
 
-void LoadAnimationFile(char *filePath);
+void LoadAnimationFile(char *FilePath);
 void ClearAnimationData();
 
-AnimationFile *AddAnimationFile(char *filePath);
+AnimationFile *AddAnimationFile(char *FilePath);
 
 inline AnimationFile *GetDefaultAnimationRef() { return &animationFileList[0]; }
 
diff --git a/RSDKv4/Audio.cpp b/RSDKv4/Audio.cpp
index 8cfa77c..4865073 100644
--- a/RSDKv4/Audio.cpp
+++ b/RSDKv4/Audio.cpp
@@ -6,8 +6,8 @@ int stageSFXCount  = 0;
 
 int masterVolume  = MAX_VOLUME;
 int trackID       = -1;
-int sfxVolume     = MAX_VOLUME;
-int bgmVolume     = MAX_VOLUME;
+int sfxVolume     = 40;
+int bgmVolume     = 40;
 bool audioEnabled = false;
 
 bool musicEnabled = 0;
@@ -33,6 +33,7 @@ int currentMusicTrack = -1;
 
 #if RETRO_USING_SDL2
 SDL_AudioDeviceID audioDevice;
+SDL_AudioStream *ogv_stream;
 #endif
 SDL_AudioSpec audioDeviceFormat;
 
@@ -67,6 +68,14 @@ int InitAudioPlayback()
         audioEnabled = false;
         return true; // no audio but game wont crash now
     }
+
+    ogv_stream = SDL_NewAudioStream(AUDIO_F32SYS, 2, 48000, audioDeviceFormat.format, audioDeviceFormat.channels, audioDeviceFormat.freq);
+    if (!ogv_stream) {
+        PrintLog("Failed to create stream: %s", SDL_GetError());
+        SDL_CloseAudioDevice(audioDevice);
+        audioEnabled = false;
+        return true;
+    }
 #elif RETRO_USING_SDL1
     if (SDL_OpenAudio(&want, &audioDeviceFormat) == 0) {
         audioEnabled = true;
@@ -222,6 +231,7 @@ void ProcessMusicStream(Sint32 *stream, size_t bytes_wanted)
                     }
                     else {
                         musicStatus = MUSIC_STOPPED;
+						trackID = -1;
                         break;
                     }
                 }
@@ -259,6 +269,7 @@ void ProcessMusicStream(Sint32 *stream, size_t bytes_wanted)
                     }
                     else {
                         musicStatus = MUSIC_STOPPED;
+						trackID = -1;
                         break;
                     }
                 }
@@ -333,6 +344,87 @@ void ProcessAudioPlayback(void *userdata, Uint8 *stream, int len)
         // Mix music
         ProcessMusicStream(mix_buffer, samples_to_do * sizeof(Sint16));
 
+#if RETRO_USING_SDL2
+        if (videoPlaying == 1) {
+            const size_t bytes_to_do = samples_to_do * sizeof(Sint16);
+
+            const THEORAPLAY_AudioPacket *packet;
+
+            while ((packet = THEORAPLAY_getAudio(videoDecoder)) != NULL) {
+                SDL_AudioStreamPut(ogv_stream, packet->samples, packet->frames * sizeof(float) * 2);
+                THEORAPLAY_freeAudio(packet);
+            }
+
+            Sint16 buffer[MIX_BUFFER_SAMPLES];
+
+            if (SDL_AudioStreamAvailable(ogv_stream) < bytes_to_do) {
+                SDL_AudioStreamFlush(ogv_stream);
+            }
+
+            int get = SDL_AudioStreamGet(ogv_stream, buffer, (int)bytes_to_do);
+
+            if (get != -1) {
+                ProcessAudioMixing(mix_buffer, buffer, get / sizeof(Sint16), bgmVolume, 0);
+            }
+        } else {
+            SDL_AudioStreamClear(ogv_stream);
+        }
+#endif
+
+#if RETRO_USING_SDL1
+        // Process music being played by a video
+        // TODO: SDL1.2 lacks SDL_AudioStream so until someone finds good way to replicate that, I'm gonna leave this commented out
+        /*if (videoPlaying) {
+            // Fetch THEORAPLAY audio packets
+            const size_t bytes_to_do = samples_to_do * sizeof(Sint16);
+            size_t bytes_done        = 0;
+
+            byte *vid_buffer             = (byte *)malloc(bytes_to_do);
+            memset(vid_buffer, 0, bytes_to_do);
+
+            const THEORAPLAY_AudioPacket *packet;
+
+            while ((packet = THEORAPLAY_getAudio(videoDecoder)) != NULL) {
+                int data_size = packet->frames * sizeof(float) * 2;
+                if (bytes_done < bytes_to_do) {
+                    memcpy(vid_buffer + bytes_done, packet->samples, data_size >= bytes_to_do ? bytes_to_do : data_size); // 2 for stereo
+                    bytes_done += data_size >= bytes_to_do ? bytes_to_do : data_size;
+                }
+                THEORAPLAY_freeAudio(packet);
+            }
+
+            Sint16 convBuffer[MIX_BUFFER_SAMPLES];
+
+            // If we need more samples, assume we've reached the end of the file,
+            // and flush the audio stream so we can get more. If we were wrong, and
+            // there's still more file left, then there will be a gap in the audio. Sorry.
+            if (bytes_done < bytes_to_do) {
+                memset(vid_buffer, 0, bytes_to_do);
+            }
+
+            if (bytes_done > 0) {
+                SDL_AudioCVT convert;
+                MEM_ZERO(convert);
+                int cvtResult =
+                    SDL_BuildAudioCVT(&convert, AUDIO_S16SYS, 2, 48000, audioDeviceFormat.format, audioDeviceFormat.channels, audioDeviceFormat.freq);
+                if (cvtResult == 0) {
+                    if (convert.len_mult > 0) {
+                        convert.buf = (byte *)malloc(bytes_done * convert.len_mult);
+                        convert.len = bytes_done;
+                        memcpy(convert.buf, vid_buffer, bytes_done);
+                        SDL_ConvertAudio(&convert);
+                    }
+                }
+
+                if (cvtResult == 0)
+                    ProcessAudioMixing(mix_buffer, (const Sint16 *)convert.buf, bytes_done / sizeof(Sint16), MAX_VOLUME, 0);
+
+                if (convert.len > 0 && convert.buf)
+                    free(convert.buf);
+            }
+        }*/
+#endif
+
         // Mix SFX
         for (byte i = 0; i < CHANNEL_COUNT; ++i) {
             ChannelInfo *sfx = &sfxChannels[i];
@@ -510,6 +602,7 @@ void LoadMusic(void *userdata)
         }
         else {
             musicStatus = MUSIC_STOPPED;
+			trackID = -1;
             PrintLog("Failed to load vorbis! error: %d", error);
             switch (error) {
                 default: PrintLog("Vorbis open error: Unknown (%d)", error); break;
@@ -523,6 +616,7 @@ void LoadMusic(void *userdata)
     }
     else {
         musicStatus = MUSIC_STOPPED;
+		trackID = -1;
     }
     UnlockAudioDevice();
 }
diff --git a/RSDKv4/Audio.hpp b/RSDKv4/Audio.hpp
index b257ad9..6786465 100644
--- a/RSDKv4/Audio.hpp
+++ b/RSDKv4/Audio.hpp
@@ -11,7 +11,7 @@
 
 #define MAX_VOLUME (100)
 
-#define MUSBUFFER_SIZE   (0x200000)
+#define MUSBUFFER_SIZE   (0x2000000)
 #define STREAMFILE_COUNT (2)
 
 #define MIX_BUFFER_SAMPLES (256)
@@ -119,7 +119,7 @@ void ProcessAudioMixing(Sint32 *dst, const Sint16 *src, int len, int volume, sby
 #endif
 
 #if !RETRO_USE_ORIGINAL_CODE
-inline void FreeMusInfo()
+inline void freeMusInfo()
 {
     LockAudioDevice();
 
@@ -144,7 +144,7 @@ void ProcessAudioPlayback() {}
 void ProcessAudioMixing() {}
 
 #if !RETRO_USE_ORIGINAL_CODE
-inline void FreeMusInfo() { ov_clear(&streamInfo[currentStreamIndex].vorbisFile); }
+inline void freeMusInfo() { ov_clear(&streamInfo[currentStreamIndex].vorbisFile); }
 #endif
 #endif
 
@@ -154,13 +154,15 @@ void SwapMusicTrack(const char *filePath, byte trackID, uint loopPoint, uint rat
 bool PlayMusic(int track, int musStartPos);
 inline void StopMusic(bool setStatus)
 {
-    if (setStatus)
+    if (setStatus) {
         musicStatus = MUSIC_STOPPED;
+		trackID = -1;
+	}
     musicPosition = 0;
 
 #if !RETRO_USE_ORIGINAL_CODE
     LockAudioDevice();
-    FreeMusInfo();
+    freeMusInfo();
     UnlockAudioDevice();
 #endif
 }
diff --git a/RSDKv4/Collision.cpp b/RSDKv4/Collision.cpp
index a7a6cb2..b2ef7ef 100644
--- a/RSDKv4/Collision.cpp
+++ b/RSDKv4/Collision.cpp
@@ -7,6 +7,8 @@ int collisionBottom = 0;
 
 int collisionTolerance = 0;
 
+int crushForgive = 0x20000;
+
 CollisionSensor sensors[RETRO_REV00 ? 6 : 7];
 
 #if !RETRO_USE_ORIGINAL_CODE
@@ -15,7 +17,7 @@ byte showHitboxes = 0;
 int debugHitboxCount = 0;
 DebugHitboxInfo debugHitboxList[DEBUG_HITBOX_COUNT];
 
-int AddDebugHitbox(byte type, Entity *entity, int left, int top, int right, int bottom)
+int addDebugHitbox(byte type, Entity *entity, int left, int top, int right, int bottom)
 {
     int i = 0;
     for (; i < debugHitboxCount; ++i) {
@@ -47,7 +49,7 @@ int AddDebugHitbox(byte type, Entity *entity, int left, int top, int right, int
 }
 #endif
 
-inline Hitbox *GetHitbox(Entity *entity)
+inline Hitbox *getHitbox(Entity *entity)
 {
     AnimationFile *thisAnim = objectScriptList[entity->type].animFile;
     return &hitboxList[thisAnim->hitboxListOffset
@@ -711,7 +713,7 @@ void RWallCollision(Entity *player, CollisionSensor *sensor)
 
 void ProcessAirCollision(Entity *entity)
 {
-    Hitbox *playerHitbox = GetHitbox(entity);
+    Hitbox *playerHitbox = getHitbox(entity);
     collisionLeft        = playerHitbox->left[0];
     collisionTop         = playerHitbox->top[0];
     collisionRight       = playerHitbox->right[0];
@@ -1512,7 +1514,7 @@ void ProcessPathGrip(Entity *entity)
 
 void SetPathGripSensors(Entity *player)
 {
-    Hitbox *playerHitbox = GetHitbox(player);
+    Hitbox *playerHitbox = getHitbox(player);
 
     switch (player->collisionMode) {
         case CMODE_FLOOR: {
@@ -2146,174 +2148,43 @@ void ObjectRWallGrip(int xOffset, int yOffset, int cPath)
         scriptEng.checkResult = false;
     }
 }
-#if RETRO_REV03
-void ObjectLEntityGrip(int xOffset, int yOffset, int cPath)
-{
-    scriptEng.checkResult = false;
-    Entity *entity        = &objectEntityList[objectEntityPos];
-    int mBlockID          = entity->values[44];
-    int XPos              = (entity->xpos >> 16) + xOffset - 16;
-    int YPos              = (entity->ypos >> 16) + yOffset;
-    int check             = 0;
-    if (mBlockID > 0 && objectTypeGroupList[mBlockID].listSize > 0) {
-        TypeGroupList *mBlockGroupList = &objectTypeGroupList[mBlockID];
-        for (int i = 0; i < objectTypeGroupList[mBlockID].listSize; i++) {
-            short entRef        = mBlockGroupList->entityRefs[i];
-            Entity *otherEntity = &objectEntityList[entRef];
-            int XPos2           = otherEntity->xpos >> 16;
-            int YPos2           = otherEntity->ypos >> 16;
-            if (((((XPos2 - 16) <= XPos) && (XPos <= (XPos2 + 16))) && ((YPos2 - 16) <= YPos)) && (YPos <= (YPos2 + 16))) {
-                entity->xpos = otherEntity->xpos - (xOffset << 16) - 0x100000;
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        check                 = 1;
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
-            if ((((XPos2 - 16) <= (XPos + 16) && ((XPos + 16) <= (XPos2 + 16))) && (YPos2 - 16) <= YPos) && (YPos <= (YPos2 + 16))) {
-                entity->xpos = otherEntity->xpos - (xOffset << 16) - 0x100000;
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
 
-            if (((XPos2 <= (XPos + 32)) && ((XPos + 32) <= (XPos2 + 16))) && (((YPos2 - 16) <= YPos && YPos <= (YPos2 + 16)))) {
-                entity->xpos = otherEntity->xpos - (xOffset << 16) - 0x100000;
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        check                 = 1;
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
-
-            if (check != 0) {
-                return;
-            }
-        }
-    }
-    ObjectLWallGrip(xOffset, yOffset, cPath);
-}
-void ObjectREntityGrip(int xOffset, int yOffset, int cPath)
-{
-    scriptEng.checkResult = false;
-    Entity *entity        = &objectEntityList[objectEntityPos];
-    int mBlockID          = entity->values[44];
-    int XPos              = (entity->xpos >> 16) + xOffset + 16;
-    int YPos              = (entity->ypos >> 16) + yOffset;
-    int check             = 0;
-    if (mBlockID > 0 && objectTypeGroupList[mBlockID].listSize > 0) {
-        TypeGroupList *mBlockGroupList = &objectTypeGroupList[mBlockID];
-        for (int i = 0; i < objectTypeGroupList[mBlockID].listSize; i++) {
-            short entRef        = mBlockGroupList->entityRefs[i];
-            Entity *otherEntity = &objectEntityList[entRef];
-            int XPos2           = otherEntity->xpos >> 16;
-            int YPos2           = otherEntity->ypos >> 16;
-            if (((((XPos2 - 16) <= XPos) && (XPos <= (XPos2 + 16))) && ((YPos2 - 16) <= YPos)) && (YPos <= (YPos2 + 16))) {
-                entity->xpos = otherEntity->xpos + ((16 - xOffset) << 16);
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        check                 = 1;
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
-            if ((((XPos2 - 16) <= (XPos + 16) && ((XPos - 16) <= (XPos2 + 16))) && (YPos2 - 16) <= YPos) && (YPos <= (YPos2 + 16))) {
-                entity->xpos = otherEntity->xpos + ((16 - xOffset) << 16);
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
-
-            if (((XPos2 <= (XPos - 32)) && ((XPos - 32) <= (XPos2 + 16))) && (((YPos2 - 16) <= YPos && YPos <= (YPos2 + 16)))) {
-                entity->xpos = otherEntity->xpos + ((16 - xOffset) << 16);
-                if (otherEntity->values[0] == 0) {
-                    check                 = 2;
-                    scriptEng.checkResult = check;
-                }
-                else {
-                    scriptEng.checkResult = check;
-                    if (check != 2) {
-                        check                 = 1;
-                        scriptEng.checkResult = check;
-                    }
-                }
-            }
-
-            if (check != 0) {
-                return;
-            }
-        }
-    }
-    ObjectRWallGrip(xOffset, yOffset, cPath);
-}
-#endif
 void TouchCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight, int thisBottom, Entity *otherEntity, int otherLeft, int otherTop,
                     int otherRight, int otherBottom)
 {
-    Hitbox *thisHitbox  = GetHitbox(thisEntity);
-    Hitbox *otherHitbox = GetHitbox(otherEntity);
+    Hitbox *thisHitbox  = getHitbox(thisEntity);
+    Hitbox *otherHitbox = getHitbox(otherEntity);
 
-    if (thisLeft == C_BOX)
+    if (thisLeft == 0x10000)
         thisLeft = thisHitbox->left[0];
 
-    if (thisTop == C_BOX)
+    if (thisTop == 0x10000)
         thisTop = thisHitbox->top[0];
 
-    if (thisRight == C_BOX)
+    if (thisRight == 0x10000)
         thisRight = thisHitbox->right[0];
 
-    if (thisBottom == C_BOX)
+    if (thisBottom == 0x10000)
         thisBottom = thisHitbox->bottom[0];
 
-    if (otherLeft == C_BOX)
+    if (otherLeft == 0x10000)
         otherLeft = otherHitbox->left[0];
 
-    if (otherTop == C_BOX)
+    if (otherTop == 0x10000)
         otherTop = otherHitbox->top[0];
 
-    if (otherRight == C_BOX)
+    if (otherRight == 0x10000)
         otherRight = otherHitbox->right[0];
 
-    if (otherBottom == C_BOX)
+    if (otherBottom == 0x10000)
         otherBottom = otherHitbox->bottom[0];
 
 #if !RETRO_USE_ORIGINAL_CODE
     int thisHitboxID  = 0;
     int otherHitboxID = 0;
     if (showHitboxes) {
-        thisHitboxID  = AddDebugHitbox(H_TYPE_TOUCH, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
-        otherHitboxID = AddDebugHitbox(H_TYPE_TOUCH, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
+        thisHitboxID  = addDebugHitbox(H_TYPE_TOUCH, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
+        otherHitboxID = addDebugHitbox(H_TYPE_TOUCH, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
     }
 #endif
 
@@ -2341,39 +2212,39 @@ void TouchCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight
 void BoxCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight, int thisBottom, Entity *otherEntity, int otherLeft, int otherTop,
                   int otherRight, int otherBottom)
 {
-    Hitbox *thisHitbox  = GetHitbox(thisEntity);
-    Hitbox *otherHitbox = GetHitbox(otherEntity);
+    Hitbox *thisHitbox  = getHitbox(thisEntity);
+    Hitbox *otherHitbox = getHitbox(otherEntity);
 
-    if (thisLeft == C_BOX)
+    if (thisLeft == 0x10000)
         thisLeft = thisHitbox->left[0];
 
-    if (thisTop == C_BOX)
+    if (thisTop == 0x10000)
         thisTop = thisHitbox->top[0];
 
-    if (thisRight == C_BOX)
+    if (thisRight == 0x10000)
         thisRight = thisHitbox->right[0];
 
-    if (thisBottom == C_BOX)
+    if (thisBottom == 0x10000)
         thisBottom = thisHitbox->bottom[0];
 
-    if (otherLeft == C_BOX)
+    if (otherLeft == 0x10000)
         otherLeft = otherHitbox->left[0];
 
-    if (otherTop == C_BOX)
+    if (otherTop == 0x10000)
         otherTop = otherHitbox->top[0];
 
-    if (otherRight == C_BOX)
+    if (otherRight == 0x10000)
         otherRight = otherHitbox->right[0];
 
-    if (otherBottom == C_BOX)
+    if (otherBottom == 0x10000)
         otherBottom = otherHitbox->bottom[0];
 
 #if !RETRO_USE_ORIGINAL_CODE
     int thisHitboxID  = 0;
     int otherHitboxID = 0;
     if (showHitboxes) {
-        thisHitboxID  = AddDebugHitbox(H_TYPE_BOX, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
-        otherHitboxID = AddDebugHitbox(H_TYPE_BOX, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
+        thisHitboxID  = addDebugHitbox(H_TYPE_BOX, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
+        otherHitboxID = addDebugHitbox(H_TYPE_BOX, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
     }
 #endif
 
@@ -2444,8 +2315,8 @@ void BoxCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
         else {
             sensors[0].collided = false;
             sensors[1].collided = false;
-            sensors[0].xpos     = rx + otherLeft + 0x20000;
-            sensors[1].xpos     = rx + otherRight - 0x20000;
+            sensors[0].xpos     = rx + otherLeft + crushForgive;
+            sensors[1].xpos     = rx + otherRight - crushForgive;
 
             sensors[0].ypos = ry + otherTop;
 
@@ -2623,8 +2494,8 @@ void BoxCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
                 else {
                     sensors[0].collided = false;
                     sensors[1].collided = false;
-                    sensors[0].xpos     = rx + otherLeft + 0x20000;
-                    sensors[1].xpos     = rx + otherRight - 0x20000;
+                    sensors[0].xpos     = rx + otherLeft + crushForgive;
+                    sensors[1].xpos     = rx + otherRight - crushForgive;
                     sensors[0].ypos     = ry + otherTop;
 
                     for (int i = 0; i < 2; ++i) {
@@ -2659,39 +2530,39 @@ void BoxCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
 void BoxCollision2(Entity *thisEntity, int thisLeft, int thisTop, int thisRight, int thisBottom, Entity *otherEntity, int otherLeft, int otherTop,
                    int otherRight, int otherBottom)
 {
-    Hitbox *thisHitbox  = GetHitbox(thisEntity);
-    Hitbox *otherHitbox = GetHitbox(otherEntity);
+    Hitbox *thisHitbox  = getHitbox(thisEntity);
+    Hitbox *otherHitbox = getHitbox(otherEntity);
 
-    if (thisLeft == C_BOX)
+    if (thisLeft == 0x10000)
         thisLeft = thisHitbox->left[0];
 
-    if (thisTop == C_BOX)
+    if (thisTop == 0x10000)
         thisTop = thisHitbox->top[0];
 
-    if (thisRight == C_BOX)
+    if (thisRight == 0x10000)
         thisRight = thisHitbox->right[0];
 
-    if (thisBottom == C_BOX)
+    if (thisBottom == 0x10000)
         thisBottom = thisHitbox->bottom[0];
 
-    if (otherLeft == C_BOX)
+    if (otherLeft == 0x10000)
         otherLeft = otherHitbox->left[0];
 
-    if (otherTop == C_BOX)
+    if (otherTop == 0x10000)
         otherTop = otherHitbox->top[0];
 
-    if (otherRight == C_BOX)
+    if (otherRight == 0x10000)
         otherRight = otherHitbox->right[0];
 
-    if (otherBottom == C_BOX)
+    if (otherBottom == 0x10000)
         otherBottom = otherHitbox->bottom[0];
 
 #if !RETRO_USE_ORIGINAL_CODE
     int thisHitboxID  = 0;
     int otherHitboxID = 0;
     if (showHitboxes) {
-        thisHitboxID  = AddDebugHitbox(H_TYPE_BOX, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
-        otherHitboxID = AddDebugHitbox(H_TYPE_BOX, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
+        thisHitboxID  = addDebugHitbox(H_TYPE_BOX, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
+        otherHitboxID = addDebugHitbox(H_TYPE_BOX, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
     }
 #endif
 
@@ -2733,7 +2604,7 @@ void BoxCollision2(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
         sensors[0].ypos = ry + otherBottom;
 
         if (otherEntity->yvel >= 0) {
-            // this should prolly be using all 5 sensors, but this was barely used in S2 so it was prolly forgotten about
+            // this should prolly be using all 5 sensors, but this was unused in S2 so it was prolly forgotten about
             for (int i = 0; i < 3; ++i) {
                 if (thisLeft < sensors[i].xpos && thisRight > sensors[i].xpos && thisTop <= sensors[0].ypos && thisEntity->ypos > sensors[0].ypos) {
                     sensors[i].collided          = true;
@@ -2758,8 +2629,8 @@ void BoxCollision2(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
         else {
             sensors[0].collided = false;
             sensors[1].collided = false;
-            sensors[0].xpos     = rx + otherLeft + 0x20000;
-            sensors[1].xpos     = rx + otherRight - 0x20000;
+            sensors[0].xpos     = rx + otherLeft + crushForgive;
+            sensors[1].xpos     = rx + otherRight - crushForgive;
 
             sensors[0].ypos = ry + otherTop;
 
@@ -2922,8 +2793,8 @@ void BoxCollision2(Entity *thisEntity, int thisLeft, int thisTop, int thisRight,
                 else {
                     sensors[0].collided = false;
                     sensors[1].collided = false;
-                    sensors[0].xpos     = rx + otherLeft + 0x20000;
-                    sensors[1].xpos     = rx + otherRight - 0x20000;
+                    sensors[0].xpos     = rx + otherLeft + crushForgive;
+                    sensors[1].xpos     = rx + otherRight - crushForgive;
 
                     sensors[0].ypos = ry + otherTop;
 
@@ -2965,39 +2836,39 @@ void PlatformCollision(Entity *thisEntity, int thisLeft, int thisTop, int thisRi
 {
     scriptEng.checkResult = false;
 
-    Hitbox *thisHitbox  = GetHitbox(thisEntity);
-    Hitbox *otherHitbox = GetHitbox(otherEntity);
+    Hitbox *thisHitbox  = getHitbox(thisEntity);
+    Hitbox *otherHitbox = getHitbox(otherEntity);
 
-    if (thisLeft == C_BOX)
+    if (thisLeft == 0x10000)
         thisLeft = thisHitbox->left[0];
 
-    if (thisTop == C_BOX)
+    if (thisTop == 0x10000)
         thisTop = thisHitbox->top[0];
 
-    if (thisRight == C_BOX)
+    if (thisRight == 0x10000)
         thisRight = thisHitbox->right[0];
 
-    if (thisBottom == C_BOX)
+    if (thisBottom == 0x10000)
         thisBottom = thisHitbox->bottom[0];
 
-    if (otherLeft == C_BOX)
+    if (otherLeft == 0x10000)
         otherLeft = otherHitbox->left[0];
 
-    if (otherTop == C_BOX)
+    if (otherTop == 0x10000)
         otherTop = otherHitbox->top[0];
 
-    if (otherRight == C_BOX)
+    if (otherRight == 0x10000)
         otherRight = otherHitbox->right[0];
 
-    if (otherBottom == C_BOX)
+    if (otherBottom == 0x10000)
         otherBottom = otherHitbox->bottom[0];
 
 #if !RETRO_USE_ORIGINAL_CODE
     int thisHitboxID  = 0;
     int otherHitboxID = 0;
     if (showHitboxes) {
-        thisHitboxID  = AddDebugHitbox(H_TYPE_PLAT, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
-        otherHitboxID = AddDebugHitbox(H_TYPE_PLAT, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
+        thisHitboxID  = addDebugHitbox(H_TYPE_PLAT, thisEntity, thisLeft, thisTop, thisRight, thisBottom);
+        otherHitboxID = addDebugHitbox(H_TYPE_PLAT, otherEntity, otherLeft, otherTop, otherRight, otherBottom);
     }
 #endif
 
diff --git a/RSDKv4/Collision.hpp b/RSDKv4/Collision.hpp
index 40ada74..9f0ff31 100644
--- a/RSDKv4/Collision.hpp
+++ b/RSDKv4/Collision.hpp
@@ -1,15 +1,11 @@
 #ifndef COLLISION_H
 #define COLLISION_H
 
-enum CollisionSides {
-    CSIDE_FLOOR   = 0,
-    CSIDE_LWALL   = 1,
-    CSIDE_RWALL   = 2,
-    CSIDE_ROOF    = 3,
-#if RETRO_REV03
-    CSIDE_LENTITY = 4, // Added in Origins Plus
-    CSIDE_RENTITY = 5, // Added in Origins Plus
-#endif
+enum CollisionSidess {
+    CSIDE_FLOOR = 0,
+    CSIDE_LWALL = 1,
+    CSIDE_RWALL = 2,
+    CSIDE_ROOF  = 3,
 };
 
 enum CollisionModes {
@@ -29,15 +25,11 @@ enum CollisionSolidity {
 
 enum ObjectCollisionTypes {
     C_TOUCH    = 0,
-    C_SOLID    = 1,
-    C_SOLID2   = 2,
+    C_BOX      = 1,
+    C_BOX2     = 2,
     C_PLATFORM = 3,
 };
 
-enum ObjectCollisionFlags {
-    C_BOX = 0x10000,
-};
-
 struct CollisionSensor {
     int xpos;
     int ypos;
@@ -66,7 +58,7 @@ extern byte showHitboxes;
 extern int debugHitboxCount;
 extern DebugHitboxInfo debugHitboxList[DEBUG_HITBOX_COUNT];
 
-int AddDebugHitbox(byte type, Entity *entity, int left, int top, int right, int bottom);
+int addDebugHitbox(byte type, Entity *entity, int left, int top, int right, int bottom);
 #endif
 
 extern int collisionLeft;
@@ -112,9 +104,5 @@ void ObjectFloorGrip(int xOffset, int yOffset, int cPath);
 void ObjectLWallGrip(int xOffset, int yOffset, int cPath);
 void ObjectRoofGrip(int xOffset, int yOffset, int cPath);
 void ObjectRWallGrip(int xOffset, int yOffset, int cPath);
-#if RETRO_REV03
-void ObjectLEntityGrip(int xOffset, int yOffset, int cPath); // Added in Origins Plus
-void ObjectREntityGrip(int xOffset, int yOffset, int cPath); // Added in Origins Plus
-#endif
 
 #endif // !COLLISION_H
diff --git a/RSDKv4/Debug.cpp b/RSDKv4/Debug.cpp
index 8991b22..929e17c 100644
--- a/RSDKv4/Debug.cpp
+++ b/RSDKv4/Debug.cpp
@@ -75,8 +75,8 @@ void ProcessStageSelect()
 {
     ClearScreen(0xF0);
 
-    CheckKeyDown(&keyDown);
-    CheckKeyPress(&keyPress);
+    CheckKeyDown(&inputDown);
+    CheckKeyPress(&inputPress);
 
 #if defined RETRO_USING_MOUSE || defined RETRO_USING_TOUCH
     DrawSprite(32, 0x42, 16, 16, 78, 240, textMenuSurfaceNo);
@@ -84,7 +84,7 @@ void ProcessStageSelect()
     DrawSprite(SCREEN_XSIZE - 32, SCREEN_YSIZE - 32, 16, 16, 112, 240, textMenuSurfaceNo);
 #endif
 
-    if (!keyDown.start && !keyDown.up && !keyDown.down) {
+    if (!inputDown.start && !inputDown.up && !inputDown.down) {
         int tFlags = touchFlags;
         touchFlags = 0;
 
@@ -93,13 +93,13 @@ void ProcessStageSelect()
                 if (touchX[t] < SCREEN_CENTERX) {
                     if (touchY[t] >= SCREEN_CENTERY) {
                         if (!(tFlags & 2))
-                            keyPress.down = true;
+                            inputPress.down = true;
                         else
                             touchFlags |= 1 << 1;
                     }
                     else {
                         if (!(tFlags & 1))
-                            keyPress.up = true;
+                            inputPress.up = true;
                         else
                             touchFlags |= 1 << 0;
                     }
@@ -107,13 +107,13 @@ void ProcessStageSelect()
                 else if (touchX[t] > SCREEN_CENTERX) {
                     if (touchY[t] > SCREEN_CENTERY) {
                         if (!(tFlags & 4))
-                            keyPress.start = true;
+                            inputPress.start = true;
                         else
                             touchFlags |= 1 << 2;
                     }
                     else {
                         if (!(tFlags & 8))
-                            keyPress.B = true;
+                            inputPress.B = true;
                         else
                             touchFlags |= 1 << 3;
                     }
@@ -121,19 +121,19 @@ void ProcessStageSelect()
             }
         }
 
-        touchFlags |= (int)keyPress.up << 0;
-        touchFlags |= (int)keyPress.down << 1;
-        touchFlags |= (int)keyPress.start << 2;
-        touchFlags |= (int)keyPress.B << 3;
+        touchFlags |= (int)inputPress.up << 0;
+        touchFlags |= (int)inputPress.down << 1;
+        touchFlags |= (int)inputPress.start << 2;
+        touchFlags |= (int)inputPress.B << 3;
     }
 
     switch (stageMode) {
         case DEVMENU_MAIN: // Main Menu
         {
-            if (keyPress.down)
+            if (inputPress.down)
                 gameMenu[0].selection2 += 2;
 
-            if (keyPress.up)
+            if (inputPress.up)
                 gameMenu[0].selection2 -= 2;
 
             int count = 15;
@@ -147,7 +147,7 @@ void ProcessStageSelect()
                 gameMenu[0].selection2 = count;
 
             DrawTextMenu(&gameMenu[0], SCREEN_CENTERX, 72);
-            if (keyPress.start || keyPress.A) {
+            if (inputPress.start || inputPress.A) {
                 if (gameMenu[0].selection2 == 9) {
                     ClearGraphicsData();
                     ClearAnimationData();
@@ -185,9 +185,7 @@ void ProcessStageSelect()
                     else {
 #endif
                         CREATE_ENTITY(SegaSplash);
-#if !RETRO_USE_ORIGINAL_CODE
                     }
-#endif
                 }
 #if RETRO_USE_MOD_LOADER
                 else if (gameMenu[0].selection2 == 15) {
@@ -199,11 +197,11 @@ void ProcessStageSelect()
 #if RETRO_USE_MOD_LOADER
                     ExitGame();
 #else
-                    Engine.running = false;
+                Engine.running = false;
 #endif
                 }
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 ClearGraphicsData();
                 ClearAnimationData();
                 activeStageList   = 0;
@@ -215,9 +213,9 @@ void ProcessStageSelect()
         }
         case DEVMENU_PLAYERSEL: // Selecting Player
         {
-            if (keyPress.down)
+            if (inputPress.down)
                 ++gameMenu[1].selection1;
-            if (keyPress.up)
+            if (inputPress.up)
                 --gameMenu[1].selection1;
             if (gameMenu[1].selection1 == gameMenu[1].rowCount)
                 gameMenu[1].selection1 = 0;
@@ -227,20 +225,20 @@ void ProcessStageSelect()
 
             DrawTextMenu(&gameMenu[0], SCREEN_CENTERX - 4, 72);
             DrawTextMenu(&gameMenu[1], SCREEN_CENTERX - 40, 96);
-            if (keyPress.start || keyPress.A) {
+            if (inputPress.start || inputPress.A) {
                 playerListPos = gameMenu[1].selection1;
                 SetTextMenu(DEVMENU_STAGELISTSEL);
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 SetTextMenu(DEVMENU_MAIN);
             }
             break;
         }
         case DEVMENU_STAGELISTSEL: // Selecting Category
         {
-            if (keyPress.down)
+            if (inputPress.down)
                 gameMenu[0].selection2 += 2;
-            if (keyPress.up)
+            if (inputPress.up)
                 gameMenu[0].selection2 -= 2;
 
             if (gameMenu[0].selection2 > 9)
@@ -275,7 +273,7 @@ void ProcessStageSelect()
                 default: break;
             }
 
-            if ((keyPress.start || keyPress.A) && nextMenu) {
+            if ((inputPress.start || inputPress.A) && nextMenu) {
                 SetupTextMenu(&gameMenu[0], 0);
                 AddTextMenuEntry(&gameMenu[0], "SELECT A STAGE");
                 SetupTextMenu(&gameMenu[1], 0);
@@ -293,7 +291,7 @@ void ProcessStageSelect()
                 gameMenu[1].timer          = 0;
                 stageMode                  = DEVMENU_STAGESEL;
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 SetupTextMenu(&gameMenu[0], 0);
                 AddTextMenuEntry(&gameMenu[0], "SELECT A PLAYER");
                 SetupTextMenu(&gameMenu[1], 0);
@@ -310,32 +308,32 @@ void ProcessStageSelect()
         }
         case DEVMENU_STAGESEL: // Selecting Stage
         {
-            if (keyDown.down) {
+            if (inputDown.down) {
                 gameMenu[1].timer += 1;
                 if (gameMenu[1].timer > 8) {
                     gameMenu[1].timer = 0;
-                    keyPress.down   = true;
+                    inputPress.down   = true;
                 }
             }
             else {
-                if (keyDown.up) {
+                if (inputDown.up) {
                     gameMenu[1].timer -= 1;
                     if (gameMenu[1].timer < -8) {
                         gameMenu[1].timer = 0;
-                        keyPress.up     = true;
+                        inputPress.up     = true;
                     }
                 }
                 else {
                     gameMenu[1].timer = 0;
                 }
             }
-            if (keyPress.down) {
+            if (inputPress.down) {
                 gameMenu[1].selection1++;
                 if (gameMenu[1].selection1 - gameMenu[1].visibleRowOffset >= gameMenu[1].visibleRowCount) {
                     gameMenu[1].visibleRowOffset += 1;
                 }
             }
-            if (keyPress.up) {
+            if (inputPress.up) {
                 gameMenu[1].selection1--;
                 if (gameMenu[1].selection1 - gameMenu[1].visibleRowOffset < 0) {
                     gameMenu[1].visibleRowOffset -= 1;
@@ -352,8 +350,8 @@ void ProcessStageSelect()
 
             DrawTextMenu(&gameMenu[0], SCREEN_CENTERX - 4, 40);
             DrawTextMenu(&gameMenu[1], SCREEN_CENTERX + 100, 64);
-            if (keyPress.start || keyPress.A) {
-                debugMode         = keyDown.A;
+            if (inputPress.start || inputPress.A) {
+                debugMode         = inputDown.A;
                 stageMode         = STAGEMODE_LOAD;
                 Engine.gameMode   = ENGINE_MAINGAME;
                 stageListPosition = gameMenu[1].selection1;
@@ -361,7 +359,7 @@ void ProcessStageSelect()
                 SetGlobalVariableByName("lampPostID", 0); // For S1
                 SetGlobalVariableByName("starPostID", 0); // For S2
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 SetTextMenu(DEVMENU_STAGELISTSEL);
             }
             break;
@@ -369,10 +367,10 @@ void ProcessStageSelect()
         case DEVMENU_SCRIPTERROR: // Script Error
         {
             DrawTextMenu(&gameMenu[0], SCREEN_CENTERX, 72);
-            if (keyPress.start || keyPress.A) {
+            if (inputPress.start || inputPress.A) {
                 SetTextMenu(DEVMENU_MAIN);
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 ClearGraphicsData();
                 ClearAnimationData();
                 activeStageList   = 0;
@@ -380,7 +378,7 @@ void ProcessStageSelect()
                 Engine.gameMode   = ENGINE_MAINGAME;
                 stageListPosition = 0;
             }
-            else if (keyPress.C) {
+            else if (inputPress.C) {
                 ClearGraphicsData();
                 ClearAnimationData();
                 stageMode       = STAGEMODE_LOAD;
@@ -392,19 +390,19 @@ void ProcessStageSelect()
         case DEVMENU_MODMENU: // Mod Menu
         {
             int preOption = gameMenu[1].selection1;
-            if (keyDown.down) {
+            if (inputDown.down) {
                 gameMenu[1].timer++;
                 if (gameMenu[1].timer > 8) {
                     gameMenu[1].timer = 0;
-                    keyPress.down   = true;
+                    inputPress.down   = true;
                 }
             }
             else {
-                if (keyDown.up) {
+                if (inputDown.up) {
                     gameMenu[1].timer--;
                     if (gameMenu[1].timer < -8) {
                         gameMenu[1].timer = 0;
-                        keyPress.up     = true;
+                        inputPress.up     = true;
                     }
                 }
                 else {
@@ -412,14 +410,14 @@ void ProcessStageSelect()
                 }
             }
 
-            if (keyPress.down) {
+            if (inputPress.down) {
                 gameMenu[1].selection1++;
                 if (gameMenu[1].selection1 - gameMenu[1].visibleRowOffset >= gameMenu[1].visibleRowCount) {
                     gameMenu[1].visibleRowOffset++;
                 }
             }
 
-            if (keyPress.up) {
+            if (inputPress.up) {
                 gameMenu[1].selection1--;
                 if (gameMenu[1].selection1 - gameMenu[1].visibleRowOffset < 0 && gameMenu[1].visibleRowOffset > 0) {
                     gameMenu[1].visibleRowOffset--;
@@ -427,7 +425,7 @@ void ProcessStageSelect()
             }
 
             if (gameMenu[1].selection1 >= gameMenu[1].rowCount) {
-                if (keyDown.C) {
+                if (inputDown.C) {
                     gameMenu[1].selection1--;
                     gameMenu[1].visibleRowOffset--;
                 }
@@ -438,7 +436,7 @@ void ProcessStageSelect()
             }
 
             if (gameMenu[1].selection1 < 0) {
-                if (keyDown.C) {
+                if (inputDown.C) {
                     gameMenu[1].selection1++;
                 }
                 else {
@@ -449,14 +447,14 @@ void ProcessStageSelect()
             gameMenu[1].selection2 = gameMenu[1].selection1; // its a bug fix LOL
 
             char buffer[0x100];
-            if (gameMenu[1].selection1 < modList.size() && (keyPress.A || keyPress.start || keyPress.left || keyPress.right)) {
+            if (gameMenu[1].selection1 < modList.size() && (inputPress.A || inputPress.start || inputPress.left || inputPress.right)) {
                 modList[gameMenu[1].selection1].active ^= 1;
                 StrCopy(buffer, modList[gameMenu[1].selection1].name.c_str());
                 StrAdd(buffer, ": ");
                 StrAdd(buffer, (modList[gameMenu[1].selection1].active ? "  Active" : "Inactive"));
                 EditTextMenuEntry(&gameMenu[1], buffer, gameMenu[1].selection1);
             }
-            else if (keyDown.C && gameMenu[1].selection1 != preOption) {
+            else if (inputDown.C && gameMenu[1].selection1 != preOption) {
                 int visibleOffset  = gameMenu[1].visibleRowOffset;
                 int option         = gameMenu[1].selection1;
                 ModInfo swap       = modList[preOption];
@@ -466,7 +464,7 @@ void ProcessStageSelect()
                 gameMenu[1].selection1       = option;
                 gameMenu[1].visibleRowOffset = visibleOffset;
             }
-            else if (keyPress.B) {
+            else if (inputPress.B) {
                 RefreshEngine();
 
                 if (Engine.modMenuCalled) {
@@ -505,18 +503,14 @@ void SetTextMenu(int sm)
     SetupTextMenu(&gameMenu[1], 0);
     switch (sm) {
         case DEVMENU_MAIN: {
-            AddTextMenuEntry(&gameMenu[0], "RETRO ENGINE DEV MENU");
+            AddTextMenuEntry(&gameMenu[0], Engine.gameWindowText);
             AddTextMenuEntry(&gameMenu[0], " ");
-            char version[0x80];
-            StrCopy(version, Engine.gameWindowText);
-            StrAdd(version, " Version");
-            AddTextMenuEntry(&gameMenu[0], version);
-            AddTextMenuEntry(&gameMenu[0], Engine.gameVersion);
-#ifdef RETRO_DEV_EXTRA
-            AddTextMenuEntry(&gameMenu[0], RETRO_DEV_EXTRA);
-#else
+            AddTextMenuEntry(&gameMenu[0], "RETRO ENGINE v4");
+            AddTextMenuEntry(&gameMenu[0], "DEV MENU");
+            //char version[0x80];
+            //StrCopy(version, "RSDK");
+            //StrAdd(version, Engine.gameVersion);
             AddTextMenuEntry(&gameMenu[0], " ");
-#endif
             AddTextMenuEntry(&gameMenu[0], " ");
             AddTextMenuEntry(&gameMenu[0], " ");
             AddTextMenuEntry(&gameMenu[0], " ");
@@ -569,7 +563,6 @@ void SetTextMenu(int sm)
                 StrAdd(buffer, ": ");
                 StrAdd(buffer, modList[m].active ? "  Active" : "Inactive");
                 AddTextMenuEntry(&gameMenu[1], buffer);
-                gameMenu[1].entryHighlight[m] = false;
             }
 
             gameMenu[1].alignment      = 1;
diff --git a/RSDKv4/Drawing.cpp b/RSDKv4/Drawing.cpp
index eaad86b..8b277ab 100644
--- a/RSDKv4/Drawing.cpp
+++ b/RSDKv4/Drawing.cpp
@@ -10,12 +10,13 @@ ushort tintLookupTable[0x10000];
 
 bool windowCreated = false;
 
-int SCREEN_XSIZE_CONFIG = 424;
-int SCREEN_XSIZE        = 424;
-int SCREEN_CENTERX      = 424 / 2;
+int CURRENT_DISP_SCREEN = 0;
+int SCREEN_XSIZE_CONFIG = 426;
+int SCREEN_XSIZE        = 426;
+int SCREEN_CENTERX      = 426 / 2;
 
-float SCREEN_XSIZE_F   = 424;
-float SCREEN_CENTERX_F = 424 / 2;
+float SCREEN_XSIZE_F   = 426;
+float SCREEN_CENTERX_F = 426 / 2;
 
 float SCREEN_YSIZE_F   = SCREEN_YSIZE;
 float SCREEN_CENTERY_F = SCREEN_YSIZE / 2;
@@ -39,6 +40,7 @@ bool mixFiltersOnJekyll = false;
 GLint defaultFramebuffer = -1;
 GLuint framebufferHiRes  = -1;
 GLuint renderbufferHiRes = -1;
+GLuint videoBuffer = -1;
 #endif
 
 #if !RETRO_USE_ORIGINAL_CODE
@@ -54,7 +56,7 @@ int InitRenderDevice()
 {
     char gameTitle[0x40];
 
-    sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : " (Using Data Folder)");
+    sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : "");
 
 #if !RETRO_USE_ORIGINAL_CODE
 #if RETRO_USING_SDL2
@@ -94,10 +96,13 @@ int InitRenderDevice()
     SCREEN_XSIZE = ((float)SCREEN_YSIZE * h / w);
     if (SCREEN_XSIZE % 2)
         ++SCREEN_XSIZE;
+
+    if (SCREEN_XSIZE >= 500)
+        SCREEN_XSIZE = 500;
 #endif
 
     SCREEN_CENTERX = SCREEN_XSIZE / 2;
-    Engine.window  = SDL_CreateWindow(gameTitle, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_XSIZE * Engine.windowScale,
+    Engine.window  = SDL_CreateWindow(gameTitle, SDL_WINDOWPOS_CENTERED_DISPLAY(CURRENT_DISP_SCREEN), SDL_WINDOWPOS_CENTERED_DISPLAY(CURRENT_DISP_SCREEN), SCREEN_XSIZE * Engine.windowScale,
                                      SCREEN_YSIZE * Engine.windowScale, SDL_WINDOW_ALLOW_HIGHDPI | flags);
 
     if (!Engine.window) {
@@ -202,9 +207,12 @@ int InitRenderDevice()
 
     SDL_GL_SetSwapInterval(Engine.vsync ? 1 : 0);
 
-#if RETRO_PLATFORM != RETRO_ANDROID && RETRO_PLATFORM != RETRO_OSX
+#if RETRO_PLATFORM == RETRO_SWITCH
+    // Should probably add error
+    gladLoadGL();
+#elif RETRO_PLATFORM != RETRO_ANDROID && RETRO_PLATFORM != RETRO_OSX
     GLenum err = glewInit();
-    if (err != GLEW_OK && err != GLEW_ERROR_NO_GLX_DISPLAY) {
+    if (err != GLEW_OK) {
         PrintLog("glew init error:");
         PrintLog((const char *)glewGetErrorString(err));
         return false;
@@ -296,6 +304,7 @@ void FlipScreen()
 {
 #if !RETRO_USE_ORIGINAL_CODE
     float dimAmount = 1.0;
+#if RETRO_PLATFORM != RETRO_SWITCH //switch doesn't need this it's builtin
     if ((!Engine.masterPaused || Engine.frameStep) && !drawStageGFXHQ) {
         if (Engine.dimTimer < Engine.dimLimit) {
             if (Engine.dimPercent < 1.0) {
@@ -310,7 +319,7 @@ void FlipScreen()
 
         dimAmount = Engine.dimMax * Engine.dimPercent;
     }
-
+#endif //! RETRO_PLATFORM != RETRO_SWITCH
 #if RETRO_SOFTWARE_RENDER && !RETRO_USING_OPENGL
 #if RETRO_USING_SDL2
     SDL_Rect destScreenPos_scaled;
@@ -319,10 +328,22 @@ void FlipScreen()
     switch (Engine.scalingMode) {
         // reset to default if value is invalid.
         default: Engine.scalingMode = 0; break;
-        case 0: break;                         // nearest
-        case 1: integerScaling = true; break;  // integer scaling
-        case 2: break;                         // sharp bilinear
-        case 3: bilinearScaling = true; break; // regular old bilinear
+        case 0: // nearest
+			integerScaling = false;
+			bilinearScaling = false;
+			break;                         
+        case 1: // integer scaling
+			integerScaling = true;
+			bilinearScaling = false;
+			break;  
+        case 2: // sharp bilinear
+			integerScaling = false;
+			bilinearScaling = false;
+			break;                         
+        case 3: // regular old bilinear
+			integerScaling = false;
+			bilinearScaling = true;
+			break; 
     }
 
     SDL_GetWindowSize(Engine.window, &Engine.windowXSize, &Engine.windowYSize);
@@ -334,8 +355,8 @@ void FlipScreen()
     if (Engine.scalingMode == 2) {
         bool cond1 = std::round((Engine.windowXSize / screenxsize) * 24) / 24 == std::floor(Engine.windowXSize / screenxsize);
         bool cond2 = std::round((Engine.windowYSize / screenysize) * 24) / 24 == std::floor(Engine.windowYSize / screenysize);
-        if (cond1 || cond2)
-            disableEnhancedScaling = true;
+        //if (cond1 || cond2)
+           //disableEnhancedScaling = true;
     }
 
     // get 2x resolution if HQ is enabled.
@@ -384,58 +405,66 @@ void FlipScreen()
     SDL_RenderClear(Engine.renderer);
 
     ushort *pixels = NULL;
-    if (!drawStageGFXHQ) {
-        SDL_LockTexture(Engine.screenBuffer, NULL, (void **)&pixels, &pitch);
-        ushort *frameBufferPtr = Engine.frameBuffer;
-        for (int y = 0; y < SCREEN_YSIZE; ++y) {
-            memcpy(pixels, frameBufferPtr, SCREEN_XSIZE * sizeof(ushort));
-            frameBufferPtr += GFX_LINESIZE;
-            pixels += pitch / sizeof(ushort);
-        }
-        // memcpy(pixels, Engine.frameBuffer, pitch * SCREEN_YSIZE); //faster but produces issues with odd numbered screen sizes
-        SDL_UnlockTexture(Engine.screenBuffer);
-
-        SDL_RenderCopy(Engine.renderer, Engine.screenBuffer, NULL, NULL);
-    }
-    else {
-        int w = 0, h = 0;
-        SDL_QueryTexture(Engine.screenBuffer2x, NULL, NULL, &w, &h);
-        SDL_LockTexture(Engine.screenBuffer2x, NULL, (void **)&pixels, &pitch);
-
-        ushort *framebufferPtr = Engine.frameBuffer;
-        for (int y = 0; y < (SCREEN_YSIZE / 2) + 12; ++y) {
-            for (int x = 0; x < GFX_LINESIZE; ++x) {
-                *pixels = *framebufferPtr;
-                pixels++;
-                *pixels = *framebufferPtr;
-                pixels++;
-                framebufferPtr++;
+    if (Engine.gameMode != ENGINE_VIDEOWAIT) {
+        if (!drawStageGFXHQ) {
+            SDL_LockTexture(Engine.screenBuffer, NULL, (void **)&pixels, &pitch);
+            ushort *frameBufferPtr = Engine.frameBuffer;
+            for (int y = 0; y < SCREEN_YSIZE; ++y) {
+                memcpy(pixels, frameBufferPtr, SCREEN_XSIZE * sizeof(ushort));
+                frameBufferPtr += GFX_LINESIZE;
+                pixels += pitch / sizeof(ushort);
             }
+            // memcpy(pixels, Engine.frameBuffer, pitch * SCREEN_YSIZE); //faster but produces issues with odd numbered screen sizes
+            SDL_UnlockTexture(Engine.screenBuffer);
 
-            framebufferPtr -= GFX_LINESIZE;
-            for (int x = 0; x < GFX_LINESIZE; ++x) {
-                *pixels = *framebufferPtr;
-                pixels++;
-                *pixels = *framebufferPtr;
-                pixels++;
-                framebufferPtr++;
-            }
+            SDL_RenderCopy(Engine.renderer, Engine.screenBuffer, NULL, NULL);
         }
+        else {
+            int w = 0, h = 0;
+            SDL_QueryTexture(Engine.screenBuffer2x, NULL, NULL, &w, &h);
+            SDL_LockTexture(Engine.screenBuffer2x, NULL, (void **)&pixels, &pitch);
+
+            ushort *framebufferPtr = Engine.frameBuffer;
+            for (int y = 0; y < (SCREEN_YSIZE / 2) + 12; ++y) {
+                for (int x = 0; x < GFX_LINESIZE; ++x) {
+                    *pixels = *framebufferPtr;
+                    pixels++;
+                    *pixels = *framebufferPtr;
+                    pixels++;
+                    framebufferPtr++;
+                }
+
+                framebufferPtr -= GFX_LINESIZE;
+                for (int x = 0; x < GFX_LINESIZE; ++x) {
+                    *pixels = *framebufferPtr;
+                    pixels++;
+                    *pixels = *framebufferPtr;
+                    pixels++;
+                    framebufferPtr++;
+                }
+            }
 
-        framebufferPtr = Engine.frameBuffer2x;
-        for (int y = 0; y < ((SCREEN_YSIZE / 2) - 12) * 2; ++y) {
-            for (int x = 0; x < GFX_LINESIZE; ++x) {
-                *pixels = *framebufferPtr;
-                framebufferPtr++;
-                pixels++;
+            framebufferPtr = Engine.frameBuffer2x;
+            for (int y = 0; y < ((SCREEN_YSIZE / 2) - 12) * 2; ++y) {
+                for (int x = 0; x < GFX_LINESIZE; ++x) {
+                    *pixels = *framebufferPtr;
+                    framebufferPtr++;
+                    pixels++;
 
-                *pixels = *framebufferPtr;
-                framebufferPtr++;
-                pixels++;
+                    *pixels = *framebufferPtr;
+                    framebufferPtr++;
+                    pixels++;
+                }
             }
+
+            SDL_UnlockTexture(Engine.screenBuffer2x);
+            SDL_RenderCopy(Engine.renderer, Engine.screenBuffer2x, NULL, NULL);
         }
-        SDL_UnlockTexture(Engine.screenBuffer2x);
-        SDL_RenderCopy(Engine.renderer, Engine.screenBuffer2x, NULL, NULL);
+    } else {
+        SDL_RenderCopy(Engine.renderer, Engine.videoBuffer, NULL, NULL);
+        // this is hacky but whatever, it's the easiest way to handle the fadeout
+        SDL_SetRenderDrawColor(Engine.renderer, 0, 0, 0, fadeMode);
+        SDL_RenderFillRect(Engine.renderer, NULL);
     }
 
     if (Engine.scalingMode != 0 && !disableEnhancedScaling) {
@@ -473,36 +502,40 @@ void FlipScreen()
     int w      = SCREEN_XSIZE * Engine.windowScale;
     int h      = SCREEN_YSIZE * Engine.windowScale;
 
-    if (Engine.windowScale == 1) {
-        ushort *frameBufferPtr = Engine.frameBuffer;
-        for (int y = 0; y < SCREEN_YSIZE; ++y) {
-            for (int x = 0; x < SCREEN_XSIZE; ++x) {
-                pixels[x] = frameBufferPtr[x];
+    if (Engine.gameMode != ENGINE_VIDEOWAIT) {
+        if (Engine.windowScale == 1) {
+            ushort *frameBufferPtr = Engine.frameBuffer;
+            for (int y = 0; y < SCREEN_YSIZE; ++y) {
+                for (int x = 0; x < SCREEN_XSIZE; ++x) {
+                    pixels[x] = frameBufferPtr[x];
+                }
+                frameBufferPtr += GFX_LINESIZE;
+                px += Engine.screenBuffer->pitch / sizeof(ushort);
             }
-            frameBufferPtr += GFX_LINESIZE;
-            px += Engine.screenBuffer->pitch / sizeof(ushort);
+            // memcpy(Engine.screenBuffer->pixels, Engine.frameBuffer, Engine.screenBuffer->pitch * SCREEN_YSIZE);
         }
-        // memcpy(Engine.screenBuffer->pixels, Engine.frameBuffer, Engine.screenBuffer->pitch * SCREEN_YSIZE);
-    }
-    else {
-        // TODO: this better, I really dont know how to use SDL1.2 well lol
-        int dx = 0, dy = 0;
-        do {
+        else {
+            // TODO: this better, I really dont know how to use SDL1.2 well lol
+            int dx = 0, dy = 0;
             do {
-                int x = (int)(dx * (1.0f / Engine.windowScale));
-                int y = (int)(dy * (1.0f / Engine.windowScale));
+                do {
+                    int x = (int)(dx * (1.0f / Engine.windowScale));
+                    int y = (int)(dy * (1.0f / Engine.windowScale));
 
-                px[dx + (dy * w)] = Engine.frameBuffer[x + (y * GFX_LINESIZE)];
+                    px[dx + (dy * w)] = Engine.frameBuffer[x + (y * GFX_LINESIZE)];
 
-                dx++;
-            } while (dx < w);
-            dy++;
-            dx = 0;
-        } while (dy < h);
-    }
+                    dx++;
+                } while (dx < w);
+                dy++;
+                dx = 0;
+            } while (dy < h);
+        }
 
-    // Apply image to screen
-    SDL_BlitSurface(Engine.screenBuffer, NULL, Engine.windowSurface, NULL);
+        // Apply image to screen
+        SDL_BlitSurface(Engine.screenBuffer, NULL, Engine.windowSurface, NULL);
+    } else {
+        SDL_BlitSurface(Engine.videoBuffer, NULL, Engine.windowSurface, NULL);
+    }
 
     // Update Screen
     SDL_Flip(Engine.windowSurface);
@@ -514,10 +547,12 @@ void FlipScreen()
 }
 void ReleaseRenderDevice(bool refresh)
 {
-    if (!refresh) {
-        ClearMeshData();
-        ClearTextures(false);
-    }
+	if (!refresh) {
+		ClearMeshData();
+		ClearTextures(false);
+	}
+	else
+		CURRENT_DISP_SCREEN = SDL_GetWindowDisplayIndex(Engine.window);
 
 #if !RETRO_USE_ORIGINAL_CODE
 #if RETRO_SOFTWARE_RENDER
@@ -553,6 +588,7 @@ void ReleaseRenderDevice(bool refresh)
 
 void GenerateBlendLookupTable(void)
 {
+	//this is still used by DrawFace, DrawFadedFace, DrawRectangle, and SetHQFade
     for (int y = 0; y < 0x100; y++) {
         for (int x = 0; x < 0x20; x++) {
             blendLookupTable[x + (0x20 * y)]    = y * x >> 8;
@@ -601,11 +637,7 @@ void SetScreenDimensions(int width, int height)
     int displayWidth        = aspect * SCREEN_YSIZE;
     // if (val > displaySettings.maxWidth)
     //    val = displaySettings.maxWidth;
-#if !RETRO_USE_ORIGINAL_CODE
     SetScreenSize(displayWidth, (displayWidth + 9) & -0x8);
-#else
-    SetScreenSize(displayWidth, (displayWidth + 9) & -0x10);
-#endif
 
     int width2 = 0;
     int wBuf   = GFX_LINESIZE - 1;
@@ -747,11 +779,7 @@ void SetupViewport()
     glViewport(displaySettings.offsetX, 0, displaySettings.width, displaySettings.height);
 #endif
     int displayWidth = aspect * SCREEN_YSIZE;
-#if !RETRO_USE_ORIGINAL_CODE
     SetScreenSize(displayWidth, (displayWidth + 9) & -0x8);
-#else
-    SetScreenSize(displayWidth, (displayWidth + 9) & -0x10);
-#endif
 
     Engine.useHighResAssets = displaySettings.height > (SCREEN_YSIZE * 2);
 
@@ -996,7 +1024,7 @@ void DrawObjectList(int Layer)
         objectEntityPos = drawListEntries[Layer].entityRefs[i];
         int type        = objectEntityList[objectEntityPos].type;
         if (type) {
-            if (scriptCode[objectScriptList[type].eventDraw.scriptCodePtr] > 0)
+            if (scriptData[objectScriptList[type].eventDraw.scriptCodePtr] > 0)
                 ProcessScript(objectScriptList[type].eventDraw.scriptCodePtr, objectScriptList[type].eventDraw.jumpTablePtr, EVENT_DRAW);
         }
     }
@@ -1226,13 +1254,6 @@ void DrawStageGFX()
         }
 
         DrawObjectList(5);
-#if RETRO_REV03
-#if !RETRO_USE_ORIGINAL_CODE
-        // Hacky fix for Tails Object not working properly in special stages on non-Origins bytecode
-        if (forceUseScripts || Engine.usingOrigins)
-#endif
-            DrawObjectList(7);
-#endif
         DrawObjectList(6);
     }
 
@@ -1245,14 +1266,28 @@ void DrawStageGFX()
     if (drawStageGFXHQ) {
         CopyFrameOverlay2x();
 
-        if (fadeMode > 0) {
+		switch (fadeMode) {
+			case 1:
+			if (fadeA > 0xFF)
+				fadeA = 0xFF;
             DrawRectangle(0, 0, SCREEN_XSIZE, SCREEN_YSIZE, fadeR, fadeG, fadeB, fadeA);
             SetFadeHQ(fadeR, fadeG, fadeB, fadeA);
+			break;
+			case 2:
+			DrawClassicFade(0, 0, SCREEN_XSIZE, SCREEN_YSIZE, fadeR, fadeG, fadeB, fadeX);
+			break;
         }
     }
     else {
-        if (fadeMode > 0) {
+		switch (fadeMode) {
+			case 1:
+			if (fadeA > 0xFF)
+				fadeA = 0xFF;
             DrawRectangle(0, 0, SCREEN_XSIZE, SCREEN_YSIZE, fadeR, fadeG, fadeB, fadeA);
+			break;
+			case 2:
+			DrawClassicFade(0, 0, SCREEN_XSIZE, SCREEN_YSIZE, fadeR, fadeG, fadeB, fadeX);
+			break;
         }
     }
 #endif
@@ -2658,6 +2693,134 @@ void Draw3DSkyLayer(int layerID)
 #endif
 }
 
+void DrawClassicFade(int XPos, int YPos, int width, int height, int R, int G, int B, int A)
+{
+	
+#if RETRO_SOFTWARE_RENDER
+    if (width + XPos > GFX_LINESIZE)
+        width = GFX_LINESIZE - XPos;
+    if (XPos < 0) {
+        width += XPos;
+        XPos = 0;
+    }
+
+    if (height + YPos > SCREEN_YSIZE)
+        height = SCREEN_YSIZE - YPos;
+    if (YPos < 0) {
+        height += YPos;
+        YPos = 0;
+    }
+    if (width <= 0 || height <= 0 || A <= 0)
+        return;
+	
+	//A works differently here, and we're going to tweak the value to compensate
+	A *= 3;
+	A >>= 3;
+	
+    int pitch              = GFX_LINESIZE - width;
+    ushort *frameBufferPtr = &Engine.frameBuffer[XPos + GFX_LINESIZE * YPos];
+    ushort clr             = PACK_RGB888(R, G, B);
+
+	int h = height;
+	while (h--) {
+		int w = width;
+		while (w--) {
+			int dif;
+			
+			int Awork = A;
+			
+			int R = (*frameBufferPtr & 0xF800) >> 11;
+			int G = (*frameBufferPtr & 0x7E0) >> 6;
+			int B = *frameBufferPtr & 0x1F;
+			
+			int trgR = (clr & 0xF800) >> 11;
+			int trgG = (clr & 0x7E0) >> 6;
+			int trgB = clr & 0x1F;
+			
+			if (Awork > 0) {	
+				if (trgR > R) {
+					dif = trgR - R;
+					if (dif >= Awork) {
+							R += Awork;
+							Awork = 0;
+					}
+					else {
+						R = trgR;
+						Awork -= dif;
+					}
+				}
+				else if (trgR < R) {
+					dif = R - trgR;
+					if (dif >= Awork) {
+							R -= Awork;
+							Awork = 0;
+					}
+					else {
+						R = trgR;
+						Awork -= dif;
+					}
+				}
+			}
+			if (Awork > 0) {	
+				if (trgG > G) {
+					dif = trgG - G;
+					if (dif >= Awork) {
+							G += Awork;
+							Awork = 0;
+					}
+					else {
+						G = trgG;
+						Awork -= dif;
+					}
+				}
+				else if (trgG < G) {
+					dif = G - trgG;
+					if (dif >= Awork) {
+							G -= Awork;
+							Awork = 0;
+					}
+					else {
+						G = trgG;
+						Awork -= dif;
+					}
+				}
+			}
+			if (Awork > 0) {	
+				if (trgB > B) {
+					dif = trgB - B;
+					if (dif >= Awork) {
+							B += Awork;
+							Awork = 0;
+					}
+					else {
+						B = trgB;
+						Awork -= dif;
+					}
+				}
+				else if (trgB < B) {
+					dif = B - trgB;
+					if (dif >= Awork) {
+							B -= Awork;
+							Awork = 0;
+					}
+					else {
+						B = trgB;
+						Awork -= dif;
+					}
+				}
+			}
+			
+			R <<= 11;
+			G <<= 6;
+
+			*frameBufferPtr = R | G | B;
+			++frameBufferPtr;
+		}
+		frameBufferPtr += pitch;
+    }
+#endif
+}
+
 void DrawRectangle(int XPos, int YPos, int width, int height, int R, int G, int B, int A)
 {
     if (A > 0xFF)
@@ -2772,7 +2935,6 @@ void DrawTintRectangle(int XPos, int YPos, int width, int height)
 	
     if (width < 0 || height < 0)
         return;
-	
     int yOffset = GFX_LINESIZE - width;
     for (ushort *frameBufferPtr = &Engine.frameBuffer[XPos + GFX_LINESIZE * YPos];; frameBufferPtr += yOffset) {
         height--;
@@ -3200,7 +3362,7 @@ void DrawSpriteScaled(int direction, int XPos, int YPos, int pivotX, int pivotY,
     }
 #endif
 }
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 void DrawScaledChar(int direction, int XPos, int YPos, int pivotX, int pivotY, int scaleX, int scaleY, int width, int height, int sprX, int sprY,
                     int sheetID)
 {
@@ -3511,6 +3673,450 @@ void DrawSpriteRotozoom(int direction, int XPos, int YPos, int pivotX, int pivot
 #endif
 }
 
+void DrawSpriteAllFX(int direction, int XPos, int YPos, int pivotX, int pivotY, int sprX, int sprY, int width, int height, int rotation, int scale,
+                        int sheetID, int alpha, int ink, int flags)
+{
+#if RETRO_SOFTWARE_RENDER
+	//check flags
+	int hscale = scale;
+	int vscale = scale;
+	if ((flags & FX_INK) == 0)
+		ink = INK_NONE;
+	if ((flags & FX_HSCALE) == 0)
+		hscale = 0x200;
+	if ((flags & FX_VSCALE) == 0)
+		vscale = 0x200;
+	if ((flags & FX_ROTATE) == 0)
+		rotation = 0;
+	if ((flags & 3) == 0)
+		direction = FLIP_NONE;
+	
+	if ((ink > INK_NONE) && (alpha < 0))
+		return;
+	
+	if (alpha > 0xFF)
+        alpha = 0xFF;
+	
+    if (scale == 0)
+        return;
+
+    int sprXPos    = (pivotX + sprX) << 9;
+    int sprYPos    = (pivotY + sprY) << 9;
+    int fullwidth  = width + sprX;
+    int fullheight = height + sprY;
+    int angle      = rotation & 0x1FF;
+    if (angle < 0)
+        angle += 0x200;
+    if (angle)
+        angle = 0x200 - angle;
+    int sine   = hscale * sin512LookupTable[angle] >> 9;
+    int cosine = hscale * cos512LookupTable[angle] >> 9;
+    int vsine   = vscale * sin512LookupTable[angle] >> 9;
+    int vcosine = vscale * cos512LookupTable[angle] >> 9;
+    int xPositions[4];
+    int yPositions[4];
+
+    if (direction == FLIP_X) {
+        xPositions[0] = XPos + ((vsine * (-pivotY - 2) + cosine * (pivotX + 2)) >> 9);
+        yPositions[0] = YPos + ((vcosine * (-pivotY - 2) - sine * (pivotX + 2)) >> 9);
+        xPositions[1] = XPos + ((vsine * (-pivotY - 2) + cosine * (pivotX - width - 2)) >> 9);
+        yPositions[1] = YPos + ((vcosine * (-pivotY - 2) - sine * (pivotX - width - 2)) >> 9);
+        xPositions[2] = XPos + ((vsine * (height - pivotY + 2) + cosine * (pivotX + 2)) >> 9);
+        yPositions[2] = YPos + ((vcosine * (height - pivotY + 2) - sine * (pivotX + 2)) >> 9);
+        int a         = pivotX - width - 2;
+        int b         = height - pivotY + 2;
+        xPositions[3] = XPos + ((vsine * b + cosine * a) >> 9);
+        yPositions[3] = YPos + ((vcosine * b - sine * a) >> 9);
+    }
+	else if (direction == FLIP_Y) {
+        xPositions[0] = XPos + ((vsine * (pivotY + 2) + cosine * (-pivotX - 2)) >> 9);
+        yPositions[0] = YPos + ((vcosine * (pivotY + 2) - sine * (-pivotX - 2)) >> 9);
+        xPositions[1] = XPos + ((vsine * (pivotY + 2) + cosine * (width - pivotX + 2)) >> 9);
+        yPositions[1] = YPos + ((vcosine * (pivotY + 2) - sine * (width - pivotX + 2)) >> 9);
+        xPositions[2] = XPos + ((vsine * (pivotY - height - 2) + cosine * (-pivotX - 2)) >> 9);
+        yPositions[2] = YPos + ((vcosine * (pivotY - height - 2) - sine * (-pivotX - 2)) >> 9);
+        int a         = width - pivotX + 2;
+        int b         = pivotY - height - 2;
+        xPositions[3] = XPos + ((vsine * b + cosine * a) >> 9);
+        yPositions[3] = YPos + ((vcosine * b - sine * a) >> 9);
+    }
+	else if (direction == FLIP_XY) {
+        xPositions[0] = XPos + ((vsine * (pivotY + 2) + cosine * (pivotX + 2)) >> 9);
+        yPositions[0] = YPos + ((vcosine * (pivotY + 2) - sine * (pivotX + 2)) >> 9);
+        xPositions[1] = XPos + ((vsine * (pivotY + 2) + cosine * (pivotX - width - 2)) >> 9);
+        yPositions[1] = YPos + ((vcosine * (pivotY + 2) - sine * (pivotX - width - 2)) >> 9);
+        xPositions[2] = XPos + ((vsine * (pivotY - height - 2) + cosine * (pivotX + 2)) >> 9);
+        yPositions[2] = YPos + ((vcosine * (pivotY - height - 2) - sine * (pivotX + 2)) >> 9);
+        int a         = pivotX - width - 2;
+        int b         = pivotY - height - 2;
+        xPositions[3] = XPos + ((vsine * b + cosine * a) >> 9);
+        yPositions[3] = YPos + ((vcosine * b - sine * a) >> 9);
+    }
+    else {
+        xPositions[0] = XPos + ((vsine * (-pivotY - 2) + cosine * (-pivotX - 2)) >> 9);
+        yPositions[0] = YPos + ((vcosine * (-pivotY - 2) - sine * (-pivotX - 2)) >> 9);
+        xPositions[1] = XPos + ((vsine * (-pivotY - 2) + cosine * (width - pivotX + 2)) >> 9);
+        yPositions[1] = YPos + ((vcosine * (-pivotY - 2) - sine * (width - pivotX + 2)) >> 9);
+        xPositions[2] = XPos + ((vsine * (height - pivotY + 2) + cosine * (-pivotX - 2)) >> 9);
+        yPositions[2] = YPos + ((vcosine * (height - pivotY + 2) - sine * (-pivotX - 2)) >> 9);
+        int a         = width - pivotX + 2;
+        int b         = height - pivotY + 2;
+        xPositions[3] = XPos + ((vsine * b + cosine * a) >> 9);
+        yPositions[3] = YPos + ((vcosine * b - sine * a) >> 9);
+    }
+    int truescale = (signed int)(float)((float)(512.0 / (float)hscale) * 512.0);
+    sine          = truescale * sin512LookupTable[angle] >> 9;
+    cosine        = truescale * cos512LookupTable[angle] >> 9;
+    truescale = (signed int)(float)((float)(512.0 / (float)vscale) * 512.0);
+    vsine          = truescale * sin512LookupTable[angle] >> 9;
+    vcosine        = truescale * cos512LookupTable[angle] >> 9;
+
+    int left = GFX_LINESIZE;
+    for (int i = 0; i < 4; ++i) {
+        if (xPositions[i] < left)
+            left = xPositions[i];
+    }
+    if (left < 0)
+        left = 0;
+
+    int right = 0;
+    for (int i = 0; i < 4; ++i) {
+        if (xPositions[i] > right)
+            right = xPositions[i];
+    }
+    if (right > GFX_LINESIZE)
+        right = GFX_LINESIZE;
+    int maxX = right - left;
+
+    int top = SCREEN_YSIZE;
+    for (int i = 0; i < 4; ++i) {
+        if (yPositions[i] < top)
+            top = yPositions[i];
+    }
+    if (top < 0)
+        top = 0;
+
+    int bottom = 0;
+    for (int i = 0; i < 4; ++i) {
+        if (yPositions[i] > bottom)
+            bottom = yPositions[i];
+    }
+    if (bottom > SCREEN_YSIZE)
+        bottom = SCREEN_YSIZE;
+    int maxY = bottom - top;
+
+    if (maxX <= 0 || maxY <= 0)
+        return;
+
+	//ink tables here -- unused by this function
+	//ushort *fbufferBlend = &blendLookupTable[0x20 * (0xFF - alpha)];
+	//ushort *pixelBlend   = &blendLookupTable[0x20 * alpha];
+	//ushort *subBlendTable  = &subtractLookupTable[0x20 * alpha];
+	
+    GFXSurface *surface    = &gfxSurface[sheetID];
+    int pitch              = GFX_LINESIZE - maxX;
+    int lineSize           = surface->widthShift;
+    ushort *frameBufferPtr = &Engine.frameBuffer[left + GFX_LINESIZE * top];
+    byte *lineBuffer       = &gfxLineBuffer[top];
+    int startX             = left - XPos;
+    int startY             = top - YPos;
+    int shiftPivot         = (sprX << 9) - 1;
+    fullwidth <<= 9;
+    int shiftheight = (sprY << 9) - 1;
+    fullheight <<= 9;
+    byte *gfxData = &graphicData[surface->dataPosition];
+    if (vcosine < 0 || vsine < 0)
+        sprYPos += vsine + vcosine;
+
+    if (direction == FLIP_X) {
+        int drawX = sprXPos - (cosine * startX - sine * startY) - (truescale >> 1);
+        int drawY = vcosine * startY + sprYPos + vsine * startX;
+        while (maxY--) {
+            activePalette   = fullPalette[*lineBuffer];
+            activePalette32 = fullPalette32[*lineBuffer];
+            lineBuffer++;
+            int finalX = drawX;
+            int finalY = drawY;
+            int w      = maxX;
+            while (w--) {
+                if (finalX > shiftPivot && finalX < fullwidth && finalY > shiftheight && finalY < fullheight) {
+                    byte index = gfxData[(finalY >> 9 << lineSize) + (finalX >> 9)];
+                    if (index > 0) {
+						
+						ushort color = activePalette[index];
+						int R;
+						int G;
+						int B;
+						switch (ink) {
+							case INK_NONE:
+								*frameBufferPtr = activePalette[index];
+								break;
+							case INK_BLEND:
+								*frameBufferPtr = ((activePalette[index] & 0xF7DE) >> 1) + ((*frameBufferPtr & 0xF7DE) >> 1);
+								break;
+							case INK_ALPHA:
+								//R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
+								//G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
+								//B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+								
+								R = ((((*frameBufferPtr & 0xF800) >> 11) * (0x100 - alpha)) + (((color & 0xF800) >> 11) * alpha) >> 8) << 11;
+								G = ((((*frameBufferPtr & 0x7E0) >> 5) * (0x100 - alpha)) + (((color & 0x7E0) >> 5) * alpha) >> 8) << 5;
+								B = (((*frameBufferPtr & 0x1F) * (0x100 - alpha)) + ((color & 0x1F) * alpha) >> 8);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_ADD:
+								//R = minVal((pixelBlend[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								//G = minVal((pixelBlend[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								//B = minVal(pixelBlend[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+
+								R = minVal((((((color & 0xF800) >> 11) * alpha) >> 8) << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								G = minVal((((((color & 0x7E0) >> 5) * alpha) >> 8) << 5) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								B = minVal((((color & 0x1F) * alpha) >> 8) + (*frameBufferPtr & 0x1F), 0x1F);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_SUB:
+								//R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
+								//G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
+								//B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+                
+								R = maxVal((*frameBufferPtr & 0xF800) - (((((0xF800 - (color & 0xF800)) >> 11) * alpha) >> 8) << 11), 0);
+								G = maxVal((*frameBufferPtr & 0x7E0) - (((((0x7E0 - (color & 0x7E0)) >> 5) * alpha) >> 8) << 5), 0);
+								B = maxVal((*frameBufferPtr & 0x1F) - (((0x1F - (color & 0x1F)) * alpha) >> 8), 0);
+
+								*frameBufferPtr = R | G | B;
+								break;
+						}
+					}
+                }
+                ++frameBufferPtr;
+                finalX -= cosine;
+                finalY += vsine;
+            }
+            drawX += sine;
+            drawY += vcosine;
+            frameBufferPtr += pitch;
+        }
+    }
+    else if (direction == FLIP_Y) {
+        int drawX = sprXPos + cosine * startX - sine * startY;
+        int drawY = sprYPos - (vcosine * startY + vsine * startX);
+        while (maxY--) {
+            activePalette   = fullPalette[*lineBuffer];
+            activePalette32 = fullPalette32[*lineBuffer];
+            lineBuffer++;
+            int finalX = drawX;
+            int finalY = drawY;
+            int w      = maxX;
+            while (w--) {
+                if (finalX > shiftPivot && finalX < fullwidth && finalY > shiftheight && finalY < fullheight) {
+                    byte index = gfxData[(finalY >> 9 << lineSize) + (finalX >> 9)];
+                    if (index > 0) {
+						
+						ushort color = activePalette[index];
+						int R;
+						int G;
+						int B;
+						switch (ink) {
+							case INK_NONE:
+								*frameBufferPtr = activePalette[index];
+								break;
+							case INK_BLEND:
+								*frameBufferPtr = ((activePalette[index] & 0xF7DE) >> 1) + ((*frameBufferPtr & 0xF7DE) >> 1);
+								break;
+							case INK_ALPHA:
+								//R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
+								//G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
+								//B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+								
+								R = ((((*frameBufferPtr & 0xF800) >> 11) * (0x100 - alpha)) + (((color & 0xF800) >> 11) * alpha) >> 8) << 11;
+								G = ((((*frameBufferPtr & 0x7E0) >> 5) * (0x100 - alpha)) + (((color & 0x7E0) >> 5) * alpha) >> 8) << 5;
+								B = (((*frameBufferPtr & 0x1F) * (0x100 - alpha)) + ((color & 0x1F) * alpha) >> 8);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_ADD:
+								//R = minVal((pixelBlend[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								//G = minVal((pixelBlend[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								//B = minVal(pixelBlend[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+
+								R = minVal((((((color & 0xF800) >> 11) * alpha) >> 8) << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								G = minVal((((((color & 0x7E0) >> 5) * alpha) >> 8) << 5) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								B = minVal((((color & 0x1F) * alpha) >> 8) + (*frameBufferPtr & 0x1F), 0x1F);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_SUB:
+								//R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
+								//G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
+								//B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+                
+								R = maxVal((*frameBufferPtr & 0xF800) - (((((0xF800 - (color & 0xF800)) >> 11) * alpha) >> 8) << 11), 0);
+								G = maxVal((*frameBufferPtr & 0x7E0) - (((((0x7E0 - (color & 0x7E0)) >> 5) * alpha) >> 8) << 5), 0);
+								B = maxVal((*frameBufferPtr & 0x1F) - (((0x1F - (color & 0x1F)) * alpha) >> 8), 0);
+
+								*frameBufferPtr = R | G | B;
+								break;
+						}
+					}
+
+                }
+                ++frameBufferPtr;
+                finalX += cosine;
+                finalY -= vsine;
+            }
+            drawX -= sine;
+            drawY -= vcosine;
+            frameBufferPtr += pitch;
+        }
+    }
+    else if (direction == FLIP_XY) {
+        int drawX = sprXPos - (cosine * startX - sine * startY) - (truescale >> 1);
+        int drawY = sprYPos - (vcosine * startY + vsine * startX);
+        while (maxY--) {
+            activePalette   = fullPalette[*lineBuffer];
+            activePalette32 = fullPalette32[*lineBuffer];
+            lineBuffer++;
+            int finalX = drawX;
+            int finalY = drawY;
+            int w      = maxX;
+            while (w--) {
+                if (finalX > shiftPivot && finalX < fullwidth && finalY > shiftheight && finalY < fullheight) {
+                    byte index = gfxData[(finalY >> 9 << lineSize) + (finalX >> 9)];
+                    if (index > 0) {
+						
+						ushort color = activePalette[index];
+						int R;
+						int G;
+						int B;
+						switch (ink) {
+							case INK_NONE:
+								*frameBufferPtr = activePalette[index];
+								break;
+							case INK_BLEND:
+								*frameBufferPtr = ((activePalette[index] & 0xF7DE) >> 1) + ((*frameBufferPtr & 0xF7DE) >> 1);
+								break;
+							case INK_ALPHA:
+								//R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
+								//G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
+								//B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+								
+								R = ((((*frameBufferPtr & 0xF800) >> 11) * (0x100 - alpha)) + (((color & 0xF800) >> 11) * alpha) >> 8) << 11;
+								G = ((((*frameBufferPtr & 0x7E0) >> 5) * (0x100 - alpha)) + (((color & 0x7E0) >> 5) * alpha) >> 8) << 5;
+								B = (((*frameBufferPtr & 0x1F) * (0x100 - alpha)) + ((color & 0x1F) * alpha) >> 8);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_ADD:
+								//R = minVal((pixelBlend[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								//G = minVal((pixelBlend[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								//B = minVal(pixelBlend[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+
+								R = minVal((((((color & 0xF800) >> 11) * alpha) >> 8) << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								G = minVal((((((color & 0x7E0) >> 5) * alpha) >> 8) << 5) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								B = minVal((((color & 0x1F) * alpha) >> 8) + (*frameBufferPtr & 0x1F), 0x1F);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_SUB:
+								//R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
+								//G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
+								//B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+                
+								R = maxVal((*frameBufferPtr & 0xF800) - (((((0xF800 - (color & 0xF800)) >> 11) * alpha) >> 8) << 11), 0);
+								G = maxVal((*frameBufferPtr & 0x7E0) - (((((0x7E0 - (color & 0x7E0)) >> 5) * alpha) >> 8) << 5), 0);
+								B = maxVal((*frameBufferPtr & 0x1F) - (((0x1F - (color & 0x1F)) * alpha) >> 8), 0);
+
+								*frameBufferPtr = R | G | B;
+								break;
+						}
+					}
+
+                }
+                ++frameBufferPtr;
+                finalX -= cosine;
+                finalY -= vsine;
+            }
+            drawX += sine;
+            drawY -= vcosine;
+            frameBufferPtr += pitch;
+        }
+    }
+    else {
+        int drawX = sprXPos + cosine * startX - sine * startY;
+        int drawY = vcosine * startY + sprYPos + vsine * startX;
+        while (maxY--) {
+            activePalette   = fullPalette[*lineBuffer];
+            activePalette32 = fullPalette32[*lineBuffer];
+            lineBuffer++;
+            int finalX = drawX;
+            int finalY = drawY;
+            int w      = maxX;
+            while (w--) {
+                if (finalX > shiftPivot && finalX < fullwidth && finalY > shiftheight && finalY < fullheight) {
+                    byte index = gfxData[(finalY >> 9 << lineSize) + (finalX >> 9)];
+                    if (index > 0) {
+						
+						ushort color = activePalette[index];
+						int R;
+						int G;
+						int B;
+						switch (ink) {
+							case INK_NONE:
+								*frameBufferPtr = activePalette[index];
+								break;
+							case INK_BLEND:
+								*frameBufferPtr = ((activePalette[index] & 0xF7DE) >> 1) + ((*frameBufferPtr & 0xF7DE) >> 1);
+								break;
+							case INK_ALPHA:
+								//R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
+								//G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
+								//B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+								
+								R = ((((*frameBufferPtr & 0xF800) >> 11) * (0x100 - alpha)) + (((color & 0xF800) >> 11) * alpha) >> 8) << 11;
+								G = ((((*frameBufferPtr & 0x7E0) >> 5) * (0x100 - alpha)) + (((color & 0x7E0) >> 5) * alpha) >> 8) << 5;
+								B = (((*frameBufferPtr & 0x1F) * (0x100 - alpha)) + ((color & 0x1F) * alpha) >> 8);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_ADD:
+								//R = minVal((pixelBlend[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								//G = minVal((pixelBlend[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								//B = minVal(pixelBlend[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+
+								R = minVal((((((color & 0xF800) >> 11) * alpha) >> 8) << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+								G = minVal((((((color & 0x7E0) >> 5) * alpha) >> 8) << 5) + (*frameBufferPtr & 0x7E0), 0x7E0);
+								B = minVal((((color & 0x1F) * alpha) >> 8) + (*frameBufferPtr & 0x1F), 0x1F);
+
+								*frameBufferPtr = R | G | B;
+								break;
+							case INK_SUB:
+								//R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
+								//G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
+								//B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+                
+								R = maxVal((*frameBufferPtr & 0xF800) - (((((0xF800 - (color & 0xF800)) >> 11) * alpha) >> 8) << 11), 0);
+								G = maxVal((*frameBufferPtr & 0x7E0) - (((((0x7E0 - (color & 0x7E0)) >> 5) * alpha) >> 8) << 5), 0);
+								B = maxVal((*frameBufferPtr & 0x1F) - (((0x1F - (color & 0x1F)) * alpha) >> 8), 0);
+
+								*frameBufferPtr = R | G | B;
+								break;
+						}
+					}
+                }
+                ++frameBufferPtr;
+                finalX += cosine;
+                finalY += vsine;
+            }
+            drawX -= sine;
+            drawY += vcosine;
+            frameBufferPtr += pitch;
+        }
+    }
+#endif
+}
+
 void DrawBlendedSprite(int XPos, int YPos, int width, int height, int sprX, int sprY, int sheetID)
 {
 #if RETRO_SOFTWARE_RENDER
@@ -3598,8 +4204,9 @@ void DrawAlphaBlendedSprite(int XPos, int YPos, int width, int height, int sprX,
         }
     }
     else {
-        ushort *fbufferBlend = &blendLookupTable[0x20 * (0xFF - alpha)];
-        ushort *pixelBlend   = &blendLookupTable[0x20 * alpha];
+		//Commented out - we're calculating it live
+        //ushort *fbufferBlend = &blendLookupTable[0x20 * (0xFF - alpha)];
+        //ushort *pixelBlend   = &blendLookupTable[0x20 * alpha];
 
         while (height--) {
             activePalette   = fullPalette[*lineBuffer];
@@ -3610,9 +4217,13 @@ void DrawAlphaBlendedSprite(int XPos, int YPos, int width, int height, int sprX,
                 if (*gfxData > 0) {
                     ushort color = activePalette[*gfxData];
 
-                    int R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
-                    int G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
-                    int B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+                    //int R = (fbufferBlend[(*frameBufferPtr & 0xF800) >> 11] + pixelBlend[(color & 0xF800) >> 11]) << 11;
+                    //int G = (fbufferBlend[(*frameBufferPtr & 0x7E0) >> 6] + pixelBlend[(color & 0x7E0) >> 6]) << 6;
+                    //int B = fbufferBlend[*frameBufferPtr & 0x1F] + pixelBlend[color & 0x1F];
+					
+					int R = ((((*frameBufferPtr & 0xF800) >> 11) * (0x100 - alpha)) + (((color & 0xF800) >> 11) * alpha) >> 8) << 11;
+					int G = ((((*frameBufferPtr & 0x7E0) >> 5) * (0x100 - alpha)) + (((color & 0x7E0) >> 5) * alpha) >> 8) << 5;
+					int B = (((*frameBufferPtr & 0x1F) * (0x100 - alpha)) + ((color & 0x1F) * alpha) >> 8);
 
                     *frameBufferPtr = R | G | B;
                 }
@@ -3647,7 +4258,8 @@ void DrawAdditiveBlendedSprite(int XPos, int YPos, int width, int height, int sp
     if (width <= 0 || height <= 0 || alpha <= 0)
         return;
 
-    ushort *blendTablePtr  = &blendLookupTable[0x20 * alpha];
+	//Commented out - we're calculating it live
+    //ushort *pixelBlend  = &blendLookupTable[0x20 * alpha];
     GFXSurface *surface    = &gfxSurface[sheetID];
     int pitch              = GFX_LINESIZE - width;
     int gfxPitch           = surface->width - width;
@@ -3664,9 +4276,13 @@ void DrawAdditiveBlendedSprite(int XPos, int YPos, int width, int height, int sp
             if (*gfxData > 0) {
                 ushort color = activePalette[*gfxData];
 
-                int R = minVal((blendTablePtr[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
-                int G = minVal((blendTablePtr[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
-                int B = minVal(blendTablePtr[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+               // int R = minVal((pixelBlend[(color & 0xF800) >> 11] << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+               // int G = minVal((pixelBlend[(color & 0x7E0) >> 6] << 6) + (*frameBufferPtr & 0x7E0), 0x7E0);
+               // int B = minVal(pixelBlend[color & 0x1F] + (*frameBufferPtr & 0x1F), 0x1F);
+
+                int R = minVal((((((color & 0xF800) >> 11) * alpha) >> 8) << 11) + (*frameBufferPtr & 0xF800), 0xF800);
+                int G = minVal((((((color & 0x7E0) >> 5) * alpha) >> 8) << 5) + (*frameBufferPtr & 0x7E0), 0x7E0);
+                int B = minVal((((color & 0x1F) * alpha) >> 8) + (*frameBufferPtr & 0x1F), 0x1F);
 
                 *frameBufferPtr = R | G | B;
             }
@@ -3701,7 +4317,8 @@ void DrawSubtractiveBlendedSprite(int XPos, int YPos, int width, int height, int
     if (width <= 0 || height <= 0 || alpha <= 0)
         return;
 
-    ushort *subBlendTable  = &subtractLookupTable[0x20 * alpha];
+    //Commented out - we're calculating it live
+    //ushort *subBlendTable  = &subtractLookupTable[0x20 * alpha];
     GFXSurface *surface    = &gfxSurface[sheetID];
     int pitch              = GFX_LINESIZE - width;
     int gfxPitch           = surface->width - width;
@@ -3718,9 +4335,13 @@ void DrawSubtractiveBlendedSprite(int XPos, int YPos, int width, int height, int
             if (*gfxData > 0) {
                 ushort color = activePalette[*gfxData];
 
-                int R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
-                int G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
-                int B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+                //int R = maxVal((*frameBufferPtr & 0xF800) - (subBlendTable[(color & 0xF800) >> 11] << 11), 0);
+                //int G = maxVal((*frameBufferPtr & 0x7E0) - (subBlendTable[(color & 0x7E0) >> 6] << 6), 0);
+                //int B = maxVal((*frameBufferPtr & 0x1F) - subBlendTable[color & 0x1F], 0);
+
+                int R = maxVal((*frameBufferPtr & 0xF800) - (((((0xF800 - (color & 0xF800)) >> 11) * alpha) >> 8) << 11), 0);
+                int G = maxVal((*frameBufferPtr & 0x7E0) - (((((0x7E0 - (color & 0x7E0)) >> 5) * alpha) >> 8) << 5), 0);
+                int B = maxVal((*frameBufferPtr & 0x1F) - (((0x1F - (color & 0x1F)) * alpha) >> 8), 0);
 
                 *frameBufferPtr = R | G | B;
             }
@@ -3743,44 +4364,23 @@ void DrawObjectAnimation(void *objScr, void *ent, int XPos, int YPos)
 
     switch (sprAnim->rotationStyle) {
         case ROTSTYLE_NONE:
-            switch (entity->direction) {
-                case FLIP_NONE:
-                    DrawSpriteFlipped(frame->pivotX + XPos, frame->pivotY + YPos, frame->width, frame->height, frame->sprX, frame->sprY, FLIP_NONE,
-                                      frame->sheetID);
-                    break;
-
-                case FLIP_X:
-                    DrawSpriteFlipped(XPos - frame->width - frame->pivotX, frame->pivotY + YPos, frame->width, frame->height, frame->sprX,
-                                      frame->sprY, FLIP_X, frame->sheetID);
-                    break;
-                case FLIP_Y:
-
-                    DrawSpriteFlipped(frame->pivotX + XPos, YPos - frame->height - frame->pivotY, frame->width, frame->height, frame->sprX,
-                                      frame->sprY, FLIP_Y, frame->sheetID);
-                    break;
-
-                case FLIP_XY:
-                    DrawSpriteFlipped(XPos - frame->width - frame->pivotX, YPos - frame->height - frame->pivotY, frame->width, frame->height,
-                                      frame->sprX, frame->sprY, FLIP_XY, frame->sheetID);
-                    break;
-
-                default: break;
-            }
+			DrawSpriteAllFX(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
+							 0, entity->scale, frame->sheetID, entity->alpha, entity->inkEffect, FX_ALL - FX_ROTATE);
             break;
 
         case ROTSTYLE_FULL:
-            DrawSpriteRotated(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
-                              entity->rotation, frame->sheetID);
+			DrawSpriteAllFX(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
+							 entity->rotation, entity->scale, frame->sheetID, entity->alpha, entity->inkEffect, FX_ALL);
             break;
 
         case ROTSTYLE_45DEG:
             if (entity->rotation >= 0x100)
-                DrawSpriteRotated(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width,
-                                  frame->height, 0x200 - ((0x214 - entity->rotation) >> 6 << 6), frame->sheetID);
-            else
-                DrawSpriteRotated(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width,
-                                  frame->height, (entity->rotation + 20) >> 6 << 6, frame->sheetID);
-            break;
+                DrawSpriteAllFX(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
+							 0x200 - ((0x214 - entity->rotation) >> 6 << 6), entity->scale, frame->sheetID, entity->alpha, entity->inkEffect, FX_ALL);
+			else
+                DrawSpriteAllFX(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
+							 (entity->rotation + 20) >> 6 << 6, entity->scale, frame->sheetID, entity->alpha, entity->inkEffect, FX_ALL);
+			break;
 
         case ROTSTYLE_STATICFRAMES: {
             if (entity->rotation >= 0x100)
@@ -3842,8 +4442,8 @@ void DrawObjectAnimation(void *objScr, void *ent, int XPos, int YPos)
             }
 
             frame = &animFrames[sprAnim->frameListOffset + frameID];
-            DrawSpriteRotated(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
-                              rotation, frame->sheetID);
+            DrawSpriteAllFX(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width, frame->height,
+							 rotation, entity->scale, frame->sheetID, entity->alpha, entity->inkEffect, FX_ALL);
             // DrawSpriteRotozoom(entity->direction, XPos, YPos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY, frame->width,
             // frame->height,
             //                  rotation, entity->scale, frame->sheetID);
@@ -4214,11 +4814,7 @@ void DrawTexturedFace(void *v, byte sheetID)
             }
             ushort *fbPtr = &frameBufferPtr[startX];
             frameBufferPtr += GFX_LINESIZE;
-#if RETRO_REV02
             int counter = posDifference;
-#else
-            int counter = posDifference + 1;
-#endif
             while (counter--) {
                 if (UPos < 0)
                     UPos = 0;
@@ -4347,11 +4943,7 @@ void DrawTexturedFaceBlended(void *v, byte sheetID)
             }
             ushort *fbPtr = &frameBufferPtr[startX];
             frameBufferPtr += GFX_LINESIZE;
-#if RETRO_REV02
             int counter = posDifference;
-#else
-            int counter = posDifference + 1;
-#endif
             while (counter--) {
                 if (UPos < 0)
                     UPos = 0;
@@ -4370,7 +4962,7 @@ void DrawTexturedFaceBlended(void *v, byte sheetID)
 #endif
 }
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 void DrawBitmapText(void *menu, int XPos, int YPos, int scale, int spacing, int rowStart, int rowCount)
 {
     TextMenu *tMenu = (TextMenu *)menu;
diff --git a/RSDKv4/Drawing.hpp b/RSDKv4/Drawing.hpp
index 3c8aea2..d909c86 100644
--- a/RSDKv4/Drawing.hpp
+++ b/RSDKv4/Drawing.hpp
@@ -2,17 +2,26 @@
 #define DRAWING_H
 
 #define SURFACE_COUNT (24)
-#define GFXDATA_SIZE  (0x800 * 0x800)
+#define GFXDATA_SIZE (0x2000 * 0x2000)
 
-#if RETRO_REV03
-#define DRAWLAYER_COUNT (8)
-#else
 #define DRAWLAYER_COUNT (7)
-#endif
 
+//changing DrawFXFlags so they can be merged with binary
+#define FX_FLIP (1)
+#define FX_ROTATE (2)
+#define FX_HSCALE (4)
+#define FX_VSCALE (8)
+#define FX_SCALE (13) //scale applies hscale, vscale AND flip (but only horizontally? TODO perhaps?
+#define FX_ROTOZOOM (15)
+#define FX_INK (16)
+#define FX_ALL (31) //ignore tint - it's unused
+#define FX_TINT (32)
 enum FlipFlags { FLIP_NONE, FLIP_X, FLIP_Y, FLIP_XY };
 enum InkFlags { INK_NONE, INK_BLEND, INK_ALPHA, INK_ADD, INK_SUB };
-enum DrawFXFlags { FX_SCALE, FX_ROTATE, FX_ROTOZOOM, FX_INK, FX_TINT, FX_FLIP };
+//3D drawing still uses these but I changed the names
+//apparently they can't have numbers in em though. so it says D instead of 3D
+//I've had a stressful day
+enum DrawFXFlags { D_SCALE, D_ROTATE, D_ROTOZOOM, D_INK, D_TINT, D_FLIP };
 
 struct DrawListEntry {
     int entityRefs[ENTITY_COUNT];
@@ -72,6 +81,7 @@ extern bool mixFiltersOnJekyll;
 extern GLint defaultFramebuffer;
 extern GLuint framebufferHiRes;
 extern GLuint renderbufferHiRes;
+extern GLuint videoBuffer;
 #endif
 
 int InitRenderDevice();
@@ -111,6 +121,7 @@ void Draw3DSkyLayer(int layerID);
 
 // Shape Drawing
 void DrawRectangle(int XPos, int YPos, int width, int height, int R, int G, int B, int A);
+void DrawClassicFade(int XPos, int YPos, int width, int height, int R, int G, int B, int A);
 void SetFadeHQ(int R, int G, int B, int A);
 void DrawTintRectangle(int XPos, int YPos, int width, int height);
 void DrawScaledTintMask(int direction, int XPos, int YPos, int pivotX, int pivotY, int scaleX, int scaleY, int width, int height, int sprX, int sprY,
@@ -124,7 +135,7 @@ void DrawSpriteClipped(int XPos, int YPos, int width, int height, int sprX, int
 void DrawSpriteFlipped(int XPos, int YPos, int width, int height, int sprX, int sprY, int direction, int sheetID);
 void DrawSpriteScaled(int direction, int XPos, int YPos, int pivotX, int pivotY, int scaleX, int scaleY, int width, int height, int sprX, int sprY,
                       int sheetID);
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 void DrawScaledChar(int direction, int XPos, int YPos, int pivotX, int pivotY, int scaleX, int scaleY, int width, int height, int sprX, int sprY,
                     int sheetID);
 #endif
@@ -132,6 +143,8 @@ void DrawSpriteRotated(int direction, int XPos, int YPos, int pivotX, int pivotY
                        int sheetID);
 void DrawSpriteRotozoom(int direction, int XPos, int YPos, int pivotX, int pivotY, int sprX, int sprY, int width, int height, int rotation, int scale,
                         int sheetID);
+void DrawSpriteAllFX(int direction, int XPos, int YPos, int pivotX, int pivotY, int sprX, int sprY, int width, int height, int rotation, int scale,
+                        int sheetID, int alpha, int ink, int flags);
 
 void DrawBlendedSprite(int XPos, int YPos, int width, int height, int sprX, int sprY, int sheetID);
 void DrawAlphaBlendedSprite(int XPos, int YPos, int width, int height, int sprX, int sprY, int alpha, int sheetID);
@@ -145,7 +158,7 @@ void DrawFadedFace(void *v, uint color, uint fogColor, int alpha);
 void DrawTexturedFace(void *v, byte sheetID);
 void DrawTexturedFaceBlended(void *v, byte sheetID);
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 void DrawBitmapText(void *menu, int XPos, int YPos, int scale, int spacing, int rowStart, int rowCount);
 #endif
 
diff --git a/RSDKv4/Ini.cpp b/RSDKv4/Ini.cpp
index 980db61..1da8e59 100644
--- a/RSDKv4/Ini.cpp
+++ b/RSDKv4/Ini.cpp
@@ -4,15 +4,6 @@
 #include <algorithm>
 #include <string>
 
-int strncmp(char const *a, char const *b)
-{
-    for (;; a++, b++) {
-        int d = tolower((unsigned char)*a) - tolower((unsigned char)*b);
-        if (d != 0 || !*a)
-            return d;
-    }
-}
-
 IniParser::IniParser(const char *filename, bool addPath)
 {
     items.clear();
@@ -133,7 +124,7 @@ int IniParser::GetFloat(const char *section, const char *key, float *dest)
         }
     }
 
-    return 0;
+    return 0.0f;
 }
 int IniParser::GetBool(const char *section, const char *key, bool *dest)
 {
@@ -143,7 +134,7 @@ int IniParser::GetBool(const char *section, const char *key, bool *dest)
     for (int x = 0; x < items.size(); x++) {
         if (!strcmp(section, items[x].section)) {
             if (!strcmp(key, items[x].key)) {
-                *dest = !strncmp(items[x].value, "true") || !strcmp(items[x].value, "1");
+                *dest = !strcmp(items[x].value, "true") || !strcmp(items[x].value, "1");
                 return 1;
             }
         }
@@ -273,8 +264,6 @@ void IniParser::Write(const char *filename, bool addPath)
             sprintf(pathBuffer, "%s/%s", getResourcesPath(), filename);
         else
             sprintf(pathBuffer, "%s", filename);
-#elif RETRO_PLATFORM == RETRO_OSX
-        sprintf(pathBuffer, "%s/%s", gamePath, filename);
 #else
         sprintf(pathBuffer, "%s", filename);
 #endif
diff --git a/RSDKv4/Input.cpp b/RSDKv4/Input.cpp
index 935d855..5378a11 100644
--- a/RSDKv4/Input.cpp
+++ b/RSDKv4/Input.cpp
@@ -1,7 +1,7 @@
 #include "RetroEngine.hpp"
 
-InputData keyPress = InputData();
-InputData keyDown  = InputData();
+InputData inputPress = InputData();
+InputData inputDown  = InputData();
 
 int touchDown[8];
 int touchX[8];
@@ -57,11 +57,12 @@ bool getControllerButton(byte buttonID)
     bool pressed = false;
 
     for (int i = 0; i < controllers.size(); ++i) {
+		if (pressed) break;
         SDL_GameController *controller = controllers[i].devicePtr;
 
         if (SDL_GameControllerGetButton(controller, (SDL_GameControllerButton)buttonID)) {
             pressed |= true;
-            continue;
+            break;
         }
         else {
             switch (buttonID) {
@@ -208,7 +209,7 @@ bool getControllerButton(byte buttonID)
 }
 #endif //! RETRO_USING_SDL2
 
-void controllerInit(int controllerID)
+void controllerInit(int controllerID) // controllerID = SDL2 controller index
 {
     for (int i = 0; i < controllers.size(); ++i) {
         if (controllers[i].id == controllerID) {
@@ -242,13 +243,16 @@ void controllerInit(int controllerID)
 #endif
 }
 
-void controllerClose(int controllerID)
+void controllerClose(int controllerID) // controllerID = SDL2 controller id
 {
 #if RETRO_USING_SDL2
     SDL_GameController *controller = SDL_GameControllerFromInstanceID(controllerID);
     if (controller) {
         SDL_GameControllerClose(controller);
 #endif
+        // ok; when compiling under msvc, this code crashes with the controllers.erase() call (when the controllers vector is 1 element long)
+        // why? i'm under the impression that it's some msvc bug to do with the vector length being 1
+        // i've really got no idea, this code compiles and works fine under linux (gcc), so i suspect it must be an msvc fault (as always lmao)
         if (controllers.size() == 1) {
             controllers.clear();
         } else {
@@ -275,11 +279,16 @@ void controllerClose(int controllerID)
 void InitInputDevices()
 {
 #if RETRO_USING_SDL2
+#if RETRO_PLATFORM == RETRO_SWITCH
+    // just gonna override the mapping and be done with it
+    SDL_GameControllerAddMapping("53776974636820436f6e74726f6c6c65,Switch Controller,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,");
+#endif
     PrintLog("Initializing gamepads...");
 
     // fix for issue #334 on github, not sure what's going wrong, but it seems to not be initializing the gamepad api maybe?
     SDL_Init(SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER);
 
+
     int joyStickCount = SDL_NumJoysticks();
     controllers.clear();
     int gamepadCount = 0;
@@ -494,11 +503,6 @@ void CheckKeyPress(InputData *input)
     input->start  = inputDevice[INPUT_START].press;
     input->select = inputDevice[INPUT_SELECT].press;
 #endif
-
-#if RETRO_REV03
-    SetGlobalVariableByName("input.pressButton", input->A || input->B || input->C || input->X || input->Y || input->Z || input->L || input->R
-                                                     || input->start || input->select);
-#endif
 }
 
 void CheckKeyDown(InputData *input)
diff --git a/RSDKv4/Input.hpp b/RSDKv4/Input.hpp
index 7419293..2d80536 100644
--- a/RSDKv4/Input.hpp
+++ b/RSDKv4/Input.hpp
@@ -1,6 +1,11 @@
 #ifndef INPUT_H
 #define INPUT_H
 
+#if RETRO_PLATFORM == RETRO_SWITCH
+// expose it for hacks
+bool getControllerButton(byte buttonID);
+#endif
+
 enum InputButtons {
     INPUT_UP,
     INPUT_DOWN,
@@ -60,8 +65,8 @@ enum DefaultHapticIDs {
     HAPTIC_STOP = -1,
 };
 
-extern InputData keyPress;
-extern InputData keyDown;
+extern InputData inputPress;
+extern InputData inputDown;
 
 extern int touchDown[8];
 extern int touchX[8];
diff --git a/RSDKv4/ModAPI.cpp b/RSDKv4/ModAPI.cpp
index 59ad313..006a23a 100644
--- a/RSDKv4/ModAPI.cpp
+++ b/RSDKv4/ModAPI.cpp
@@ -23,13 +23,14 @@ byte modObjCount = 0;
 #include <filesystem>
 #include <locale>
 
-void OpenModMenu()
+int OpenModMenu()
 {
     Engine.gameMode      = ENGINE_INITMODMENU;
     Engine.modMenuCalled = true;
+    return 1;
 }
 
-#if RETRO_PLATFORM == RETRO_ANDROID
+#if (RETRO_PLATFORM == RETRO_ANDROID)
 namespace fs = std::__fs::filesystem; // this is so we can avoid using c++17, which causes a ton of warnings w asio and looks ugly
 #else
 namespace fs = std::filesystem;
@@ -37,8 +38,12 @@ namespace fs = std::filesystem;
 
 fs::path resolvePath(fs::path given)
 {
+	    // This crashes and I don't know why
+    // Maybe to do with pathconf somehow?
+#if RETRO_PLATFORM != RETRO_SWITCH
     if (given.is_relative())
         given = fs::current_path() / given; // thanks for the weird syntax!
+#endif
     for (auto &p : fs::directory_iterator{ given.parent_path() }) {
         char pbuf[0x100];
         char gbuf[0x100];
@@ -108,7 +113,7 @@ void InitMods()
 
                     if (flag) {
                         if (LoadMod(&info, modPath.string(), modDirPath.filename().string(), false))
-                            modList.push_back(info);
+                            modList.insert(modList.begin(), info);
                     }
                 }
             }
@@ -291,6 +296,54 @@ void ScanModFolder(ModInfo *info)
         }
     }
 
+    // Check for Scripts/ replacements
+    fs::path scriptPath = resolvePath(modDir + "/Scripts");
+
+    if (fs::exists(scriptPath) && fs::is_directory(scriptPath)) {
+        try {
+            auto data_rdi = fs::recursive_directory_iterator(scriptPath);
+            for (auto &data_de : data_rdi) {
+                if (data_de.is_regular_file()) {
+                    char modBuf[0x100];
+                    StrCopy(modBuf, data_de.path().string().c_str());
+                    char folderTest[4][0x10] = {
+                        "Scripts/",
+                        "Scripts\\",
+                        "scripts/",
+                        "scripts\\",
+                    };
+                    int tokenPos = -1;
+                    for (int i = 0; i < 4; ++i) {
+                        tokenPos = FindLastStringToken(modBuf, folderTest[i]);
+                        if (tokenPos >= 0)
+                            break;
+                    }
+
+                    if (tokenPos >= 0) {
+                        char buffer[0x80];
+                        for (int i = StrLength(modBuf); i >= tokenPos; --i) {
+                            buffer[i - tokenPos] = modBuf[i] == '\\' ? '/' : modBuf[i];
+                        }
+
+                        // PrintLog(modBuf);
+                        std::string path(buffer);
+                        std::string modPath(modBuf);
+                        char pathLower[0x100];
+                        memset(pathLower, 0, sizeof(char) * 0x100);
+                        for (int c = 0; c < path.size(); ++c) {
+                            pathLower[c] = tolower(path.c_str()[c]);
+                        }
+
+                        info->fileMap.insert(std::pair<std::string, std::string>(pathLower, modBuf));
+                    }
+                }
+            }
+        } catch (fs::filesystem_error fe) {
+            PrintLog("Script Folder Scanning Error: ");
+            PrintLog(fe.what());
+        }
+    }
+
     // Check for Bytecode/ replacements
     fs::path bytecodePath = resolvePath(modDir + "/Bytecode");
 
@@ -367,12 +420,12 @@ void RefreshEngine()
 #if RETRO_USING_SDL2
     if (Engine.window) {
         char gameTitle[0x40];
-        sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : " (Using Data Folder)");
+        sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : "");
         SDL_SetWindowTitle(Engine.window, gameTitle);
     }
 #elif RETRO_USING_SDL1
     char gameTitle[0x40];
-    sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : " (Using Data Folder)");
+    sprintf(gameTitle, "%s%s", Engine.gameWindowText, Engine.usingDataFile_Config ? "" : "");
     SDL_WM_SetCaption(gameTitle, NULL);
 #endif
 
@@ -512,7 +565,6 @@ void GetModActive(uint *id, int *unused)
     scriptEng.checkResult = false;
     if (*id >= modList.size())
         return;
-
     scriptEng.checkResult = modList[*id].active;
 }
 
@@ -526,7 +578,7 @@ void SetModActive(uint *id, int *active)
 
 void MoveMod(uint *id, int *up)
 {
-    if (!id || !up)
+    if (!id)
         return;
 
     int preOption = *id;
diff --git a/RSDKv4/ModAPI.hpp b/RSDKv4/ModAPI.hpp
index f3492ce..16a35f9 100644
--- a/RSDKv4/ModAPI.hpp
+++ b/RSDKv4/ModAPI.hpp
@@ -6,12 +6,19 @@
 extern char playerNames[PLAYER_COUNT][0x20];
 extern byte playerCount;
 
+// These are still needed even if RETRO_USE_MOD_LOADER isn't defined
+extern bool redirectSave;
+extern char modsPath[0x100];
+extern char savePath[0x100];
+
 #if RETRO_USE_MOD_LOADER
 #include <string>
 #include <map>
 #include <unordered_map>
 #include <tinyxml2.h>
 
+#define PLAYER_COUNT (0x10)
+
 struct ModInfo {
     std::string name;
     std::string desc;
@@ -40,6 +47,9 @@ extern char modScriptPaths[OBJECT_COUNT][0x40];
 extern byte modScriptFlags[OBJECT_COUNT];
 extern byte modObjCount;
 
+extern char playerNames[PLAYER_COUNT][0x20];
+extern byte playerCount;
+
 inline void SetActiveMod(int id) { activeMod = id; }
 
 void InitMods();
@@ -47,7 +57,7 @@ bool LoadMod(ModInfo *info, std::string modsPath, std::string folder, bool activ
 void ScanModFolder(ModInfo *info);
 void SaveMods();
 
-void OpenModMenu();
+int OpenModMenu();
 
 void RefreshEngine();
 void GetModCount();
diff --git a/RSDKv4/NativeObjects/AboutScreen.cpp b/RSDKv4/NativeObjects/AboutScreen.cpp
index f6da82f..65cfc30 100644
--- a/RSDKv4/NativeObjects/AboutScreen.cpp
+++ b/RSDKv4/NativeObjects/AboutScreen.cpp
@@ -102,8 +102,8 @@ void AboutScreen_Main(void *objPtr)
             break;
         }
         case ABOUT_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
 
             if (usePhysicalControls) {
@@ -111,13 +111,13 @@ void AboutScreen_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton--;
                         if (self->selectedButton < 0)
                             self->selectedButton = 1;
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton++;
                         if (self->selectedButton >= 2)
@@ -127,12 +127,12 @@ void AboutScreen_Main(void *objPtr)
                     for (int i = 0; i < ABOUT_BTN_COUNT; ++i) self->buttons[i]->state = 0;
                     self->buttons[self->selectedButton]->state = 1;
 
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         PlaySfxByName("Menu Select", false);
                         self->buttons[self->selectedButton]->state = 2;
                         self->state                                = ABOUT_STATE_ACTION;
                     }
-                    else if (keyPress.B) {
+                    else if (inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = ABOUT_STATE_EXIT;
@@ -150,11 +150,11 @@ void AboutScreen_Main(void *objPtr)
                     }
                     self->backPressed = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
                     if (self->state == ABOUT_STATE_MAIN) {
-                        if (keyDown.up) {
+                        if (inputDown.up) {
                             self->selectedButton = 1;
                             usePhysicalControls  = true;
                         }
-                        if (keyDown.down) {
+                        if (inputDown.down) {
                             self->selectedButton = 0;
                             usePhysicalControls  = true;
                         }
@@ -171,18 +171,18 @@ void AboutScreen_Main(void *objPtr)
                         }
                     }
 
-                    if (keyPress.B || self->backPressed) {
+                    if (inputPress.B || self->backPressed) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = ABOUT_STATE_EXIT;
                     }
                     else {
                         if (self->state == ABOUT_STATE_MAIN) {
-                            if (keyDown.up) {
+                            if (inputDown.up) {
                                 self->selectedButton = 1;
                                 usePhysicalControls  = true;
                             }
-                            if (keyDown.down) {
+                            if (inputDown.down) {
                                 self->selectedButton = 0;
                                 usePhysicalControls  = true;
                             }
@@ -193,7 +193,7 @@ void AboutScreen_Main(void *objPtr)
             break;
         }
         case ABOUT_STATE_ACTION: {
-            CheckKeyDown(&keyDown);
+            CheckKeyDown(&inputDown);
             SetRenderMatrix(&self->renderMatrix);
 
             if (self->buttons[self->selectedButton]->state) {
diff --git a/RSDKv4/NativeObjects/AchievementsMenu.cpp b/RSDKv4/NativeObjects/AchievementsMenu.cpp
index 760db05..8440cef 100644
--- a/RSDKv4/NativeObjects/AchievementsMenu.cpp
+++ b/RSDKv4/NativeObjects/AchievementsMenu.cpp
@@ -73,8 +73,8 @@ void AchievementsMenu_Main(void *objPtr)
             break;
         }
         case 1: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
 
             if (usePhysicalControls) {
@@ -82,12 +82,12 @@ void AchievementsMenu_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                     }
 
-                    if (keyPress.B) {
+                    if (inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = ABOUT_STATE_EXIT;
@@ -99,17 +99,17 @@ void AchievementsMenu_Main(void *objPtr)
                     self->backPressed = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
                 }
                 else {
-                    if (keyPress.B || self->backPressed) {
+                    if (inputPress.B || self->backPressed) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = ABOUT_STATE_EXIT;
                     }
                     else {
                         if (self->state == ABOUT_STATE_MAIN) {
-                            if (keyDown.up) {
+                            if (inputDown.up) {
                                 usePhysicalControls = true;
                             }
-                            if (keyDown.down) {
+                            if (inputDown.down) {
                                 usePhysicalControls = true;
                             }
                         }
diff --git a/RSDKv4/NativeObjects/DialogPanel.cpp b/RSDKv4/NativeObjects/DialogPanel.cpp
index 5e4af91..b37189f 100644
--- a/RSDKv4/NativeObjects/DialogPanel.cpp
+++ b/RSDKv4/NativeObjects/DialogPanel.cpp
@@ -74,8 +74,8 @@ void DialogPanel_Main(void *objPtr)
             break;
         }
         case DIALOGPANEL_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->buttonMatrix);
             if (!usePhysicalControls) {
                 if (touches < 1) {
@@ -104,11 +104,11 @@ void DialogPanel_Main(void *objPtr)
                             CheckTouchRect(36.0, -30.0, (self->buttons[1]->textWidth + (self->buttons[1]->scale * 64.0)) * 0.75, 12.0) >= 0;
                     }
                 }
-                if (keyDown.left) {
+                if (inputDown.left) {
                     usePhysicalControls  = true;
                     self->buttonSelected = 1;
                 }
-                else if (keyDown.right) {
+                else if (inputDown.right) {
                     usePhysicalControls  = true;
                     self->buttonSelected = 0;
                 }
@@ -118,19 +118,19 @@ void DialogPanel_Main(void *objPtr)
             }
             else if (self->buttonCount == DLGTYPE_OK) {
                 self->buttonSelected = 0;
-                if (keyPress.start || keyPress.A) {
+                if (inputPress.start || inputPress.A) {
                     self->state = DIALOGPANEL_STATE_ACTION;
                     PlaySfxByName("Menu Select", false);
                     self->buttons[self->buttonSelected]->state = 2;
                 }
             }
             else {
-                if (keyPress.left) {
+                if (inputPress.left) {
                     PlaySfxByName("Menu Move", false);
                     if (--self->buttonSelected < 0)
                         self->buttonSelected = 1;
                 }
-                if (keyPress.right) {
+                if (inputPress.right) {
                     PlaySfxByName("Menu Move", false);
                     if (++self->buttonSelected > 1)
                         self->buttonSelected = 0;
@@ -139,13 +139,13 @@ void DialogPanel_Main(void *objPtr)
                 self->buttons[1]->state                    = 0;
                 self->buttons[self->buttonSelected]->state = 1;
 
-                if (keyPress.start || keyPress.A) {
+                if (inputPress.start || inputPress.A) {
                     self->state = DIALOGPANEL_STATE_ACTION;
                     PlaySfxByName("Menu Select", false);
                     self->buttons[self->buttonSelected]->state = 2;
                 }
             }
-            if (self->state == 2 && keyPress.B) {
+            if (self->state == 2 && inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->selection = DLG_NO;
                 self->state     = DIALOGPANEL_STATE_EXIT;
diff --git a/RSDKv4/NativeObjects/InstructionsScreen.cpp b/RSDKv4/NativeObjects/InstructionsScreen.cpp
index 8e823ba..bf5e058 100644
--- a/RSDKv4/NativeObjects/InstructionsScreen.cpp
+++ b/RSDKv4/NativeObjects/InstructionsScreen.cpp
@@ -70,8 +70,8 @@ void InstructionsScreen_Main(void *objPtr)
         }
 
         case INSTRUCTIONSCREEN_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->matrixTemp);
 
             if (usePhysicalControls) {
@@ -84,13 +84,13 @@ void InstructionsScreen_Main(void *objPtr)
                     self->touchedBack = false;
 
                     if (self->textHeight > 68.0) {
-                        if (keyDown.up)
+                        if (inputDown.up)
                             self->textY = fmaxf(68.0, self->textY - 2.0);
-                        if (keyDown.down)
+                        if (inputDown.down)
                             self->textY = fminf(self->textHeight, self->textY + 2.0);
                     }
 
-                    if (keyDown.left) {
+                    if (inputDown.left) {
                         PlaySfxByName("Menu Move", false);
                         self->state       = INSTRUCTIONSCREEN_STATE_FLIP;
                         self->stateInput  = INSTRUCTIONSCREEN_STATEINPUT_CHECKPRESS;
@@ -99,7 +99,7 @@ void InstructionsScreen_Main(void *objPtr)
                         if (--self->pageID < 0)
                             self->pageID = 4;
                     }
-                    else if (keyDown.right) {
+                    else if (inputDown.right) {
                         PlaySfxByName("Menu Move", false);
                         self->state       = INSTRUCTIONSCREEN_STATE_FLIP;
                         self->stateInput  = INSTRUCTIONSCREEN_STATEINPUT_CHECKPRESS;
@@ -123,7 +123,7 @@ void InstructionsScreen_Main(void *objPtr)
                             self->selectionEnabled = false;
                         }
 
-                        if (keyDown.up || keyDown.down)
+                        if (inputDown.up || inputDown.down)
                             usePhysicalControls = true;
                         break;
 
@@ -246,10 +246,10 @@ void InstructionsScreen_Main(void *objPtr)
                 self->selectionEnabled = false;
             }
 
-            if (keyDown.up || keyDown.down || keyDown.left || keyDown.right)
+            if (inputDown.up || inputDown.down || inputDown.left || inputDown.right)
                 usePhysicalControls = true;
 
-            if (self->state == 1 && keyPress.B) {
+            if (self->state == 1 && inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->touchedBack = false;
                 self->state       = INSTRUCTIONSCREEN_STATE_EXIT;
diff --git a/RSDKv4/NativeObjects/MenuControl.cpp b/RSDKv4/NativeObjects/MenuControl.cpp
index 6fec3cb..3b352ae 100644
--- a/RSDKv4/NativeObjects/MenuControl.cpp
+++ b/RSDKv4/NativeObjects/MenuControl.cpp
@@ -81,8 +81,8 @@ void MenuControl_Main(void *objPtr)
 
     switch (self->state) {
         case MENUCONTROL_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
             if (segaIDButton->alpha < 0x100 && Engine.language != RETRO_JP && !(Engine.language == RETRO_ZH || Engine.language == RETRO_ZS)
                 && Engine.gameDeviceType == RETRO_MOBILE)
@@ -92,7 +92,7 @@ void MenuControl_Main(void *objPtr)
                 switch (self->stateInput) {
                     case MENUCONTROL_STATEINPUT_CHECKTOUCH: {
                         if (touches > 0) {
-                            if (!keyDown.left && !keyDown.right) {
+                            if (!inputDown.left && !inputDown.right) {
                                 segaIDButton->state = SEGAIDBUTTON_STATE_IDLE;
                                 if (CheckTouchRect(0.0, 16.0, 56.0, 56.0) >= 0) {
                                     BackupNativeObjects();
@@ -125,7 +125,7 @@ void MenuControl_Main(void *objPtr)
                             PlaySfxByName("Menu Select", false);
                             ShowPromoPopup(0, "MoreGames");
                         }
-                        else if (keyDown.left || keyDown.right) {
+                        else if (inputDown.left || inputDown.right) {
                             segaIDButton->state              = SEGAIDBUTTON_STATE_IDLE;
                             usePhysicalControls              = true;
                             self->buttonID                   = ceilf(self->buttonMovePos / -self->buttonSpacing);
@@ -248,7 +248,7 @@ void MenuControl_Main(void *objPtr)
                 }
                 else {
                     if (touches <= 0) {
-                        if (keyPress.right && self->buttonMovePos > -(self->menuEndPos - self->buttonSpacing)) {
+                        if (inputPress.right && self->buttonMovePos > -(self->menuEndPos - self->buttonSpacing)) {
                             self->stateInput = MENUCONTROL_STATEINPUT_HANDLEDRAG;
                             self->targetButtonMovePos -= self->buttonSpacing;
                             PlaySfxByName("Menu Move", false);
@@ -257,7 +257,7 @@ void MenuControl_Main(void *objPtr)
                             if (self->buttonID >= self->buttonCount)
                                 self->buttonID = self->buttonCount - 1;
                         }
-                        else if (keyPress.left && self->buttonMovePos < 0.0) {
+                        else if (inputPress.left && self->buttonMovePos < 0.0) {
                             self->stateInput = MENUCONTROL_STATEINPUT_HANDLEDRAG;
                             self->targetButtonMovePos += self->buttonSpacing;
                             PlaySfxByName("Menu Move", false);
@@ -266,7 +266,7 @@ void MenuControl_Main(void *objPtr)
                             if (self->buttonID > self->buttonCount)
                                 self->buttonID = 0;
                         }
-                        else if ((keyPress.start || keyPress.A) && !Engine.nativeMenuFadeIn) {
+                        else if ((inputPress.start || inputPress.A) && !Engine.nativeMenuFadeIn) {
                             BackupNativeObjects();
                             self->buttons[self->buttonID]->labelPtr->state = TEXTLABEL_STATE_BLINK_FAST;
                             self->timer                                    = 0.0;
@@ -302,7 +302,7 @@ void MenuControl_Main(void *objPtr)
                 if (self->dialogTimer) {
                     self->dialogTimer--;
                 }
-                else if (keyPress.B && !Engine.nativeMenuFadeIn) {
+                else if (inputPress.B && !Engine.nativeMenuFadeIn) {
                     self->dialog = CREATE_ENTITY(DialogPanel);
                     SetStringToFont(self->dialog->text, strExitGame, FONT_TEXT);
                     self->state = MENUCONTROL_STATE_DIALOGWAIT;
@@ -461,8 +461,8 @@ void MenuControl_Main(void *objPtr)
         }
 
         case MENUCONTROL_STATE_SUBMENU: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             if (touches <= 0) {
                 if (self->backButton->g == 0xC0) {
                     PlaySfxByName("Menu Back", false);
@@ -477,7 +477,7 @@ void MenuControl_Main(void *objPtr)
                 else
                     backButton->g = 0xC0;
             }
-            if (keyPress.B) {
+            if (inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->backButton->g = 0xFF;
                 self->state         = MENUCONTROL_STATE_EXITSUBMENU;
diff --git a/RSDKv4/NativeObjects/MultiplayerScreen.cpp b/RSDKv4/NativeObjects/MultiplayerScreen.cpp
index 616f334..d5161e3 100644
--- a/RSDKv4/NativeObjects/MultiplayerScreen.cpp
+++ b/RSDKv4/NativeObjects/MultiplayerScreen.cpp
@@ -290,8 +290,8 @@ void MultiplayerScreen_Main(void *objPtr)
             break;
         }
         case MULTIPLAYERSCREEN_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
 
             if (usePhysicalControls) {
@@ -299,13 +299,13 @@ void MultiplayerScreen_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton--;
                         if (self->selectedButton < MULTIPLAYERSCREEN_BUTTON_HOST)
                             self->selectedButton = MULTIPLAYERSCREEN_BUTTON_JOIN;
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton++;
                         if (self->selectedButton > MULTIPLAYERSCREEN_BUTTON_JOIN)
@@ -316,12 +316,12 @@ void MultiplayerScreen_Main(void *objPtr)
                     self->buttons[MULTIPLAYERSCREEN_BUTTON_JOIN]->state = PUSHBUTTON_STATE_UNSELECTED;
                     self->buttons[self->selectedButton]->state          = PUSHBUTTON_STATE_SELECTED;
 
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         PlaySfxByName("Menu Select", false);
                         self->buttons[self->selectedButton]->state = PUSHBUTTON_STATE_FLASHING;
                         self->state                                = MULTIPLAYERSCREEN_STATE_ACTION;
                     }
-                    else if (keyPress.B || self->backPressed) {
+                    else if (inputPress.B || self->backPressed) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed             = false;
                         self->state                   = MULTIPLAYERSCREEN_STATE_EXIT;
@@ -340,11 +340,11 @@ void MultiplayerScreen_Main(void *objPtr)
                     }
                     self->backPressed = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
                     if (self->state == MULTIPLAYERSCREEN_STATE_MAIN) {
-                        if (keyDown.left) {
+                        if (inputDown.left) {
                             self->selectedButton = MULTIPLAYERSCREEN_BUTTON_JOIN;
                             usePhysicalControls  = true;
                         }
-                        if (keyDown.right) {
+                        if (inputDown.right) {
                             self->selectedButton = MULTIPLAYERSCREEN_BUTTON_HOST;
                             usePhysicalControls  = true;
                         }
@@ -361,7 +361,7 @@ void MultiplayerScreen_Main(void *objPtr)
                         }
                     }
 
-                    if (keyPress.B || self->backPressed) {
+                    if (inputPress.B || self->backPressed) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed             = false;
                         self->state                   = MULTIPLAYERSCREEN_STATE_EXIT;
@@ -372,11 +372,11 @@ void MultiplayerScreen_Main(void *objPtr)
                     }
                     else {
                         if (self->state == MULTIPLAYERSCREEN_STATE_MAIN) {
-                            if (keyDown.down) {
+                            if (inputDown.down) {
                                 self->selectedButton = MULTIPLAYERSCREEN_BUTTON_JOIN;
                                 usePhysicalControls  = true;
                             }
-                            if (keyDown.up) {
+                            if (inputDown.up) {
                                 self->selectedButton = MULTIPLAYERSCREEN_BUTTON_HOST;
                                 usePhysicalControls  = true;
                             }
@@ -387,7 +387,7 @@ void MultiplayerScreen_Main(void *objPtr)
             break;
         }
         case MULTIPLAYERSCREEN_STATE_ACTION: { // action
-            CheckKeyDown(&keyDown);
+            CheckKeyDown(&inputDown);
             SetRenderMatrix(&self->renderMatrix);
 
             if (self->buttons[self->selectedButton]->state == PUSHBUTTON_STATE_UNSELECTED) {
@@ -521,8 +521,8 @@ void MultiplayerScreen_Main(void *objPtr)
             break;
         }
         case MULTIPLAYERSCREEN_STATE_HOSTSCR: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
 
             if (!self->roomCode) {
@@ -550,14 +550,14 @@ void MultiplayerScreen_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.A || keyPress.start) {
+                    if (inputPress.A || inputPress.start) {
                         PlaySfxByName("Menu Select", false);
                         char buffer[0x30];
                         int code = GetRoomCode();
                         sprintf(buffer, "%08X", code);
                         SDL_SetClipboardText(buffer);
                     }
-                    if (keyPress.B) {
+                    if (inputPress.B) {
                         self->dialog = CREATE_ENTITY(DialogPanel);
                         SetStringToFont8(self->dialog->text,
                                          "Are you sure you want to exit?\rThis will close the room,\rand you will return to the main menu.", 2);
@@ -577,10 +577,10 @@ void MultiplayerScreen_Main(void *objPtr)
                                                                           >= 0;
                 }
                 else {
-                    self->buttons[MULTIPLAYERSCREEN_BUTTON_COPY]->state |= keyPress.A || keyPress.start;
+                    self->buttons[MULTIPLAYERSCREEN_BUTTON_COPY]->state |= inputPress.A || inputPress.start;
                     if (self->buttons[MULTIPLAYERSCREEN_BUTTON_COPY]->state) {
                         self->buttons[MULTIPLAYERSCREEN_BUTTON_COPY]->state = PUSHBUTTON_STATE_UNSELECTED;
-                        if (keyPress.A || keyPress.start)
+                        if (inputPress.A || inputPress.start)
                             usePhysicalControls = true;
                         PlaySfxByName("Menu Select", false);
                         char buffer[0x30];
@@ -588,7 +588,7 @@ void MultiplayerScreen_Main(void *objPtr)
                         sprintf(buffer, "%08X", code);
                         SDL_SetClipboardText(buffer);
                     }
-                    if (keyPress.B || self->backPressed) {
+                    if (inputPress.B || self->backPressed) {
                         self->backPressed = false;
                         self->dialog      = CREATE_ENTITY(DialogPanel);
                         SetStringToFont8(self->dialog->text,
@@ -602,8 +602,8 @@ void MultiplayerScreen_Main(void *objPtr)
             break;
         }
         case MULTIPLAYERSCREEN_STATE_JOINSCR: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
 
             if (usePhysicalControls) {
@@ -611,13 +611,13 @@ void MultiplayerScreen_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.left) {
+                    if (inputPress.left) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton--;
                         if (self->selectedButton < 3)
                             self->selectedButton = 12;
                     }
-                    else if (keyPress.right) {
+                    else if (inputPress.right) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton++;
                         if (self->selectedButton > 12)
@@ -625,7 +625,7 @@ void MultiplayerScreen_Main(void *objPtr)
                     }
 
                     if ((self->selectedButton != MULTIPLAYERSCREEN_BUTTON_JOINROOM && self->selectedButton != MULTIPLAYERSCREEN_BUTTON_PASTE)
-                        && (keyPress.up || keyPress.down)) {
+                        && (inputPress.up || inputPress.down)) {
                         union {
                             int val;
                             byte bytes[4];
@@ -634,11 +634,11 @@ void MultiplayerScreen_Main(void *objPtr)
                         int n         = 7 - (self->selectedButton - 5);
                         int nybbles[] = { u.bytes[n >> 1] & 0xF, ((u.bytes[n >> 1] & 0xF0) >> 4) & 0xF };
 
-                        if (keyPress.up) {
+                        if (inputPress.up) {
                             PlaySfxByName("Menu Move", false);
                             nybbles[n & 1] = (nybbles[n & 1] + 1) & 0xF;
                         }
-                        else if (keyPress.down) {
+                        else if (inputPress.down) {
                             PlaySfxByName("Menu Move", false);
                             nybbles[n & 1] = (nybbles[n & 1] - 1) & 0xF;
                         }
@@ -668,7 +668,7 @@ void MultiplayerScreen_Main(void *objPtr)
                         self->enterCodeLabel[self->selectedButton - 5]->useColors = true;
                     }
 
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         if (self->selectedButton == MULTIPLAYERSCREEN_BUTTON_JOINROOM) {
                             PlaySfxByName("Menu Select", false);
                             self->buttons[MULTIPLAYERSCREEN_BUTTON_JOINROOM]->state = PUSHBUTTON_STATE_UNSELECTED;
@@ -702,7 +702,7 @@ void MultiplayerScreen_Main(void *objPtr)
                             SDL_free(txt);
                         }
                     }
-                    else if (keyPress.B) {
+                    else if (inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->state         = MULTIPLAYERSCREEN_STATE_FLIP;
                         self->nextState     = MULTIPLAYERSCREEN_STATE_MAIN;
@@ -751,7 +751,7 @@ void MultiplayerScreen_Main(void *objPtr)
                         >= 0;
 
                     self->backPressed = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
-                    if (keyDown.left || keyDown.right) {
+                    if (inputDown.left || inputDown.right) {
                         usePhysicalControls = true;
                     }
                 }
@@ -839,7 +839,7 @@ void MultiplayerScreen_Main(void *objPtr)
                         SDL_free(txt);
                     }
 
-                    if (keyPress.B || self->backPressed) {
+                    if (inputPress.B || self->backPressed) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed   = false;
                         self->state         = MULTIPLAYERSCREEN_STATE_FLIP;
@@ -847,11 +847,11 @@ void MultiplayerScreen_Main(void *objPtr)
                         self->nextStateDraw = MULTIPLAYERSCREEN_STATEDRAW_MAIN;
                     }
                     else {
-                        if (keyDown.left) {
+                        if (inputDown.left) {
                             self->selectedButton = 5;
                             usePhysicalControls  = true;
                         }
-                        if (keyDown.right) {
+                        if (inputDown.right) {
                             self->selectedButton = 12;
                             usePhysicalControls  = true;
                         }
diff --git a/RSDKv4/NativeObjects/OptionsMenu.cpp b/RSDKv4/NativeObjects/OptionsMenu.cpp
index 3628ae1..5aa6db7 100644
--- a/RSDKv4/NativeObjects/OptionsMenu.cpp
+++ b/RSDKv4/NativeObjects/OptionsMenu.cpp
@@ -71,8 +71,8 @@ void OptionsMenu_Main(void *objPtr)
             if (self->timer > 1.0) {
                 self->timer      = 0.0;
                 self->state      = OPTIONSMENU_STATE_MAIN;
-                keyPress.start = false;
-                keyPress.A     = false;
+                inputPress.start = false;
+                inputPress.A     = false;
             }
             break;
         }
@@ -85,13 +85,13 @@ void OptionsMenu_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton--;
                         if (self->selectedButton < 0)
                             self->selectedButton = OPTIONSMENU_BUTTON_COUNT - 1;
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton++;
                         if (self->selectedButton >= OPTIONSMENU_BUTTON_COUNT)
@@ -100,16 +100,11 @@ void OptionsMenu_Main(void *objPtr)
                     for (int i = 0; i < OPTIONSMENU_BUTTON_COUNT; ++i) self->buttons[i]->b = 0xFF;
                     self->buttons[self->selectedButton]->b = 0x00;
 
-                    if (self->buttons[self->selectedButton]->g > 0x80 && (keyPress.start || keyPress.A)) {
+                    if (self->buttons[self->selectedButton]->g > 0x80 && (inputPress.start || inputPress.A)) {
                         PlaySfxByName("Menu Select", false);
                         self->buttons[self->selectedButton]->state = SUBMENUBUTTON_STATE_FLASHING2;
                         self->buttons[self->selectedButton]->b     = 0xFF;
                         self->state                                = OPTIONSMENU_STATE_ACTION;
-#if !RETRO_USE_ORIGINAL_CODE
-                        self->unused1 = Engine.devMenu && self->selectedButton == OPTIONSMENU_BUTTON_INSTRUCTIONS && !keyDown.X;
-                        if (self->unused1)
-                            StopMusic(true);
-#endif
                     }
                 }
             }
@@ -128,17 +123,12 @@ void OptionsMenu_Main(void *objPtr)
                         self->buttons[i]->state = SUBMENUBUTTON_STATE_FLASHING2;
                         self->buttons[i]->b     = 0xFF;
                         self->state             = OPTIONSMENU_STATE_ACTION;
-#if !RETRO_USE_ORIGINAL_CODE
-                        self->unused1 = Engine.devMenu && self->selectedButton == OPTIONSMENU_BUTTON_INSTRUCTIONS;
-                        if (self->unused1)
-                            StopMusic(true);
-#endif
                         break;
                     }
                     y -= 30.0;
                 }
 
-                if (self->state == OPTIONSMENU_STATE_MAIN && (keyDown.up || keyDown.down)) {
+                if (self->state == OPTIONSMENU_STATE_MAIN && (inputDown.up || inputDown.down)) {
                     self->selectedButton = 0;
                     usePhysicalControls  = true;
                 }
@@ -162,27 +152,16 @@ void OptionsMenu_Main(void *objPtr)
         case OPTIONSMENU_STATE_ACTION: {
             self->menuControl->state = MENUCONTROL_STATE_NONE;
             if (!self->buttons[self->selectedButton]->state) {
-#if !RETRO_USE_ORIGINAL_CODE
-                if (!self->unused1) {
-#endif
-                    self->state = OPTIONSMENU_STATE_ENTERSUBMENU;
+                self->state = OPTIONSMENU_STATE_ENTERSUBMENU;
 
-                    self->labelRotateYVelocity = 0.0;
-                    self->targetLabelRotateY   = DegreesToRad(-90.0);
-                    for (int i = 0; i < OPTIONSMENU_BUTTON_COUNT; ++i) self->targetButtonRotateY[i] = DegreesToRad(-90.0);
-                    float val = 0.02;
-                    for (int i = 0; i < OPTIONSMENU_BUTTON_COUNT; ++i) {
-                        self->buttonRotateYVelocity[i] = val;
-                        val += 0.02;
-                    }
-#if !RETRO_USE_ORIGINAL_CODE
-                }
-                else {
-                    self->state = OPTIONSMENU_STATE_SUBMENU;
-                    CREATE_ENTITY(FadeScreen);
-                    Engine.gameMode = ENGINE_INITDEVMENU;
+                self->labelRotateYVelocity = 0.0;
+                self->targetLabelRotateY   = DegreesToRad(-90.0);
+                for (int i = 0; i < OPTIONSMENU_BUTTON_COUNT; ++i) self->targetButtonRotateY[i] = DegreesToRad(-90.0);
+                float val = 0.02;
+                for (int i = 0; i < OPTIONSMENU_BUTTON_COUNT; ++i) {
+                    self->buttonRotateYVelocity[i] = val;
+                    val += 0.02;
                 }
-#endif
             }
             break;
         }
@@ -224,8 +203,19 @@ void OptionsMenu_Main(void *objPtr)
                 switch (self->selectedButton) {
                     default: break;
                     case OPTIONSMENU_BUTTON_INSTRUCTIONS:
+#if !RETRO_USE_ORIGINAL_CODE
+                        if (!Engine.devMenu) {
+                            self->instructionsScreen              = CREATE_ENTITY(InstructionsScreen);
+                            self->instructionsScreen->optionsMenu = self;
+                        }
+                        else {
+                            CREATE_ENTITY(FadeScreen);
+                            Engine.gameMode = ENGINE_INITDEVMENU;
+                        }
+#else
                         self->instructionsScreen              = CREATE_ENTITY(InstructionsScreen);
                         self->instructionsScreen->optionsMenu = self;
+#endif
                         break;
                     case OPTIONSMENU_BUTTON_SETTINGS:
                         self->settingsScreen              = CREATE_ENTITY(SettingsScreen);
diff --git a/RSDKv4/NativeObjects/OptionsMenu.hpp b/RSDKv4/NativeObjects/OptionsMenu.hpp
index 4236dd8..499cefe 100644
--- a/RSDKv4/NativeObjects/OptionsMenu.hpp
+++ b/RSDKv4/NativeObjects/OptionsMenu.hpp
@@ -23,7 +23,7 @@ enum OptionsMenuButtons {
 struct NativeEntity_OptionsMenu : NativeEntityBase {
     OptionsMenuStates state;
     float timer;
-    int unused1; // Used for checking if the dev menu should be entered in the decomp
+    int unused1;
     NativeEntity_MenuControl *menuControl;
     NativeEntity_InstructionsScreen *instructionsScreen;
     NativeEntity_SettingsScreen *settingsScreen;
diff --git a/RSDKv4/NativeObjects/PauseMenu.cpp b/RSDKv4/NativeObjects/PauseMenu.cpp
index 453de91..664f95f 100644
--- a/RSDKv4/NativeObjects/PauseMenu.cpp
+++ b/RSDKv4/NativeObjects/PauseMenu.cpp
@@ -115,12 +115,9 @@ void PauseMenu_Create(void *objPtr)
         default: break;
     }
 #endif
-
     pauseMenuButtonCount = PMB_COUNT;
-#if !RETRO_USE_ORIGINAL_CODE
-    if (!Engine.devMenu)
+    if (PMB_COUNT == 5 && !Engine.devMenu)
         pauseMenuButtonCount--;
-#endif
 
     self->retroGameLoop = (NativeEntity_RetroGameLoop *)GetNativeObject(0);
     self->label         = CREATE_ENTITY(TextLabel);
@@ -161,10 +158,8 @@ void PauseMenu_Create(void *objPtr)
     SetStringToFont(self->buttons[PMB_RESTART]->text, strRestart, FONT_LABEL);
     SetStringToFont(self->buttons[PMB_SETTINGS]->text, strSettings, FONT_LABEL);
     SetStringToFont(self->buttons[PMB_EXIT]->text, strExit, FONT_LABEL);
-#if !RETRO_USE_ORIGINAL_CODE
-    if (Engine.devMenu)
+    if (pauseMenuButtonCount == 5)
         SetStringToFont(self->buttons[PMB_DEVMENU]->text, strDevMenu, FONT_LABEL);
-#endif
     self->textureCircle = LoadTexture("Data/Game/Menu/Circle.png", TEXFMT_RGBA4444);
     self->rotationY     = 0.0;
     self->rotYOff       = DegreesToRad(-16.0);
@@ -210,20 +205,20 @@ void PauseMenu_Main(void *objPtr)
             break;
         }
         case PAUSEMENU_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             if (usePhysicalControls) {
                 if (touches > 0) {
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->buttonSelected--;
                         if (self->buttonSelected < PMB_CONTINUE)
                             self->buttonSelected = pauseMenuButtonCount - 1;
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->buttonSelected++;
                         if (self->buttonSelected >= pauseMenuButtonCount)
@@ -231,7 +226,7 @@ void PauseMenu_Main(void *objPtr)
                     }
                     for (int i = 0; i < pauseMenuButtonCount; ++i) self->buttons[i]->b = self->buttons[i]->r;
                     self->buttons[self->buttonSelected]->b = 0;
-                    if (self->buttons[self->buttonSelected]->g > 0x80 && (keyPress.start || keyPress.A)) {
+                    if (self->buttons[self->buttonSelected]->g > 0x80 && (inputPress.start || inputPress.A)) {
                         PlaySfxByName("Menu Select", false);
                         self->buttons[self->buttonSelected]->state = SUBMENUBUTTON_STATE_FLASHING2;
                         self->buttons[self->buttonSelected]->b     = 0xFF;
@@ -257,7 +252,7 @@ void PauseMenu_Main(void *objPtr)
                     }
                 }
 
-                if (self->state == PAUSEMENU_STATE_MAIN && (keyDown.up || keyDown.down)) {
+                if (self->state == PAUSEMENU_STATE_MAIN && (inputDown.up || inputDown.down)) {
                     self->buttonSelected = PMB_CONTINUE;
                     usePhysicalControls  = true;
                 }
diff --git a/RSDKv4/NativeObjects/PlayerSelectScreen.cpp b/RSDKv4/NativeObjects/PlayerSelectScreen.cpp
index 668578c..37ed743 100644
--- a/RSDKv4/NativeObjects/PlayerSelectScreen.cpp
+++ b/RSDKv4/NativeObjects/PlayerSelectScreen.cpp
@@ -60,8 +60,8 @@ void PlayerSelectScreen_Main(void *objPtr)
             if (self->timer > 0.5) {
                 self->timer      = 0.0;
                 self->state      = PLAYERSELECTSCREEN_STATE_MAIN;
-                keyPress.start = false;
-                keyPress.A     = false;
+                inputPress.start = false;
+                inputPress.A     = false;
                 self->alpha      = 256;
                 if (usePhysicalControls)
                     self->playerID = SAVESEL_SONIC;
@@ -69,27 +69,27 @@ void PlayerSelectScreen_Main(void *objPtr)
             break;
 
         case PLAYERSELECTSCREEN_STATE_MAIN:
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->matrixTemp);
             if (usePhysicalControls) {
                 if (touches > 0) {
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.left) {
+                    if (inputPress.left) {
                         if (saveGame->knuxUnlocked) {
                             PlaySfxByName("Menu Move", false);
-                            if (--self->playerID < SAVESEL_SONIC)
+                            if (--self->playerID < 0)
                                 self->playerID = SAVESEL_KNUX;
                         }
                         else if (saveGame->tailsUnlocked) {
                             PlaySfxByName("Menu Move", false);
-                            if (--self->playerID > SAVESEL_SONIC)
+                            if (--self->playerID > 0)
                                 self->playerID = SAVESEL_TAILS;
                         }
                     }
-                    else if (keyPress.right) {
+                    else if (inputPress.right) {
                         if (saveGame->knuxUnlocked) {
                             PlaySfxByName("Menu Move", false);
 
@@ -106,12 +106,12 @@ void PlayerSelectScreen_Main(void *objPtr)
                             self->playerID = SAVESEL_SONIC;
                         }
                     }
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         PlaySfxByName("Menu Select", false);
                         StopMusic(true);
                         self->state = PLAYERSELECTSCREEN_STATE_ACTION;
                     }
-                    else if (keyPress.B) {
+                    else if (inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = PLAYERSELECTSCREEN_STATE_EXIT;
@@ -153,7 +153,7 @@ void PlayerSelectScreen_Main(void *objPtr)
                         }
                     }
                     self->backPressed = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
-                    if (self->state == PLAYERSELECTSCREEN_STATE_MAIN && (keyDown.left || keyDown.right)) {
+                    if (self->state == PLAYERSELECTSCREEN_STATE_MAIN && (inputDown.left || inputDown.right)) {
                         usePhysicalControls = true;
                         self->playerID      = SAVESEL_SONIC;
                     }
@@ -164,12 +164,12 @@ void PlayerSelectScreen_Main(void *objPtr)
                         StopMusic(true);
                         self->state = PLAYERSELECTSCREEN_STATE_ACTION;
                     }
-                    if (self->backPressed || keyPress.B) {
+                    if (self->backPressed || inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = PLAYERSELECTSCREEN_STATE_EXIT;
                     }
-                    else if (self->state == PLAYERSELECTSCREEN_STATE_MAIN && (keyDown.left || keyDown.right)) {
+                    else if (self->state == PLAYERSELECTSCREEN_STATE_MAIN && (inputDown.left || inputDown.right)) {
                         usePhysicalControls = true;
                         self->playerID      = SAVESEL_SONIC;
                     }
@@ -177,7 +177,7 @@ void PlayerSelectScreen_Main(void *objPtr)
             }
             break;
 
-        case PLAYERSELECTSCREEN_STATE_ACTION:
+        case 2:
             SetRenderMatrix(&self->matrixTemp);
 
             self->timer2 += Engine.deltaTime;
@@ -226,14 +226,13 @@ void PlayerSelectScreen_Main(void *objPtr)
                 SetGlobalVariableByName("starPostID", 0);
                 debugMode = false;
 
-                int charID = 0;
                 switch (self->playerID) {
-                    case SAVESEL_SONIC: charID = 0; break;
-                    case SAVESEL_TAILS: charID = 1; break;
-                    case SAVESEL_KNUX: charID = 2; break;
-                    case SAVESEL_ST: charID = 3; break;
+                    case SAVESEL_SONIC: saveGame->files[saveSel->selectedButton - 1].characterID = 0; break;
+                    case SAVESEL_TAILS: saveGame->files[saveSel->selectedButton - 1].characterID = 1; break;
+                    case SAVESEL_KNUX: saveGame->files[saveSel->selectedButton - 1].characterID = 2; break;
+                    case SAVESEL_ST: saveGame->files[saveSel->selectedButton - 1].characterID = 3; break;
                 }
-                InitStartingStage(STAGELIST_PRESENTATION, 0, charID);
+                InitStartingStage(STAGELIST_PRESENTATION, 0, saveGame->files[saveSel->selectedButton - 1].characterID);
 
                 CREATE_ENTITY(FadeScreen);
             }
diff --git a/RSDKv4/NativeObjects/RecordsScreen.cpp b/RSDKv4/NativeObjects/RecordsScreen.cpp
index 629a60b..568309a 100644
--- a/RSDKv4/NativeObjects/RecordsScreen.cpp
+++ b/RSDKv4/NativeObjects/RecordsScreen.cpp
@@ -1,7 +1,9 @@
 #include "RetroEngine.hpp"
 
-float timeAttackU[] = { 1.0, 321.0, 641.0, 1.0, 321.0, 641.0, 641.0 };
-float timeAttackV[] = { 1.0, 1.0, 1.0, 241.0, 241.0, 241.0, 721.0 };
+float timeAttackU[] = {
+    1.0, 321.0, 641.0, 1.0, 321.0, 641.0,
+};
+float timeAttackV[] = { 1.0, 1.0, 1.0, 241.0, 241.0, 241.0 };
 
 void RecordsScreen_Create(void *objPtr)
 {
@@ -93,9 +95,7 @@ void RecordsScreen_Main(void *objPtr)
                         case 8: self->recordOffset = (timeAttack_ActCount * 8) + 1; break;
                         case 9: self->recordOffset = 22; break;
                         case 10: self->recordOffset = 20; break;
-#if !RETRO_USE_ORIGINAL_CODE
                         case 11: self->recordOffset = 23; break;
-#endif
                     }
                 }
             }
@@ -105,9 +105,7 @@ void RecordsScreen_Main(void *objPtr)
                 switch (self->zoneID) {
                     default: break;
                     case 9:
-#if !RETRO_USE_ORIGINAL_CODE
                     case 11:
-#endif
                         self->timeAttackU = timeAttackU[0];
                         self->timeAttackV = timeAttackV[0];
                         break;
@@ -117,19 +115,6 @@ void RecordsScreen_Main(void *objPtr)
                         break;
                 }
             }
-            else if (Engine.gameType == GAME_SONIC1 && self->zoneID >= 6) {
-                switch (self->zoneID) {
-                    default: break;
-                    case 6: // dumber stupider dumber
-                        self->timeAttackU = timeAttackU[6];
-                        self->timeAttackV = timeAttackV[6];
-                        break;
-                    case 7:
-                        self->timeAttackU = timeAttackU[(self->recordOffset - 1) % 6];
-                        self->timeAttackV = timeAttackV[(self->recordOffset - 1) % 6];
-                        break;
-                }
-            }
             else {
                 self->timeAttackU = timeAttackU[self->recordOffset % 6];
                 self->timeAttackV = timeAttackV[self->recordOffset % 6];
@@ -140,7 +125,7 @@ void RecordsScreen_Main(void *objPtr)
                 switch (self->zoneID) {
                     default: pos = timeAttack_ActCount * self->zoneID; break;
                     case 7: // special stage
-                        pos = timeAttack_ActCount * 6;
+                        pos = 6 * self->zoneID;
                         pos++;
                         break;
                 }
@@ -194,8 +179,8 @@ void RecordsScreen_Main(void *objPtr)
         }
 
         case RECORDSSCREEN_STATE_MAIN: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->matrixTemp);
             if (!usePhysicalControls) {
                 if (touches <= 0) {
@@ -285,16 +270,16 @@ void RecordsScreen_Main(void *objPtr)
                 }
 
                 if (self->state == RECORDSSCREEN_STATE_MAIN) {
-                    if (keyDown.left) {
+                    if (inputDown.left) {
                         self->selectedButton = RECORDSSCREEN_BUTTON_NEXTACT;
                         usePhysicalControls  = true;
                     }
                     else {
-                        if (keyDown.right) {
+                        if (inputDown.right) {
                             self->selectedButton = RECORDSSCREEN_BUTTON_PLAY;
                             usePhysicalControls  = true;
                         }
-                        else if (keyPress.B) {
+                        else if (inputPress.B) {
                             PlaySfxByName("Menu Back", false);
                             self->backPressed = false;
                             self->state       = RECORDSSCREEN_STATE_EXIT;
@@ -312,7 +297,7 @@ void RecordsScreen_Main(void *objPtr)
                     self->backPressed    = false;
 
                     if (self->actCount > 1) {
-                        if (keyPress.left) {
+                        if (inputPress.left) {
                             PlaySfxByName("Menu Move", false);
                             self->selectedButton--;
                             if (self->selectedButton < 0) {
@@ -324,7 +309,7 @@ void RecordsScreen_Main(void *objPtr)
                                 self->flipRight = true;
                             }
                         }
-                        else if (keyPress.right) {
+                        else if (inputPress.right) {
                             PlaySfxByName("Menu Move", false);
                             self->selectedButton++;
                             if (self->selectedButton >= 2) {
@@ -342,7 +327,7 @@ void RecordsScreen_Main(void *objPtr)
                         self->buttons[self->selectedButton]->state = PUSHBUTTON_STATE_SELECTED;
                     }
 
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         if (self->selectedButton) {
                             PlaySfxByName("Menu Move", false);
                             self->state     = RECORDSSCREEN_STATE_FLIP;
@@ -355,7 +340,7 @@ void RecordsScreen_Main(void *objPtr)
                             self->buttons[RECORDSSCREEN_BUTTON_PLAY]->state = PUSHBUTTON_STATE_FLASHING;
                         }
                     }
-                    else if (keyPress.B) {
+                    else if (inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = RECORDSSCREEN_STATE_EXIT;
@@ -371,7 +356,7 @@ void RecordsScreen_Main(void *objPtr)
                 switch (self->zoneID) {
                     default: pos += timeAttack_ActCount * self->zoneID; break;
                     case 7: // special stage
-                        pos += timeAttack_ActCount * 6;
+                        pos += 6 * self->zoneID;
                         pos++;
                         break;
                 }
@@ -379,7 +364,7 @@ void RecordsScreen_Main(void *objPtr)
             else {
                 if (self->zoneID >= 8) {
                     pos += timeAttack_ActCount * 8;
-                    ++pos; // metropolis moment
+                    ++pos;
                     pos += self->zoneID - 8;
                 }
                 else {
@@ -403,9 +388,7 @@ void RecordsScreen_Main(void *objPtr)
                     switch (self->zoneID) {
                         default: break;
                         case 9:
-#if !RETRO_USE_ORIGINAL_CODE
                         case 11:
-#endif
                             self->timeAttackU = timeAttackU[0];
                             self->timeAttackV = timeAttackV[0];
                             break;
@@ -415,19 +398,6 @@ void RecordsScreen_Main(void *objPtr)
                             break;
                     }
                 }
-                else if (Engine.gameType == GAME_SONIC1 && self->zoneID >= 6) {
-                    switch (self->zoneID) {
-                        default: break;
-                        case 6: // dumber stupider dumber
-                            self->timeAttackU = timeAttackU[6];
-                            self->timeAttackV = timeAttackV[6];
-                            break;
-                        case 7:
-                            self->timeAttackU = timeAttackU[(self->recordOffset + self->actID - 1) % 6];
-                            self->timeAttackV = timeAttackV[(self->recordOffset + self->actID - 1) % 6];
-                            break;
-                    }
-                }
                 else {
                     self->timeAttackU = timeAttackU[(self->recordOffset + self->actID) % 6];
                     self->timeAttackV = timeAttackV[(self->recordOffset + self->actID) % 6];
@@ -516,14 +486,8 @@ void RecordsScreen_Main(void *objPtr)
                 SetGlobalVariableByName("specialStage.listPos", 0);
                 SetGlobalVariableByName("specialStage.emeralds", 0);
                 SetGlobalVariableByName("specialStage.nextZone", 0);
-                SetGlobalVariableByName("specialStage.nextZone", 0); // We gotta make extra sure it's reset, I guess
-#if !RETRO_USE_ORIGINAL_CODE
+                SetGlobalVariableByName("specialStage.nextZone", 0);
                 SetGlobalVariableByName("lampPostID", 0);
-#endif
-                // Bug Details:
-                // Despite using the variable "lampPostID" for checkpoints, Sonic 1 still tries to set "starPostID", which only exists in Sonic 2
-                // As a result, the checkpoint variable doesn't get reset in Sonic 1, allowing you to start an act further into the level if exploited
-                // (This is fixed in the decomp with the above line)
                 SetGlobalVariableByName("starPostID", 0);
                 SetGlobalVariableByName("timeAttack.result", 0);
 
@@ -534,22 +498,13 @@ void RecordsScreen_Main(void *objPtr)
                         default: break;
                         case 9: InitStartingStage(STAGELIST_BONUS, 1, 0); break;
                         case 10: InitStartingStage(STAGELIST_REGULAR, self->zoneID * timeAttack_ActCount, 0); break;
-#if !RETRO_USE_ORIGINAL_CODE
                         case 11: InitStartingStage(STAGELIST_BONUS, 0, 0); break;
-#endif
                     }
                 }
-#if !RETRO_USE_ORIGINAL_CODE
-                // There's a bit of a bug in the code that makes Wing Fortress go to Metropolis 3, even though the records save perfectly fine.
-                // So, if you are in Sonic 2 and the zone selected is Wing Fortress, load Stage 18 (this is always Wing Fortress under normal circumstances).
-                else if (Engine.gameType == GAME_SONIC2 && self->zoneID == 8)
-                    InitStartingStage(STAGELIST_REGULAR, 18, 0);
-#endif
                 else
                     InitStartingStage(STAGELIST_REGULAR, self->zoneID * timeAttack_ActCount + self->actID, 0);
 
                 self->state      = RECORDSSCREEN_STATE_SHOWRESULTS;
-                self->flashTimer = 0.0;
                 self->taResultID = GetGlobalVariableID("timeAttack.result");
                 BackupNativeObjects();
                 CREATE_ENTITY(FadeScreen);
@@ -562,7 +517,7 @@ void RecordsScreen_Main(void *objPtr)
                 switch (self->zoneID) {
                     default: pos += timeAttack_ActCount * self->zoneID; break;
                     case 7: // special stage
-                        pos += timeAttack_ActCount * 6;
+                        pos += 6 * self->zoneID;
                         pos++;
                         break;
                 }
@@ -588,26 +543,24 @@ void RecordsScreen_Main(void *objPtr)
 
                 for (int r = 0; r < 3; ++r) {
                     if (time < records[r]) {
-                        for (int s = 2; s > r; --s) records[s] = records[s - 1];
+                        for (int s = r + 1; s < 3; ++s) records[s + 1] = records[s];
                         records[r] = time;
                         self->rank = r + 1;
                         break;
                     }
                 }
 
-                if (self->rank) {
-                    SetStringToFont8(self->rank1st, "1.", FONT_LABEL);
-                    AddTimeStringToFont(self->rank1st, records[0], FONT_LABEL);
-                    SetStringToFont8(self->rank2nd, "2.", FONT_LABEL);
-                    AddTimeStringToFont(self->rank2nd, records[1], FONT_LABEL);
-                    SetStringToFont8(self->rank3rd, "3.", FONT_LABEL);
-                    AddTimeStringToFont(self->rank3rd, records[2], FONT_LABEL);
-
-                    self->timer = 0.0;
-                    self->state = RECORDSSCREEN_STATE_EXITRESULTS;
-                    PlaySfxByName("Event", false);
-                    WriteSaveRAMData();
-                }
+                SetStringToFont8(self->rank1st, "1.", FONT_LABEL);
+                AddTimeStringToFont(self->rank1st, records[0], FONT_LABEL);
+                SetStringToFont8(self->rank2nd, "2.", FONT_LABEL);
+                AddTimeStringToFont(self->rank2nd, records[1], FONT_LABEL);
+                SetStringToFont8(self->rank3rd, "3.", FONT_LABEL);
+                AddTimeStringToFont(self->rank3rd, records[2], FONT_LABEL);
+
+                self->timer = 0.0;
+                self->state = RECORDSSCREEN_STATE_EXITRESULTS;
+                PlaySfxByName("Event", false);
+                WriteSaveRAMData();
 
                 int pos = 0;
                 for (int i = 0; i < timeAttack_ZoneCount; ++i) {
@@ -665,12 +618,7 @@ void RecordsScreen_Main(void *objPtr)
                     }
                     else {
                         if (z < 9) {
-#if !RETRO_USE_ORIGINAL_CODE
-                            if (z < 11)
-                                for (int a = 0; a < timeAttack_ActCount; ++a) timeAttack->totalTime += saveGame->records[3 * (pos + a)];
-#else
                             for (int a = 0; a < timeAttack_ActCount; ++a) timeAttack->totalTime += saveGame->records[3 * (pos + a)];
-#endif
                             pos += timeAttack_ActCount;
                         }
                         else {
diff --git a/RSDKv4/NativeObjects/RetroGameLoop.cpp b/RSDKv4/NativeObjects/RetroGameLoop.cpp
index fd6d4fe..74585a1 100644
--- a/RSDKv4/NativeObjects/RetroGameLoop.cpp
+++ b/RSDKv4/NativeObjects/RetroGameLoop.cpp
@@ -68,42 +68,22 @@ void RetroGameLoop_Main(void *objPtr)
         case ENGINE_ENDGAME:
             ClearScreen(1);
             TransferRetroBuffer();
-#if !RETRO_USE_ORIGINAL_CODE
-            if (skipStartMenu) {
-                activeStageList   = 0;
-                stageListPosition = 0;
-                stageMode         = STAGEMODE_LOAD;
-                Engine.gameMode   = ENGINE_MAINGAME;
-            }
-            else {
-                RestoreNativeObjects();
-                Engine.LoadGameConfig("Data/Game/GameConfig.bin");
-                activeStageList   = 0;
-                stageListPosition = 0;
-            }
-#else
             RestoreNativeObjects();
             Engine.LoadGameConfig("Data/Game/GameConfig.bin");
             activeStageList   = 0;
             stageListPosition = 0;
-#endif
             break;
 
         case ENGINE_RESETGAME: // Also called when 2P VS disconnects
             ClearScreen(1);
             TransferRetroBuffer();
-#if !RETRO_USE_ORIGINAL_CODE
-            if (skipStartMenu) {
-                activeStageList   = 0;
-                stageListPosition = 0;
-                stageMode         = STAGEMODE_LOAD;
-                Engine.gameMode   = ENGINE_MAINGAME;
-            }
-            else
-                RestoreNativeObjects();
-#else
             RestoreNativeObjects();
-#endif
+            break;
+
+        case ENGINE_VIDEOWAIT:
+            if (ProcessVideo() == 1) {
+                Engine.gameMode = ENGINE_MAINGAME;
+            }
             break;
 
 #if !RETRO_USE_ORIGINAL_CODE && RETRO_USE_NETWORKING
diff --git a/RSDKv4/NativeObjects/SaveSelect.cpp b/RSDKv4/NativeObjects/SaveSelect.cpp
index 91109a7..682ed11 100644
--- a/RSDKv4/NativeObjects/SaveSelect.cpp
+++ b/RSDKv4/NativeObjects/SaveSelect.cpp
@@ -116,8 +116,8 @@ void SaveSelect_Main(void *objPtr)
             if (self->timer > 1.0) {
                 self->timer      = 0.0;
                 self->state      = SAVESELECT_STATE_MAIN;
-                keyPress.start = false;
-                keyPress.A     = false;
+                inputPress.start = false;
+                inputPress.A     = false;
             }
             break;
         }
@@ -135,7 +135,7 @@ void SaveSelect_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton--;
                         if (self->deleteEnabled && self->selectedButton < SAVESELECT_BUTTON_NOSAVE) {
@@ -145,7 +145,7 @@ void SaveSelect_Main(void *objPtr)
                             self->selectedButton = SAVESELECT_BUTTON_COUNT - 1;
                         }
                     }
-                    else if (keyPress.down) {
+                    else if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->selectedButton++;
                         if (self->deleteEnabled && self->selectedButton > SAVESELECT_BUTTON_COUNT) {
@@ -158,7 +158,7 @@ void SaveSelect_Main(void *objPtr)
 
                     for (int i = 0; i < SAVESELECT_BUTTON_COUNT; ++i) self->saveButtons[i]->b = 0xFF;
 
-                    if (self->deleteEnabled && (keyPress.left || keyPress.right)) {
+                    if (self->deleteEnabled && (inputPress.left || inputPress.right)) {
                         if (self->selectedButton < SAVESELECT_BUTTON_COUNT) {
                             self->selectedButton   = SAVESELECT_BUTTON_COUNT;
                             self->delButton->state = PUSHBUTTON_STATE_SELECTED;
@@ -179,7 +179,7 @@ void SaveSelect_Main(void *objPtr)
                         }
                     }
 
-                    if (keyPress.start || keyPress.A) {
+                    if (inputPress.start || inputPress.A) {
                         if (self->selectedButton < SAVESELECT_BUTTON_COUNT) {
                             if (self->state == SAVESELECT_STATE_MAIN_DELETING) {
                                 if (self->selectedButton > SAVESELECT_BUTTON_NOSAVE && saveGame->files[self->selectedButton - 1].stageID > 0) {
@@ -258,7 +258,7 @@ void SaveSelect_Main(void *objPtr)
 
                 if (self->state == SAVESELECT_STATE_MAIN) {
                     if (!self->deleteEnabled) {
-                        if (keyDown.up || keyDown.down || keyDown.left || keyDown.right) {
+                        if (inputDown.up || inputDown.down || inputDown.left || inputDown.right) {
                             self->selectedButton = SAVESELECT_BUTTON_NOSAVE;
                             usePhysicalControls  = true;
                         }
@@ -275,7 +275,7 @@ void SaveSelect_Main(void *objPtr)
                                 self->state            = SAVESELECT_STATE_LOADSAVE;
                             }
                             else {
-                                if (keyDown.up || keyDown.down || keyDown.left || keyDown.right) {
+                                if (inputDown.up || inputDown.down || inputDown.left || inputDown.right) {
                                     self->selectedButton = SAVESELECT_BUTTON_NOSAVE;
                                     usePhysicalControls  = true;
                                 }
@@ -286,7 +286,7 @@ void SaveSelect_Main(void *objPtr)
                                                                     (64.0 * self->delButton->scale) + self->delButton->textWidth, 12.0)
                                                      >= 0;
                             if (self->state == SAVESELECT_STATE_MAIN) {
-                                if (keyDown.up || keyDown.down || keyDown.left || keyDown.right) {
+                                if (inputDown.up || inputDown.down || inputDown.left || inputDown.right) {
                                     self->selectedButton = SAVESELECT_BUTTON_NOSAVE;
                                     usePhysicalControls  = true;
                                 }
diff --git a/RSDKv4/NativeObjects/SettingsScreen.cpp b/RSDKv4/NativeObjects/SettingsScreen.cpp
index b16c7e4..c8313ad 100644
--- a/RSDKv4/NativeObjects/SettingsScreen.cpp
+++ b/RSDKv4/NativeObjects/SettingsScreen.cpp
@@ -166,12 +166,12 @@ void SettingsScreen_Main(void *objPtr)
             }
             break;
         case SETTINGSSCREEN_STATE_MAIN:
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->tempMatrix);
             if (usePhysicalControls) {
                 if (touches <= 0) {
-                    if (keyPress.up) {
+                    if (inputPress.up) {
                         PlaySfxByName("Menu Move", false);
                         self->selected--;
                         if ((Engine.gameType != GAME_SONIC1 || self->isPauseMenu) && self->selected == SETTINGSSCREEN_SEL_SPINDASH)
@@ -179,7 +179,7 @@ void SettingsScreen_Main(void *objPtr)
                         if (self->selected <= SETTINGSSCREEN_SEL_NONE)
                             self->selected = SETTINGSSCREEN_SEL_CONTROLS;
                     }
-                    if (keyPress.down) {
+                    if (inputPress.down) {
                         PlaySfxByName("Menu Move", false);
                         self->selected++;
                         if ((Engine.gameType != GAME_SONIC1 || self->isPauseMenu) && self->selected == SETTINGSSCREEN_SEL_SPINDASH)
@@ -191,9 +191,9 @@ void SettingsScreen_Main(void *objPtr)
 
                     switch (self->selected) {
                         case SETTINGSSCREEN_SEL_MUSVOL:
-                            self->buttons[SETTINGSSCREEN_BTN_MUSUP]->state   = keyDown.left == true;
-                            self->buttons[SETTINGSSCREEN_BTN_MUSDOWN]->state = keyDown.right == true;
-                            if (keyPress.left) {
+                            self->buttons[SETTINGSSCREEN_BTN_MUSUP]->state   = inputDown.left == true;
+                            self->buttons[SETTINGSSCREEN_BTN_MUSDOWN]->state = inputDown.right == true;
+                            if (inputPress.left) {
                                 PlaySfxByName("Menu Move", false);
                                 if (saveGame->musVolume > 0)
                                     saveGame->musVolume -= (MAX_VOLUME / 5);
@@ -201,7 +201,7 @@ void SettingsScreen_Main(void *objPtr)
                                 if (!saveGame->musVolume)
                                     musicEnabled = false;
                             }
-                            else if (keyPress.right) {
+                            else if (inputPress.right) {
                                 PlaySfxByName("Menu Move", false);
                                 if (saveGame->musVolume < MAX_VOLUME)
                                     saveGame->musVolume += (MAX_VOLUME / 5);
@@ -214,15 +214,15 @@ void SettingsScreen_Main(void *objPtr)
                             }
                             break;
                         case SETTINGSSCREEN_SEL_SFXVOL:
-                            self->buttons[SETTINGSSCREEN_BTN_SFXUP]->state   = keyDown.left == true;
-                            self->buttons[SETTINGSSCREEN_BTN_SFXDOWN]->state = keyDown.right == true;
-                            if (keyPress.left) {
+                            self->buttons[SETTINGSSCREEN_BTN_SFXUP]->state   = inputDown.left == true;
+                            self->buttons[SETTINGSSCREEN_BTN_SFXDOWN]->state = inputDown.right == true;
+                            if (inputPress.left) {
                                 PlaySfxByName("Menu Move", false);
                                 if (saveGame->sfxVolume > 0)
                                     saveGame->sfxVolume -= (MAX_VOLUME / 5);
                                 SetGameVolumes(saveGame->musVolume, saveGame->sfxVolume);
                             }
-                            else if (keyPress.right) {
+                            else if (inputPress.right) {
                                 PlaySfxByName("Menu Move", false);
                                 if (saveGame->sfxVolume < MAX_VOLUME)
                                     saveGame->sfxVolume += (MAX_VOLUME / 5);
@@ -234,7 +234,7 @@ void SettingsScreen_Main(void *objPtr)
                                 self->buttons[SETTINGSSCREEN_BTN_SDON]->state = PUSHBUTTON_STATE_SELECTED;
                             else
                                 self->buttons[SETTINGSSCREEN_BTN_SDOFF]->state = PUSHBUTTON_STATE_SELECTED;
-                            if (keyPress.left || keyPress.right) {
+                            if (inputPress.left || inputPress.right) {
                                 PlaySfxByName("Menu Move", false);
                                 if (saveGame->spindashEnabled) {
                                     self->buttons[SETTINGSSCREEN_BTN_SDON]->state            = PUSHBUTTON_STATE_UNSELECTED;
@@ -257,8 +257,8 @@ void SettingsScreen_Main(void *objPtr)
                             }
                             break;
                         case SETTINGSSCREEN_SEL_REGION:
-                            if (keyPress.left || keyPress.right) {
-                                if (keyPress.left) {
+                            if (inputPress.left || inputPress.right) {
+                                if (inputPress.left) {
                                     PlaySfxByName("Menu Move", false);
                                     if (saveGame->boxRegion - 1 >= 0)
                                         saveGame->boxRegion--;
@@ -282,7 +282,7 @@ void SettingsScreen_Main(void *objPtr)
                             break;
                         case SETTINGSSCREEN_SEL_CONTROLS:
                             self->buttons[SETTINGSSCREEN_BTN_CTRLS]->state = PUSHBUTTON_STATE_SELECTED;
-                            if (keyPress.start || keyPress.A) {
+                            if (inputPress.start || inputPress.A) {
                                 PlaySfxByName("Menu Select", false);
                                 self->buttons[SETTINGSSCREEN_BTN_CTRLS]->state = PUSHBUTTON_STATE_FLASHING;
                                 self->state                                    = SETTINGSSCREEN_STATE_ENTERCTRLS;
@@ -290,7 +290,7 @@ void SettingsScreen_Main(void *objPtr)
                             break;
                         default: break;
                     }
-                    if (self->state == SETTINGSSCREEN_STATE_MAIN && keyPress.B) {
+                    if (self->state == SETTINGSSCREEN_STATE_MAIN && inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = SETTINGSSCREEN_STATE_EXIT;
@@ -409,17 +409,17 @@ void SettingsScreen_Main(void *objPtr)
                         self->buttons[SETTINGSSCREEN_BTN_CTRLS]->state = PUSHBUTTON_STATE_FLASHING;
                         self->state                                    = SETTINGSSCREEN_STATE_ENTERCTRLS;
                     }
-                    if (self->backPressed || keyPress.B) {
+                    if (self->backPressed || inputPress.B) {
                         PlaySfxByName("Menu Back", false);
                         self->backPressed = false;
                         self->state       = SETTINGSSCREEN_STATE_EXIT;
                     }
                     else if (self->state == SETTINGSSCREEN_STATE_MAIN) {
-                        if (keyDown.up) {
+                        if (inputDown.up) {
                             self->selected      = SETTINGSSCREEN_SEL_CONTROLS;
                             usePhysicalControls = true;
                         }
-                        else if (keyDown.down) {
+                        else if (inputDown.down) {
                             self->selected      = SETTINGSSCREEN_SEL_MUSVOL;
                             usePhysicalControls = true;
                         }
@@ -520,8 +520,8 @@ void SettingsScreen_Main(void *objPtr)
             for (int l = 0; l < SETTINGSSCREEN_BTN_COUNT; ++l) self->buttons[l]->renderMatrix = self->buttonMatrix;
             break;
         case SETTINGSSCREEN_STATE_CTRLS_TOUCH:
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->tempMatrix);
 
             if (touches > 0) {
@@ -686,7 +686,7 @@ void SettingsScreen_Main(void *objPtr)
                 }
             }
 
-            if (self->state == SETTINGSSCREEN_STATE_CTRLS_TOUCH && keyPress.B) {
+            if (self->state == SETTINGSSCREEN_STATE_CTRLS_TOUCH && inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->backPressed = false;
                 self->state       = SETTINGSSCREEN_STATE_FLIP_CTRLSTOUCH;
@@ -801,8 +801,8 @@ void SettingsScreen_Main(void *objPtr)
             for (int l = 0; l < SETTINGSSCREEN_BTN_COUNT; ++l) self->buttons[l]->renderMatrix = self->buttonMatrix;
             break;
         case SETTINGSSCREEN_STATE_CTRLS:
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->tempMatrix);
             if (touches <= 0) {
                 if (self->backPressed) {
@@ -815,7 +815,7 @@ void SettingsScreen_Main(void *objPtr)
             else {
                 self->backPressed = CheckTouchRect(136.0, 88.0, 32.0, 16.0) >= 0;
             }
-            if (keyPress.B) {
+            if (inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->backPressed = false;
                 self->state       = SETTINGSSCREEN_STATE_FLIP_CTRLS;
diff --git a/RSDKv4/NativeObjects/StaffCredits.cpp b/RSDKv4/NativeObjects/StaffCredits.cpp
index b59a56c..f56d9fb 100644
--- a/RSDKv4/NativeObjects/StaffCredits.cpp
+++ b/RSDKv4/NativeObjects/StaffCredits.cpp
@@ -87,8 +87,8 @@ void StaffCredits_Main(void *objPtr)
             }
             break;
         case STAFFCREDITS_STATE_SCROLL:
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderMatrix(&self->renderMatrix);
             if (touches <= 0) {
                 if (self->useRenderMatrix) {
@@ -100,7 +100,7 @@ void StaffCredits_Main(void *objPtr)
             else {
                 self->useRenderMatrix = CheckTouchRect(128.0, -92.0, 32.0, 32.0) >= 0;
             }
-            if (keyPress.B) {
+            if (inputPress.B) {
                 PlaySfxByName("Menu Back", false);
                 self->useRenderMatrix = false;
                 self->state           = STAFFCREDITS_STATE_EXIT;
@@ -141,7 +141,7 @@ void StaffCredits_Main(void *objPtr)
         NativeEntity_CreditText *creditText = self->creditText[i];
 
         creditText->textY += 0.75;
-        if (touches > 0 || keyDown.A || keyDown.C) {
+        if (touches > 0 || inputDown.A || inputDown.C) {
             creditText->textY += 0.75;
         }
 
diff --git a/RSDKv4/NativeObjects/TimeAttack.cpp b/RSDKv4/NativeObjects/TimeAttack.cpp
index 3d4bd51..4851ec9 100644
--- a/RSDKv4/NativeObjects/TimeAttack.cpp
+++ b/RSDKv4/NativeObjects/TimeAttack.cpp
@@ -2,9 +2,8 @@
 
 byte timeAttackTex;
 
-int timeAttack_ZoneCount   = 11;
-int timeAttack_ActCount    = 2;
-int timeAttack_ExZoneCount = 2;
+int timeAttack_ZoneCount = 12;
+int timeAttack_ActCount  = 2;
 
 void TimeAttack_Create(void *objPtr)
 {
@@ -15,28 +14,18 @@ void TimeAttack_Create(void *objPtr)
 
     int actCount = 0;
     if (Engine.gameType == GAME_SONIC1) {
-        timeAttack_ZoneCount   = 6;
-        timeAttack_ActCount    = 3;
-        timeAttack_ExZoneCount = 2;
-        // GHZ-SBZ + FZ
-        actCount = (timeAttack_ZoneCount * timeAttack_ActCount) + 1;
+        timeAttack_ZoneCount = 8;
+        timeAttack_ActCount  = 3;
+        // GHZ-SBZ + FZ & 6 SS
+        actCount = (timeAttack_ZoneCount * timeAttack_ActCount) + 7;
     }
     else {
-        timeAttack_ZoneCount = 11;
-#if !RETRO_USE_ORIGINAL_CODE
-        FileInfo info;
-        if (LoadFile("Data/Stages/ZoneM/StageConfig.bin", &info)) {
-            timeAttack_ZoneCount++;
-            CloseFile();
-        }
-#endif
-        timeAttack_ActCount    = 2;
-        timeAttack_ExZoneCount = 0;
-        actCount               = timeAttack_ZoneCount * timeAttack_ActCount;
+        timeAttack_ZoneCount = 12;
+        timeAttack_ActCount  = 2;
+        actCount             = timeAttack_ZoneCount * timeAttack_ActCount;
     }
 
     bool saveRAMUpdated = false;
-    // Regular Stages
     for (int i = 0; i < actCount * 3; i += 3) {
         // 1st
         if (!saveGame->records[i]) {
@@ -56,33 +45,6 @@ void TimeAttack_Create(void *objPtr)
             saveRAMUpdated           = true;
         }
     }
-
-    // Special Stages (S1 Only)
-    if (Engine.gameType == GAME_SONIC1) {
-        int offset            = actCount * 3;
-
-        int specialStageCount = 6;
-        for (int i = 0; i < specialStageCount * 3; i += 3) {
-            // 1st
-            if (!saveGame->records[offset + i]) {
-                saveGame->records[offset + i] = 30000;
-                saveRAMUpdated       = true;
-            }
-
-            // 2nd
-            if (!saveGame->records[offset + i + 1]) {
-                saveGame->records[offset + i + 1] = 30000;
-                saveRAMUpdated           = true;
-            }
-
-            // 3rd
-            if (!saveGame->records[offset + i + 2]) {
-                saveGame->records[offset + i + 2] = 30000;
-                saveRAMUpdated           = true;
-            }
-        }
-    }
-
     if (saveRAMUpdated)
         WriteSaveRAMData();
 
@@ -96,9 +58,20 @@ void TimeAttack_Create(void *objPtr)
 
         self->totalTime = 0;
         if (Engine.gameType == GAME_SONIC1) {
-            // Regular Stages (GHZ-SBZ)
-            for (int a = 0; a < timeAttack_ActCount; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
-            pos += timeAttack_ActCount;
+            switch (z) {
+                default:
+                    for (int a = 0; a < timeAttack_ActCount; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
+                    pos += timeAttack_ActCount;
+                    break;
+                case 6: // final zone
+                    self->totalTime += saveGame->records[3 * pos];
+                    pos++;
+                    break;
+                case 7: // special stage
+                    for (int a = 0; a < 6; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
+                    pos += 6;
+                    break;
+            }
         }
         else {
             if (z == 7) { // metropolis
@@ -124,48 +97,24 @@ void TimeAttack_Create(void *objPtr)
             x += 144.0;
     }
 
-    if (Engine.gameType == GAME_SONIC1) {
-        // final zone
-        int z                               = 6;
-        NativeEntity_ZoneButton *zoneButton = CREATE_ENTITY(ZoneButton);
-        self->zoneButtons[z]                = zoneButton;
-        zoneButton->x                       = x;
-        SetStringToFont(zoneButton->zoneText, strStageList[z], FONT_TEXT);
-
-        self->totalTime = 0;
-        self->totalTime += saveGame->records[3 * pos];
-        pos++;
-        SetStringToFont8(self->zoneButtons[z]->timeText, "", FONT_TEXT);
-        AddTimeStringToFont(self->zoneButtons[z]->timeText, self->totalTime, FONT_TEXT);
-        self->zoneButtons[z]->textWidth = GetTextWidth(self->zoneButtons[z]->zoneText, FONT_TEXT, 0.25) * 0.5;
-
-        if (!((z + 1) % 3))
-            x += 432.0;
-        else
-            x += 144.0;
-
-        // special stages
-        z                = 7;
-        zoneButton           = CREATE_ENTITY(ZoneButton);
-        self->zoneButtons[z] = zoneButton;
-        zoneButton->x        = x;
-        SetStringToFont(zoneButton->zoneText, strStageList[z], FONT_TEXT);
-
-        self->totalTime = 0;
-        for (int a = 0; a < 6; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
-        pos += 6;
-        SetStringToFont8(self->zoneButtons[z]->timeText, "", FONT_TEXT);
-        AddTimeStringToFont(self->zoneButtons[z]->timeText, self->totalTime, FONT_TEXT);
-        self->zoneButtons[z]->textWidth = GetTextWidth(self->zoneButtons[z]->zoneText, FONT_TEXT, 0.25) * 0.5;
-    }
-
     self->totalTime = 0;
     pos             = 0;
     for (int z = 0; z < timeAttack_ZoneCount; ++z) {
         if (Engine.gameType == GAME_SONIC1) {
-            // Regular Stages (GHZ-SBZ)
-            for (int a = 0; a < timeAttack_ActCount; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
-            pos += timeAttack_ActCount;
+            switch (z) {
+                default:
+                    for (int a = 0; a < timeAttack_ActCount; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
+                    pos += timeAttack_ActCount;
+                    break;
+                case 6: // final zone
+                    self->totalTime += saveGame->records[3 * pos];
+                    pos++;
+                    break;
+                case 7: // special stage
+                    for (int a = 0; a < 6; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
+                    pos += 6;
+                    break;
+            }
         }
         else {
             if (z == 7) { // metropolis
@@ -183,16 +132,6 @@ void TimeAttack_Create(void *objPtr)
         }
     }
 
-    if (Engine.gameType == GAME_SONIC1) {
-        // final zone
-        self->totalTime += saveGame->records[3 * pos];
-        pos++;
-
-        // special stages
-        for (int a = 0; a < 6; ++a) self->totalTime += saveGame->records[3 * (pos + a)];
-        pos += 6;
-    }
-
     int zone = saveGame->unlockedActs;
     for (int i = 0; i < 4; ++i) {
         if (saveGame->files[i].stageID > zone)
@@ -216,9 +155,15 @@ void TimeAttack_Create(void *objPtr)
                 tx += 320.0f;
                 ty += 240.0f;
 
+                self->zoneButtons[i + 1]->texX = tx;
+                self->zoneButtons[i + 1]->texY = ty;
+
+                self->zoneButtons[i + 1]->unlocked = false;
+                if (zone > (timeAttack_ActCount * (i + 1)) + 1) {
+                    self->zoneButtons[i + 1]->unlocked = true;
+                }
+
                 ++i;
-                self->zoneButtons[i]->texX = tx;
-                self->zoneButtons[i]->texY = ty;
 
                 tx -= 320.0f;
                 tx -= 320.0f;
@@ -249,30 +194,14 @@ void TimeAttack_Create(void *objPtr)
                 }
             }
             else {
-                if (i == 11) // Boss Attack
+                if (i == 11)
                     self->zoneButtons[i]->unlocked = self->zoneButtons[i - 1]->unlocked;
-                if (i == 10) // HPZ
+                if (i == 10)
                     self->zoneButtons[i]->unlocked = saveGame->unlockedHPZ;
             }
         }
     }
 
-    if (Engine.gameType == GAME_SONIC1) {
-        // final zone
-        self->zoneButtons[6]->unlocked = false;
-        if (zone > timeAttack_ActCount * 6) { // if listPos == final zone OR complete
-            self->zoneButtons[6]->unlocked = true;
-        }
-
-        // special stages
-        self->zoneButtons[7]->texX     = tx;
-        self->zoneButtons[7]->texY     = ty;
-        self->zoneButtons[7]->unlocked = false;
-        if (zone > (timeAttack_ActCount * 6) + 1) { // if listPos == complete
-            self->zoneButtons[7]->unlocked = true;
-        }
-    }
-
     self->y             = -400.0;
     self->zoneButtonVel = -72.0;
     MatrixRotateXYZF(&self->matRender, 0.0, DegreesToRad(12.25), DegreesToRad(6.125));
@@ -343,15 +272,15 @@ void TimeAttack_Main(void *objPtr)
             if (self->timer > 1.0) {
                 self->timer      = 0.0;
                 self->state      = TIMEATTACK_STATE_MAIN;
-                keyPress.start = false;
-                keyPress.A     = false;
+                inputPress.start = false;
+                inputPress.A     = false;
             }
             break;
         }
 
         case TIMEATTACK_STATE_MAIN: {
             bool canPrev = 3 * (self->pageID - 1) >= 0;
-            bool canNext = 3 * (self->pageID + 1) < (timeAttack_ZoneCount + timeAttack_ExZoneCount);
+            bool canNext = 3 * (self->pageID + 1) < timeAttack_ZoneCount;
 
             if (!canNext) {
                 if (self->pagePrevAlpha < 0x100)
@@ -374,7 +303,7 @@ void TimeAttack_Main(void *objPtr)
 
             if (!usePhysicalControls) {
                 if (touches <= 0) {
-                    for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i) {
+                    for (int i = 0; i < timeAttack_ZoneCount; ++i) {
                         if (self->zoneButtons[i]->state == ZONEBUTTON_STATE_SELECTED) {
                             PlaySfxByName("Menu Select", false);
                             self->zoneButtons[i]->state = ZONEBUTTON_STATE_FLASHING;
@@ -402,8 +331,7 @@ void TimeAttack_Main(void *objPtr)
                     }
                 }
                 else {
-                    for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i)
-                        self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
+                    for (int i = 0; i < timeAttack_ZoneCount; ++i) self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
 
                     if (CheckTouchRectMatrix(&self->matrixTouch, 0.0, self->zoneButtons[0]->y + 16.0, 512.0, 40.0) >= 0) {
                         int offset = self->pageID * 3;
@@ -411,12 +339,12 @@ void TimeAttack_Main(void *objPtr)
                         if (self->zoneButtons[offset]->unlocked && CheckTouchRect(-78.0, 0.0, 48.0, 120.0) >= 0)
                             self->zoneButtons[offset]->state = ZONEBUTTON_STATE_SELECTED;
 
-                        if (offset + 1 < (timeAttack_ZoneCount + timeAttack_ExZoneCount)) {
+                        if (offset + 1 < timeAttack_ZoneCount) {
                             if (self->zoneButtons[offset + 1]->unlocked && CheckTouchRect(22.0, 0.0, 38.0, 120.0) >= 0)
                                 self->zoneButtons[offset + 1]->state = ZONEBUTTON_STATE_SELECTED;
                         }
 
-                        if (offset + 2 < (timeAttack_ZoneCount + timeAttack_ExZoneCount)) {
+                        if (offset + 2 < timeAttack_ZoneCount) {
                             if (self->zoneButtons[offset + 2]->unlocked && CheckTouchRect(100.0, 0.0, 30.0, 120.0) >= 0)
                                 self->zoneButtons[offset + 2]->state = ZONEBUTTON_STATE_SELECTED;
                         }
@@ -442,8 +370,7 @@ void TimeAttack_Main(void *objPtr)
                             self->zoneID           = (3 * self->pageID) + 2;
                             self->selectionEnabled = false;
 
-                            for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i)
-                                self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
+                            for (int i = 0; i < timeAttack_ZoneCount; ++i) self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
                         }
                         else if ((self->lastTouchX - touchXF[0]) > 16.0f && canNext) {
                             PlaySfxByName("Menu Move", false);
@@ -452,8 +379,7 @@ void TimeAttack_Main(void *objPtr)
                             self->zoneButtonVel    = -72.0f - (720.0f * self->pageID);
                             self->zoneID           = (3 * self->pageID);
                             self->selectionEnabled = false;
-                            for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i)
-                                self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
+                            for (int i = 0; i < timeAttack_ZoneCount; ++i) self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
                         }
                     }
                     else {
@@ -467,11 +393,11 @@ void TimeAttack_Main(void *objPtr)
                 }
 
                 if (self->state == TIMEATTACK_STATE_MAIN) {
-                    if (keyDown.left) {
+                    if (inputDown.left) {
                         usePhysicalControls = true;
                         self->zoneID        = (3 * self->pageID);
                     }
-                    if (keyDown.right) {
+                    if (inputDown.right) {
                         usePhysicalControls = true;
                         self->zoneID        = (3 * self->pageID) + 2;
                     }
@@ -482,7 +408,7 @@ void TimeAttack_Main(void *objPtr)
                     usePhysicalControls = false;
                 }
                 else {
-                    if (keyPress.left && self->zoneID > 0) {
+                    if (inputPress.left && self->zoneID > 0) {
                         PlaySfxByName("Menu Move", false);
                         self->zoneID--;
                         if (self->zoneID < (self->pageID * 3) && self->zoneID > 0) {
@@ -493,7 +419,7 @@ void TimeAttack_Main(void *objPtr)
                             self->zoneID        = (3 * self->pageID) + 2;
                         }
                     }
-                    else if (keyPress.right && self->zoneID < (timeAttack_ZoneCount + timeAttack_ExZoneCount) - 1) {
+                    else if (inputPress.right && self->zoneID < timeAttack_ZoneCount - 1) {
                         PlaySfxByName("Menu Move", false);
                         ++self->zoneID;
                         if (self->zoneID >= ((self->pageID + 1) * 3)) {
@@ -505,11 +431,10 @@ void TimeAttack_Main(void *objPtr)
                         }
                     }
 
-                    for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i)
-                        self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
+                    for (int i = 0; i < timeAttack_ZoneCount; ++i) self->zoneButtons[i]->state = ZONEBUTTON_STATE_UNSELECTED;
                     if (self->state == TIMEATTACK_STATE_MAIN) {
                         self->zoneButtons[self->zoneID]->state = ZONEBUTTON_STATE_SELECTED;
-                        if (self->zoneButtons[self->zoneID]->unlocked && (keyPress.start || keyPress.A)) {
+                        if (self->zoneButtons[self->zoneID]->unlocked && (inputPress.start || inputPress.A)) {
                             PlaySfxByName("Menu Select", false);
                             self->zoneButtons[self->zoneID]->state = ZONEBUTTON_STATE_FLASHING;
                             self->state                            = TIMEATTACK_STATE_ACTION;
@@ -538,7 +463,7 @@ void TimeAttack_Main(void *objPtr)
             }
 
             float x = self->zoneButtons[0]->x + 144.0;
-            for (int i = 1; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i) {
+            for (int i = 1; i < timeAttack_ZoneCount; ++i) {
                 self->zoneButtons[i]->x = x;
                 if (!((i + 1) % 3))
                     x += 432.0;
@@ -677,7 +602,7 @@ void TimeAttack_Main(void *objPtr)
                 self->timer = 0.0;
                 RemoveNativeObject(self->button);
                 RemoveNativeObject(self->labelPtr);
-                for (int i = 0; i < (timeAttack_ZoneCount + timeAttack_ExZoneCount); ++i) RemoveNativeObject(self->zoneButtons[i]);
+                for (int i = 0; i < timeAttack_ZoneCount; ++i) RemoveNativeObject(self->zoneButtons[i]);
                 RemoveNativeObject(self);
             }
             break;
diff --git a/RSDKv4/NativeObjects/TitleScreen.cpp b/RSDKv4/NativeObjects/TitleScreen.cpp
index 74bf0d7..21fbb3a 100644
--- a/RSDKv4/NativeObjects/TitleScreen.cpp
+++ b/RSDKv4/NativeObjects/TitleScreen.cpp
@@ -189,10 +189,10 @@ void TitleScreen_Main(void *objPtr)
             if (self->introRectAlpha < -320.0)
                 self->state = TITLESCREEN_STATE_INTRO;
             RenderRect(-SCREEN_CENTERX_F, SCREEN_CENTERY_F, 160.0, SCREEN_XSIZE_F, SCREEN_YSIZE_F, 0, 0, 0, self->introRectAlpha);
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
-            if (CheckTouchRect(SCREEN_CENTERX_F - 32.0, 104.0, 20.0, 20.0) >= 0 || (keyPress.start || keyPress.A)) {
+            if (CheckTouchRect(SCREEN_CENTERX_F - 32.0, 104.0, 20.0, 20.0) >= 0 || (inputPress.start || inputPress.A)) {
                 self->state                   = TITLESCREEN_STATE_TITLE;
                 self->x                       = -96.0;
                 self->meshScale               = 1.0;
@@ -208,8 +208,8 @@ void TitleScreen_Main(void *objPtr)
         }
 
         case TITLESCREEN_STATE_INTRO: {
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
             SetRenderBlendMode(RENDER_BLEND_NONE);
             RenderRect(-SCREEN_CENTERX_F, SCREEN_CENTERY_F, 160.0, SCREEN_XSIZE_F, SCREEN_YSIZE_F, 255, 255, 255, 255);
             self->meshAnimator.animationSpeed = 6.0 * Engine.deltaTime;
@@ -221,7 +221,7 @@ void TitleScreen_Main(void *objPtr)
             if (self->meshAnimator.frameID > 26)
                 self->state = TITLESCREEN_STATE_ENTERBOX;
 
-            if (CheckTouchRect(SCREEN_CENTERX_F - 32.0, 104.0, 20.0, 20.0) >= 0 || (keyPress.start || keyPress.A)) {
+            if (CheckTouchRect(SCREEN_CENTERX_F - 32.0, 104.0, 20.0, 20.0) >= 0 || (inputPress.start || inputPress.A)) {
                 self->state             = TITLESCREEN_STATE_TITLE;
                 self->x                 = -96.0;
                 self->meshScale         = 1.0;
@@ -299,9 +299,9 @@ void TitleScreen_Main(void *objPtr)
 
             if (self->x <= -96.0) {
                 if (self->logoAlpha > 255) {
-                    CheckKeyDown(&keyDown);
-                    CheckKeyPress(&keyPress);
-                    if (keyPress.start || touches > 0 || keyPress.A) {
+                    CheckKeyDown(&inputDown);
+                    CheckKeyPress(&inputPress);
+                    if (inputPress.start || touches > 0 || inputPress.A) {
                         if (!self->selectionDisabled) {
                             PlaySfxByName("Menu Select", false);
                             StopMusic(true);
diff --git a/RSDKv4/NativeObjects/VirtualDPad.cpp b/RSDKv4/NativeObjects/VirtualDPad.cpp
index 0b10643..9944dee 100644
--- a/RSDKv4/NativeObjects/VirtualDPad.cpp
+++ b/RSDKv4/NativeObjects/VirtualDPad.cpp
@@ -55,28 +55,28 @@ void VirtualDPad_Main(void *objPtr)
             self->offsetX = 0.0;
             self->offsetY = 0.0;
         }
-        else if (keyDown.up) {
+        else if (inputDown.up) {
             RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 128.0, 128.0, 256.0, 120.0, 256.0, 256.0, self->alpha,
                         self->textureID);
 
             self->offsetX = 0.0;
             self->offsetY = 20.0;
         }
-        else if (keyDown.down) {
+        else if (inputDown.down) {
             RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 128.0, -8.0, 256.0, 120.0, 256.0, 392.0, self->alpha,
                         self->textureID);
 
             self->offsetX = 0.0;
             self->offsetY = -20.0;
         }
-        else if (keyDown.left) {
+        else if (inputDown.left) {
             RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 128.0, 128.0, 120.0, 256.0, 256.0, 256.0, self->alpha,
                         self->textureID);
 
             self->offsetX = 20.0;
             self->offsetY = 0.0;
         }
-        else if (keyDown.right) {
+        else if (inputDown.right) {
             RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, -8.0, 128.0, 120.0, 256.0, 392.0, 256.0, self->alpha,
                         self->textureID);
 
@@ -96,7 +96,7 @@ void VirtualDPad_Main(void *objPtr)
                     self->textureID);
 
         float size = 0.0f;
-        if (self->alpha == saveGame->vDPadOpacity && (keyDown.C || keyDown.A || keyDown.B))
+        if (self->alpha == saveGame->vDPadOpacity && (inputDown.C || inputDown.A || inputDown.B))
             size = self->pressedSize;
         else
             size = self->jumpSize;
diff --git a/RSDKv4/NativeObjects/VirtualDPadM.cpp b/RSDKv4/NativeObjects/VirtualDPadM.cpp
index 5dc142d..1ef2c4c 100644
--- a/RSDKv4/NativeObjects/VirtualDPadM.cpp
+++ b/RSDKv4/NativeObjects/VirtualDPadM.cpp
@@ -45,19 +45,19 @@ void VirtualDPadM_Main(void *objPtr)
                     self->textureID);
 
         if (self->alpha == saveGame->vDPadOpacity) {
-            if (keyDown.up) {
+            if (inputDown.up) {
                 RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 25.0, 30.0, 50.0, 55.0, 24.0, 282.0, self->alpha,
                             self->textureID);
             }
-            else if (keyDown.down) {
+            else if (inputDown.down) {
                 RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 26.0, 0.0, 52.0, 128.0, 102.0, 384.0, self->alpha,
                             self->textureID);
             }
-            else if (keyDown.left) {
+            else if (inputDown.left) {
                 RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 128.0, 29.0, 128.0, 59.0, 0.0, 355.0, self->alpha,
                             self->textureID);
             }
-            else if (keyDown.right) {
+            else if (inputDown.right) {
                 RenderImage(self->moveX, self->moveY, 160.0, self->moveSize, self->moveSize, 0.0, 29.0, 128.0, 59.0, 128.0, 355.0, self->alpha,
                             self->textureID);
             }
@@ -65,7 +65,7 @@ void VirtualDPadM_Main(void *objPtr)
 
         int alpha  = 0xFF;
         float sprY = 0;
-        if (keyDown.A && self->alpha == saveGame->vDPadOpacity) {
+        if (inputDown.A && self->alpha == saveGame->vDPadOpacity) {
             alpha = 255;
             sprY  = 256.0;
         }
diff --git a/RSDKv4/Networking.cpp b/RSDKv4/Networking.cpp
index 1be9508..06e8c43 100644
--- a/RSDKv4/Networking.cpp
+++ b/RSDKv4/Networking.cpp
@@ -1,4 +1,5 @@
 #include "RetroEngine.hpp"
+
 #if RETRO_USE_NETWORKING
 
 #include <cstdlib>
@@ -6,10 +7,30 @@
 #include <iostream>
 #include <thread>
 #include <chrono>
+
+#if RETRO_PLATFORM != RETRO_SWITCH
 #if RETRO_PLATFORM == RETRO_ANDROID
 #define ASIO_NO_TYPEID
+#endif // RETRO_PLATFORM == RETRO_ANDROID
+#include <asio/io_context.hpp>
+#include <asio/ip/udp.hpp>
+#include <asio/steady_timer.hpp>
+
+using asio::ip::udp;
+asio::io_context io_context;
+#else
+#include <switch.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <unistd.h> //close
+#include <errno.h>
+#include <fcntl.h>
+
+int sockfd      = 0;
+auto &closeFD   = close; // inherit
+bool socketInit = false;
 #endif
-#include <asio.hpp>
 
 char networkHost[64];
 char networkGame[7] = "SONIC2";
@@ -18,23 +39,25 @@ int dcError         = 0;
 float lastPing      = 0;
 
 bool waitingForPing = false;
+bool waitForVerify  = false;
 
 uint64_t lastTime = 0;
 
-using asio::ip::udp;
-
 typedef std::deque<ServerPacket> DataQueue;
 
 class NetworkSession
 {
 public:
     bool running = false;
+#if RETRO_PLATFORM != RETRO_SWITCH
     NetworkSession(asio::io_context &io_context, const udp::endpoint &endpoint)
         : io_context(io_context), socket(io_context), endpoint(endpoint), timer(io_context)
     {
         socket.open(udp::v4());
     }
-
+#else
+    NetworkSession(const sockaddr_in &addr) { servaddr = addr; }
+#endif
     ~NetworkSession() {}
 
     void write(const ServerPacket &msg, bool repeat = false)
@@ -62,8 +85,12 @@ public:
     {
         if (running)
             running = false;
+#if RETRO_PLATFORM != RETRO_SWITCH
         if (socket.is_open())
             socket.close();
+#else
+        closeFD(sockfd);
+#endif
     }
 
     NetworkSession &operator=(const NetworkSession &s)
@@ -85,13 +112,22 @@ public:
 
     ServerPacket repeat;
 
+    void timerCB()
+    {
+        retried     = true;
+        repeat.room = room;
+        StrCopy(repeat.game, networkGame);
+        if (retries++ == 10)
+            do_write(&repeat);
+    };
+
     void run()
     {
         // do we write anything
         while (!write_msgs_.empty()) {
             ServerPacket *send = &write_msgs_.front();
             StrCopy(send->game, networkGame);
-            socket.send_to(asio::buffer(send, sizeof(ServerPacket)), endpoint);
+            do_write(send);
             write_msgs_.pop_front();
             if (send->header == 0xFF)
                 session->running = false;
@@ -100,14 +136,12 @@ public:
             do_read();
         if (repeat.header != 0x80 && retried) {
             retried = false;
+#if RETRO_PLATFORM != RETRO_SWITCH
             timer.expires_from_now(asio::chrono::seconds(1));
-            timer.async_wait([&](const asio::error_code &) {
-                retried     = true;
-                repeat.room = room;
-                StrCopy(repeat.game, networkGame);
-                if (retries++ == 10)
-                    socket.send_to(asio::buffer(&repeat, sizeof(ServerPacket)), endpoint);
-            });
+            timer.async_wait([&](const asio::error_code &) { timerCB(); });
+#else
+            retryTime = time(NULL);
+#endif
         }
         else if (repeat.header == 0x80)
             retries = 0;
@@ -130,8 +164,13 @@ public:
             }
         }
 
+#if RETRO_PLATFORM != RETRO_SWITCH
         io_context.poll();
         io_context.restart();
+#else
+        if (time(NULL) - retryTime > 10)
+            timerCB();
+#endif
     }
 
     void leave()
@@ -143,6 +182,9 @@ public:
     }
 
 private:
+#if RETRO_PLATFORM != RETRO_SWITCH
+    void do_write(ServerPacket *send) { socket.send_to(asio::buffer(send, sizeof(ServerPacket)), endpoint); }
+
     void do_read()
     {
         if (awaitingReceive)
@@ -152,28 +194,53 @@ private:
             awaitingReceive = false; // async, not threaded. this is safe
             if (ec || !session->running)
                 return;
-            // it's ok to use preformace counter; we're in a different thread and slowdown is safe
-            lastPing       = ((SDL_GetPerformanceCounter() - lastTime) * 1000.0 / SDL_GetPerformanceFrequency());
-            lastTime       = SDL_GetPerformanceCounter();
-            waitingForPing = false;
-            if (!code) {
-                if (read_msg_.header == SV_CODES && read_msg_.player) {
-                    code = read_msg_.player;
-                }
-                return;
-            }
+            handleRead();
+        });
+    }
 
-            switch (read_msg_.header) {
-                case SV_CODES: {
-                    if (vsPlaying)
-                        return;
-                    room = read_msg_.room;
-                    if (read_msg_.data.multiData.type > 2) {
-                        dcError = 3;
-                        leave();
-                        return;
-                    }
+    asio::io_context &io_context;
+    asio::steady_timer timer;
+    udp::socket socket;
+    udp::endpoint endpoint;
+#else
+    void do_write(ServerPacket *send) { int sent = sendto(sockfd, send, sizeof(ServerPacket), 0, (sockaddr *)&servaddr, sizeof(servaddr)); }
+
+    void do_read()
+    {
+        ServerPacket buf;
+        sockaddr_in addrbuf;
+        uint len = sizeof(sockaddr_in);
+        int read = recvfrom(sockfd, &buf, sizeof(ServerPacket), MSG_PEEK, (sockaddr *)&addrbuf, &len);
+        /*if (read != -1)
+            printLog("read %d from %d expecting %d", read, addrbuf.sin_addr.s_addr, servaddr.sin_addr.s_addr);
+        else
+            printLog("read err %s", strerror(errno));//*/
+        if (read == sizeof(ServerPacket) && addrbuf.sin_addr.s_addr == servaddr.sin_addr.s_addr) {
+            recvfrom(sockfd, &read_msg_, sizeof(ServerPacket), 0, (sockaddr *)&servaddr, &len);
+            handleRead();
+        }
+    }
+
+    sockaddr_in servaddr;
+    time_t retryTime;
+#endif
+
+    void handleRead()
+    {
+        // it's ok to use preformace counter; we're in a different thread and slowdown is safe
+        lastPing       = ((SDL_GetPerformanceCounter() - lastTime) * 1000.0 / SDL_GetPerformanceFrequency());
+        lastTime       = SDL_GetPerformanceCounter();
+        waitingForPing = false;
+        if (!code) {
+            if (read_msg_.header == SV_CODES && read_msg_.player) {
+                code = read_msg_.player;
+            }
+            return;
+        }
 
+        switch (read_msg_.header) {
+            case SV_CODES: {
+                if (vsPlaying)
                     if (read_msg_.data.multiData.type - 1) {
                         partner = *read_msg_.data.multiData.data;
                         Receive2PVSMatchCode(room);
@@ -196,36 +263,46 @@ private:
                 case SV_DATA: {
                     Receive2PVSData(&read_msg_.data.multiData);
                     return;
-                }
-                case SV_RECEIVED: {
-                    if (repeat.header == CL_DATA_VERIFIED)
-                        repeat.header = CL_QUERY_VERIFICATION;
+                room = read_msg_.room;
+                if (read_msg_.data.multiData.type > 2) {
+                    dcError = 3;
+                    leave();
                     return;
                 }
-                case SV_VERIFY_CLEAR: {
+
+                if (read_msg_.data.multiData.type - 1) {
+                    partner = *read_msg_.data.multiData.data;
+                    Receive2PVSMatchCode(room);
                     repeat.header = 0x80;
                     return;
                 }
-                case SV_NO_ROOM: {
-                    leave();
-                    dcError = 5;
-                    return;
-                }
-                case SV_LEAVE: {
-                    if (read_msg_.player != partner)
-                        return;
-                    leave();
-                    dcError = 1;
+                break;
+            }
+            case SV_RECEIVED: {
+                if (repeat.header == CL_DATA_VERIFIED)
+                    repeat.header = CL_QUERY_VERIFICATION;
+                return;
+            }
+            case SV_VERIFY_CLEAR: {
+                // waitForVerify = false;
+                repeat.header = 0x80;
+                return;
+            }
+            case SV_NO_ROOM: {
+                leave();
+                dcError = 5;
+                return;
+            }
+            case SV_LEAVE: {
+                if (read_msg_.player != partner)
                     return;
-                }
+                leave();
+                dcError = 1;
+                return;
             }
-        });
+        }
     }
 
-    asio::io_context &io_context;
-    asio::steady_timer timer;
-    udp::socket socket;
-    udp::endpoint endpoint;
     ServerPacket read_msg_;
     DataQueue write_msgs_;
 
@@ -235,18 +312,36 @@ private:
 };
 
 std::shared_ptr<NetworkSession> session;
-asio::io_context io_context;
 std::thread loopThread;
 
 void InitNetwork()
 {
     try {
+#if RETRO_PLATFORM != RETRO_SWITCH
         udp::resolver resolver(io_context);
         asio::error_code ec;
         auto endpoint = *resolver.resolve(udp::v4(), networkHost, std::to_string(networkPort), ec).begin();
         session.reset();
         auto newsession = std::make_shared<NetworkSession>(io_context, endpoint);
         session.swap(newsession);
+#else
+        if (!socketInit) {
+            socketInitializeDefault();
+            nxlinkStdio(); // debug!
+            socketInit = true;
+        }
+        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+            throw std::runtime_error(strerror(errno));
+        }
+        fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);
+        sockaddr_in servaddr;
+        servaddr.sin_family = AF_INET;
+        servaddr.sin_port   = htons(networkPort);
+        inet_aton(networkHost, &servaddr.sin_addr);
+        session.reset();
+        auto newsession = std::make_shared<NetworkSession>(servaddr);
+        session.swap(newsession);
+#endif
     } catch (std::exception &e) {
         Engine.onlineActive = false;
         PrintLog("Failed to initialize networking: %s", e.what());
@@ -279,18 +374,24 @@ void SendData(bool verify)
     send.header         = CL_DATA + verify;
     send.data.multiData = multiplayerDataOUT;
     session->write(send, verify);
+    // if (verify)
+    //    waitForVerify = true;
 }
 
 void DisconnectNetwork(bool finalClose)
 {
     if (session->running)
         session->leave();
+
     if (loopThread.joinable())
         loopThread.join();
-
     if (finalClose) {
         if (session)
             session.reset();
+#if RETRO_PLATFORM == RETRO_SWITCH
+        socketExit();
+        socketInit = false;
+#endif
     }
 }
 
diff --git a/RSDKv4/Networking.hpp b/RSDKv4/Networking.hpp
index b30307a..4545cfc 100644
--- a/RSDKv4/Networking.hpp
+++ b/RSDKv4/Networking.hpp
@@ -1,6 +1,7 @@
-#if RETRO_USE_NETWORKING
 #ifndef NETWORKING_H
 #define NETWORKING_H
+
+#if RETRO_USE_NETWORKING
 #include <thread>
 #include <memory>
 
@@ -13,6 +14,7 @@ extern int networkPort;
 extern float lastPing;
 extern int dcError;
 extern bool waitingForPing;
+extern bool waitForVerify;
 
 struct MultiplayerData {
     int type;
@@ -74,4 +76,4 @@ void SetRoomCode(int code);
 void SetNetworkGameName(int *unused, const char *name);
 
 #endif
-#endif
+#endif
\ No newline at end of file
diff --git a/RSDKv4/Object.cpp b/RSDKv4/Object.cpp
index 7ddf148..4318e0a 100644
--- a/RSDKv4/Object.cpp
+++ b/RSDKv4/Object.cpp
@@ -61,7 +61,7 @@ void ProcessStartupObjects()
         scriptInfo->spriteSheetID   = 0;
         entity->type                = i;
 
-        if (scriptCode[scriptInfo->eventStartup.scriptCodePtr] > 0)
+        if (scriptData[scriptInfo->eventStartup.scriptCodePtr] > 0)
             ProcessScript(scriptInfo->eventStartup.scriptCodePtr, scriptInfo->eventStartup.jumpTablePtr, EVENT_SETUP);
         scriptInfo->frameCount = scriptFrameCount - scriptInfo->frameListOffset;
     }
@@ -81,20 +81,20 @@ void ProcessObjects()
         y              = entity->ypos >> 16;
 
         switch (entity->priority) {
-            case PRIORITY_BOUNDS:
+            case PRIORITY_ACTIVE_BOUNDS:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < xScrollOffset + OBJECT_BORDER_X2
                                                      && y > yScrollOffset - OBJECT_BORDER_Y1 && y < yScrollOffset + OBJECT_BORDER_Y2;
                 break;
 
             case PRIORITY_ACTIVE:
-            case PRIORITY_ALWAYS:
+            case PRIORITY_ACTIVE_PAUSED:
             case PRIORITY_ACTIVE_SMALL: processObjectFlag[objectEntityPos] = true; break;
 
-            case PRIORITY_XBOUNDS:
+            case PRIORITY_ACTIVE_XBOUNDS:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < OBJECT_BORDER_X2 + xScrollOffset;
                 break;
 
-            case PRIORITY_XBOUNDS_DESTROY:
+            case PRIORITY_ACTIVE_XBOUNDS_REMOVE:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < xScrollOffset + OBJECT_BORDER_X2;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = false;
@@ -103,7 +103,7 @@ void ProcessObjects()
                 break;
 
             case PRIORITY_INACTIVE: processObjectFlag[objectEntityPos] = false; break;
-            case PRIORITY_BOUNDS_SMALL:
+            case PRIORITY_ACTIVE_BOUNDS_SMALL:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X3 && x < OBJECT_BORDER_X4 + xScrollOffset
                                                      && y > yScrollOffset - OBJECT_BORDER_Y3 && y < yScrollOffset + OBJECT_BORDER_Y4;
                 break;
@@ -113,10 +113,10 @@ void ProcessObjects()
 
         if (processObjectFlag[objectEntityPos] && entity->type > OBJ_TYPE_BLANKOBJECT) {
             ObjectScript *scriptInfo = &objectScriptList[entity->type];
-            if (scriptCode[scriptInfo->eventUpdate.scriptCodePtr] > 0)
-                ProcessScript(scriptInfo->eventUpdate.scriptCodePtr, scriptInfo->eventUpdate.jumpTablePtr, EVENT_MAIN);
+            if (scriptData[scriptInfo->eventMain.scriptCodePtr] > 0)
+                ProcessScript(scriptInfo->eventMain.scriptCodePtr, scriptInfo->eventMain.jumpTablePtr, EVENT_MAIN);
 
-            if (entity->drawOrder < DRAWLAYER_COUNT)
+            if (entity->drawOrder < DRAWLAYER_COUNT && entity->drawOrder >= 0)
                 drawListEntries[entity->drawOrder].entityRefs[drawListEntries[entity->drawOrder].listSize++] = objectEntityPos;
         }
     }
@@ -131,7 +131,6 @@ void ProcessObjects()
                 TypeGroupList *listCustom                      = &objectTypeGroupList[objectEntityList[objectEntityPos].groupID];
                 listCustom->entityRefs[listCustom->listSize++] = objectEntityPos;
             }
-
             // Type-Specific list
             TypeGroupList *listType                    = &objectTypeGroupList[objectEntityList[objectEntityPos].type];
             listType->entityRefs[listType->listSize++] = objectEntityPos;
@@ -149,10 +148,10 @@ void ProcessPausedObjects()
     for (objectEntityPos = 0; objectEntityPos < ENTITY_COUNT; ++objectEntityPos) {
         Entity *entity = &objectEntityList[objectEntityPos];
 
-        if (entity->priority == PRIORITY_ALWAYS && entity->type > OBJ_TYPE_BLANKOBJECT) {
+        if (entity->priority == PRIORITY_ACTIVE_PAUSED && entity->type > OBJ_TYPE_BLANKOBJECT) {
             ObjectScript *scriptInfo = &objectScriptList[entity->type];
-            if (scriptCode[scriptInfo->eventUpdate.scriptCodePtr] > 0)
-                ProcessScript(scriptInfo->eventUpdate.scriptCodePtr, scriptInfo->eventUpdate.jumpTablePtr, EVENT_MAIN);
+            if (scriptData[scriptInfo->eventMain.scriptCodePtr] > 0)
+                ProcessScript(scriptInfo->eventMain.scriptCodePtr, scriptInfo->eventMain.jumpTablePtr, EVENT_MAIN);
 
             if (entity->drawOrder < DRAWLAYER_COUNT && entity->drawOrder >= 0)
                 drawListEntries[entity->drawOrder].entityRefs[drawListEntries[entity->drawOrder].listSize++] = objectEntityPos;
@@ -171,20 +170,20 @@ void ProcessFrozenObjects()
         y              = entity->ypos >> 16;
 
         switch (entity->priority) {
-            case PRIORITY_BOUNDS:
+            case PRIORITY_ACTIVE_BOUNDS:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < xScrollOffset + OBJECT_BORDER_X2
                                                      && y > yScrollOffset - OBJECT_BORDER_Y1 && y < yScrollOffset + OBJECT_BORDER_Y2;
                 break;
 
             case PRIORITY_ACTIVE:
-            case PRIORITY_ALWAYS:
+            case PRIORITY_ACTIVE_PAUSED:
             case PRIORITY_ACTIVE_SMALL: processObjectFlag[objectEntityPos] = true; break;
 
-            case PRIORITY_XBOUNDS:
+            case PRIORITY_ACTIVE_XBOUNDS:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < OBJECT_BORDER_X2 + xScrollOffset;
                 break;
 
-            case PRIORITY_XBOUNDS_DESTROY:
+            case PRIORITY_ACTIVE_XBOUNDS_REMOVE:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X1 && x < xScrollOffset + OBJECT_BORDER_X2;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = false;
@@ -194,7 +193,7 @@ void ProcessFrozenObjects()
 
             case PRIORITY_INACTIVE: processObjectFlag[objectEntityPos] = false; break;
 
-            case PRIORITY_BOUNDS_SMALL:
+            case PRIORITY_ACTIVE_BOUNDS_SMALL:
                 processObjectFlag[objectEntityPos] = x > xScrollOffset - OBJECT_BORDER_X3 && x < OBJECT_BORDER_X4 + xScrollOffset
                                                      && y > yScrollOffset - OBJECT_BORDER_Y3 && y < yScrollOffset + OBJECT_BORDER_Y4;
                 break;
@@ -204,8 +203,8 @@ void ProcessFrozenObjects()
 
         if (processObjectFlag[objectEntityPos] && entity->type > OBJ_TYPE_BLANKOBJECT) {
             ObjectScript *scriptInfo = &objectScriptList[entity->type];
-            if (scriptCode[scriptInfo->eventUpdate.scriptCodePtr] > 0 && entity->priority == PRIORITY_ALWAYS)
-                ProcessScript(scriptInfo->eventUpdate.scriptCodePtr, scriptInfo->eventUpdate.jumpTablePtr, EVENT_MAIN);
+            if (scriptData[scriptInfo->eventMain.scriptCodePtr] > 0 && entity->priority == PRIORITY_ACTIVE_PAUSED)
+                ProcessScript(scriptInfo->eventMain.scriptCodePtr, scriptInfo->eventMain.jumpTablePtr, EVENT_MAIN);
 
             if (entity->drawOrder < DRAWLAYER_COUNT && entity->drawOrder >= 0)
                 drawListEntries[entity->drawOrder].entityRefs[drawListEntries[entity->drawOrder].listSize++] = objectEntityPos;
@@ -264,7 +263,7 @@ void Process2PObjects()
         int YPosP2       = entityP2->ypos;
 
         switch (entity->priority) {
-            case PRIORITY_BOUNDS:
+            case PRIORITY_ACTIVE_BOUNDS:
                 processObjectFlag[objectEntityPos] = x > XPosP1 + boundX1 && x < XPosP1 + boundX2 && y > YPosP1 + boundY1 && y < YPosP1 + boundY2;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = x > XPosP2 + boundX1 && x < XPosP2 + boundX2 && y > YPosP2 + boundY1 && y < YPosP2 + boundY2;
@@ -272,17 +271,17 @@ void Process2PObjects()
                 break;
 
             case PRIORITY_ACTIVE:
-            case PRIORITY_ALWAYS:
+            case PRIORITY_ACTIVE_PAUSED:
             case PRIORITY_ACTIVE_SMALL: processObjectFlag[objectEntityPos] = true; break;
 
-            case PRIORITY_XBOUNDS:
+            case PRIORITY_ACTIVE_XBOUNDS:
                 processObjectFlag[objectEntityPos] = x > XPosP1 + boundX1 && x < XPosP1 + boundX2;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = x > XPosP2 + boundX1 && x < XPosP2 + boundX2;
                 }
                 break;
 
-            case PRIORITY_XBOUNDS_DESTROY:
+            case PRIORITY_ACTIVE_XBOUNDS_REMOVE:
                 processObjectFlag[objectEntityPos] = x > XPosP1 + boundX1 && x < XPosP1 + boundX2;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = x > XPosP2 + boundX1 && x < XPosP2 + boundX2;
@@ -293,7 +292,7 @@ void Process2PObjects()
                 break;
 
             case PRIORITY_INACTIVE: processObjectFlag[objectEntityPos] = false; break;
-            case PRIORITY_BOUNDS_SMALL:
+            case PRIORITY_ACTIVE_BOUNDS_SMALL:
                 processObjectFlag[objectEntityPos] = x > XPosP1 + boundX3 && x < XPosP1 + boundX4 && y > YPosP1 + boundY3 && y < YPosP1 + boundY4;
                 if (!processObjectFlag[objectEntityPos]) {
                     processObjectFlag[objectEntityPos] = x > XPosP2 + boundX3 && x < XPosP2 + boundX4 && y > YPosP2 + boundY3 && y < YPosP2 + boundY4;
@@ -305,8 +304,8 @@ void Process2PObjects()
 
         if (processObjectFlag[objectEntityPos] && entity->type > OBJ_TYPE_BLANKOBJECT) {
             ObjectScript *scriptInfo = &objectScriptList[entity->type];
-            if (scriptCode[scriptInfo->eventUpdate.scriptCodePtr] > 0)
-                ProcessScript(scriptInfo->eventUpdate.scriptCodePtr, scriptInfo->eventUpdate.jumpTablePtr, EVENT_MAIN);
+            if (scriptData[scriptInfo->eventMain.scriptCodePtr] > 0)
+                ProcessScript(scriptInfo->eventMain.scriptCodePtr, scriptInfo->eventMain.jumpTablePtr, EVENT_MAIN);
 
             if (entity->drawOrder < DRAWLAYER_COUNT && entity->drawOrder >= 0)
                 drawListEntries[entity->drawOrder].entityRefs[drawListEntries[entity->drawOrder].listSize++] = objectEntityPos;
@@ -348,21 +347,21 @@ void SetObjectTypeName(const char *objectName, int objectID)
     PrintLog("Set Object (%d) name to: %s", objectID, objectName);
 }
 
-void ProcessObjectControl(Entity *entity)
+void ProcessObjectControl(Entity *player)
 {
-    if (entity->controlMode == 0) {
-        entity->up   = keyDown.up;
-        entity->down = keyDown.down;
-        if (!keyDown.left || !keyDown.right) {
-            entity->left  = keyDown.left;
-            entity->right = keyDown.right;
+    if (!player->controlMode) {
+        player->up   = inputDown.up;
+        player->down = inputDown.down;
+        if (!inputDown.left || !inputDown.right) {
+            player->left  = inputDown.left;
+            player->right = inputDown.right;
         }
         else {
-            entity->left  = false;
-            entity->right = false;
+            player->left  = false;
+            player->right = false;
         }
-        entity->jumpHold  = keyDown.C || keyDown.B || keyDown.A;
-        entity->jumpPress = keyPress.C || keyPress.B || keyPress.A;
+        player->jumpHold  = inputDown.C || inputDown.B || inputDown.A;
+        player->jumpPress = inputPress.C || inputPress.B || inputPress.A;
     }
 }
 
@@ -402,16 +401,16 @@ void InitNativeObjectSystem()
         saveGame->knuxUnlocked    = Engine.gameType != GAME_SONIC1;
         saveGame->unlockedActs    = 0;
         WriteSaveRAMData();
-    }
 #if !RETRO_USE_ORIGINAL_CODE
+    }
     else if (Engine.gameType == GAME_SONIC2) {
         // ensure tails and knuckles are unlocked in sonic 2
         // they weren't automatically unlocked in older versions of the decomp
         saveGame->tailsUnlocked = true;
         saveGame->knuxUnlocked  = true;
         WriteSaveRAMData();
-    }
 #endif
+    }
     saveGame->musVolume = bgmVolume;
     saveGame->sfxVolume = sfxVolume;
 
@@ -477,7 +476,7 @@ void RemoveNativeObject(NativeEntityBase *entity)
 #if !RETRO_USE_ORIGINAL_CODE
     if (!entity)
         return;
-    memmove(&activeEntityList[entity->objectID], &activeEntityList[entity->objectID + 1], sizeof(int) * (NATIVEENTITY_COUNT - (entity->objectID + 2)));
+    memcpy(&activeEntityList[entity->objectID], &activeEntityList[entity->objectID + 1], sizeof(int) * (NATIVEENTITY_COUNT - (entity->objectID + 2)));
     --nativeEntityCount;
     for (int i = entity->slotID; objectEntityBank[i].eventMain; ++i) objectEntityBank[i].objectID--;
 #else
diff --git a/RSDKv4/Object.hpp b/RSDKv4/Object.hpp
index 3160c12..e014eae 100644
--- a/RSDKv4/Object.hpp
+++ b/RSDKv4/Object.hpp
@@ -38,7 +38,7 @@ struct Entity {
     byte type;
     byte propertyValue;
     byte priority;
-    byte drawOrder;
+    sbyte drawOrder;
     byte direction;
     byte inkEffect;
     byte animation;
@@ -89,19 +89,19 @@ enum ObjectGroups {
 
 enum ObjectPriority {
     // The entity is active if the entity is on screen or within 128 pixels of the screen borders on any axis
-    PRIORITY_BOUNDS,
-    // The entity is always active, unless the stage state is PAUSED/FROZEN
+    PRIORITY_ACTIVE_BOUNDS,
+    // The entity is always active, unless the stage state is PAUSED or FROZEN
     PRIORITY_ACTIVE,
-    // Same as PRIORITY_ACTIVE, the entity even runs when the stage state is PAUSED/FROZEN
-    PRIORITY_ALWAYS,
-    // Same as PRIORITY_BOUNDS, however it only does checks on the x-axis, so when in bounds on the x-axis, the y position doesn't matter
-    PRIORITY_XBOUNDS,
-    // Same as PRIORITY_XBOUNDS, however the entity's type will be set to BLANK OBJECT when it becomes inactive
-    PRIORITY_XBOUNDS_DESTROY,
+    // Same as PRIORITY_ACTIVE, the entity even runs when the stage state is PAUSED or FROZEN
+    PRIORITY_ACTIVE_PAUSED,
+    // Same as PRIORITY_ACTIVE_BOUNDS, however it only does checks on the x-axis, so when in bounds on the x-axis, the y position doesn't matter
+    PRIORITY_ACTIVE_XBOUNDS,
+    // Same as PRIORITY_ACTIVE_XBOUNDS, however the entity's type will be set to BLANK OBJECT when it becomes inactive
+    PRIORITY_ACTIVE_XBOUNDS_REMOVE,
     // Never Active.
     PRIORITY_INACTIVE,
-    // Same as PRIORITY_BOUNDS, but uses the smaller bounds (32px off screen rather than the normal 128)
-    PRIORITY_BOUNDS_SMALL,
+    // Same as PRIORITY_ACTIVE_BOUNDS, but uses the smaller bounds (32px off screen rather than the normal 128)
+    PRIORITY_ACTIVE_BOUNDS_SMALL,
     // Same as PRIORITY_ACTIVE, but uses the smaller bounds in object.outOfBounds
     PRIORITY_ACTIVE_SMALL
 };
@@ -152,7 +152,7 @@ void SetObjectTypeName(const char *objectName, int objectID);
 
 extern int playerListPos;
 
-void ProcessObjectControl(Entity *entity);
+void ProcessObjectControl(Entity *player);
 
 void InitNativeObjectSystem();
 NativeEntity *CreateNativeObject(void (*objCreate)(void *objPtr), void (*objMain)(void *objPtr));
diff --git a/RSDKv4/Palette.cpp b/RSDKv4/Palette.cpp
index c9f4f35..43f2022 100644
--- a/RSDKv4/Palette.cpp
+++ b/RSDKv4/Palette.cpp
@@ -22,6 +22,7 @@ byte fadeA   = 0;
 byte fadeR   = 0;
 byte fadeG   = 0;
 byte fadeB   = 0;
+int fadeX = 0;
 
 int paletteMode = 1;
 
@@ -56,7 +57,7 @@ void LoadPalette(const char *filePath, int paletteID, int startPaletteIndex, int
 }
 
 #if RETRO_REV00
-void SetLimitedFade(byte paletteID, byte R, byte G, byte B, ushort blendAmount, int startIndex, int endIndex)
+void SetLimitedFade(byte paletteID, byte R, byte G, byte B, ushort alpha, int startIndex, int endIndex)
 {
     if (paletteID >= PALETTE_COUNT)
         return;
@@ -70,15 +71,15 @@ void SetLimitedFade(byte paletteID, byte R, byte G, byte B, ushort blendAmount,
     if (startIndex >= endIndex)
         return;
 
-    uint blendA = 0xFF - blendAmount;
-    for (int i = startIndex; i < endIndex; ++i) {
-        PACK_RGB888(activePalette[i], (byte)((ushort)(R * blendAmount + blendA * activePalette32[i].r) >> 8),
-                    (byte)((ushort)(G * blendAmount + blendA * activePalette32[i].g) >> 8),
-                    (byte)((ushort)(B * blendAmount + blendA * activePalette32[i].b) >> 8));
+    uint alpha2 = 0xFF - alpha;
+    for (int i = startIndex; i <= endIndex; ++i) {
+        PACK_RGB888(activePalette[i], (byte)((ushort)(R * alpha + alpha2 * activePalette32[i].r) >> 8),
+                    (byte)((ushort)(G * alpha + alpha2 * activePalette32[i].g) >> 8),
+                    (byte)((ushort)(B * alpha + alpha2 * activePalette32[i].b) >> 8));
 
-        activePalette32[i].r = (byte)((ushort)(R * blendAmount + blendA * activePalette32[i].r) >> 8);
-        activePalette32[i].g = (byte)((ushort)(G * blendAmount + blendA * activePalette32[i].g) >> 8);
-        activePalette32[i].b = (byte)((ushort)(B * blendAmount + blendA * activePalette32[i].b) >> 8);
+        activePalette32[i].r = (byte)((ushort)(R * alpha + alpha2 * activePalette32[i].r) >> 8);
+        activePalette32[i].g = (byte)((ushort)(G * alpha + alpha2 * activePalette32[i].g) >> 8);
+        activePalette32[i].b = (byte)((ushort)(B * alpha + alpha2 * activePalette32[i].b) >> 8);
     }
 }
 #else
diff --git a/RSDKv4/Palette.hpp b/RSDKv4/Palette.hpp
index 2f89467..45adf47 100644
--- a/RSDKv4/Palette.hpp
+++ b/RSDKv4/Palette.hpp
@@ -37,6 +37,7 @@ extern byte fadeA;
 extern byte fadeR;
 extern byte fadeG;
 extern byte fadeB;
+extern int fadeX;
 
 extern int paletteMode;
 
@@ -127,17 +128,20 @@ inline void RotatePalette(int palID, byte startIndex, byte endIndex, bool right)
     }
 }
 
-inline void SetFade(byte R, byte G, byte B, ushort A)
+inline void SetFade(byte mode, byte R, byte G, byte B, int A)
 {
-    fadeMode = 1;
+    fadeMode = mode;
     fadeR    = R;
     fadeG    = G;
     fadeB    = B;
-    fadeA    = A > 0xFF ? 0xFF : A;
+	if (fadeMode == 1)
+		fadeA    = A > 0xFF ? 0xFF : A;
+	else
+		fadeX = A;
 }
 
 #if RETRO_REV00
-void SetLimitedFade(byte paletteID, byte R, byte G, byte B, ushort blendAmount, int startIndex, int endIndex);
+void SetLimitedFade(byte paletteID, byte R, byte G, byte B, ushort alpha, int startIndex, int endIndex);
 #else
 void SetPaletteFade(byte destPaletteID, byte srcPaletteA, byte srcPaletteB, ushort blendAmount, int startIndex, int endIndex);
 #endif
diff --git a/RSDKv4/Reader.cpp b/RSDKv4/Reader.cpp
index 3071fbf..f50b037 100644
--- a/RSDKv4/Reader.cpp
+++ b/RSDKv4/Reader.cpp
@@ -28,9 +28,7 @@ bool CheckRSDKFile(const char *filePath)
 
     char filePathBuffer[0x100];
 #if RETRO_PLATFORM == RETRO_OSX
-    char pathBuf[0x100];
-    sprintf(pathBuf, "%s/%s", gamePath, filePath);
-    sprintf(filePathBuffer, "%s", pathBuf);
+    sprintf(filePathBuffer, "%s/%s", gamePath, filePath);
 #else
     sprintf(filePathBuffer, "%s", filePath);
 #endif
diff --git a/RSDKv4/Reader.hpp b/RSDKv4/Reader.hpp
index b7eb8f1..7b1da33 100644
--- a/RSDKv4/Reader.hpp
+++ b/RSDKv4/Reader.hpp
@@ -1,6 +1,19 @@
 #ifndef READER_H
 #define READER_H
 
+#if RETRO_PLATFORM == RETRO_LINUX   // Force case insensitivity for Linux
+
+#include "fcaseopen.h"
+#define FileIO                                          FILE
+#define fOpen(path, mode)                               fcaseopen(path, mode)
+#define fRead(buffer, elementSize, elementCount, file)  fread(buffer, elementSize, elementCount, file)
+#define fSeek(file, offset, whence)                     fseek(file, offset, whence)
+#define fTell(file)                                     ftell(file)
+#define fClose(file)                                    fclose(file)
+#define fWrite(buffer, elementSize, elementCount, file) fwrite(buffer, elementSize, elementCount, file)
+
+#else                               // Force case insensitivity for Linux
+
 #ifdef FORCE_CASE_INSENSITIVE
 
 #include "fcaseopen.h"
@@ -32,6 +45,8 @@
 #define fWrite(buffer, elementSize, elementCount, file) fwrite(buffer, elementSize, elementCount, file)
 #endif
 
+#endif                              // Force case insensitivity for Linux
+
 #endif
 
 #define RETRO_PACKFILE_COUNT (0x1000)
diff --git a/RSDKv4/RetroEngine.cpp b/RSDKv4/RetroEngine.cpp
index 29f393f..0cf1d6a 100644
--- a/RSDKv4/RetroEngine.cpp
+++ b/RSDKv4/RetroEngine.cpp
@@ -12,7 +12,7 @@ bool engineDebugMode = false;
 RetroEngine Engine = RetroEngine();
 
 #if !RETRO_USE_ORIGINAL_CODE
-inline int GetLowerRate(int intendRate, int targetRate)
+inline int getLowerRate(int intendRate, int targetRate)
 {
     int result   = 0;
     int valStore = 0;
@@ -29,7 +29,11 @@ inline int GetLowerRate(int intendRate, int targetRate)
 }
 #endif
 
-bool ProcessEvents()
+#if RETRO_PLATFORM == RETRO_SWITCH
+int devDownTimer = 0;
+#endif
+
+bool processEvents()
 {
 #if !RETRO_USE_ORIGINAL_CODE
 #if RETRO_USING_SDL1 || RETRO_USING_SDL2
@@ -48,26 +52,35 @@ bool ProcessEvents()
                     }
                     case SDL_WINDOWEVENT_CLOSE: return false;
                     case SDL_WINDOWEVENT_FOCUS_LOST:
+						/*
                         if (Engine.gameMode == ENGINE_MAINGAME && !(disableFocusPause & 1))
                             Engine.gameMode = ENGINE_INITPAUSE;
 #if RETRO_REV00
                         if (!(disableFocusPause & 1))
                             Engine.message = MESSAGE_LOSTFOCUS;
 #endif
+						*/
                         Engine.hasFocus = false;
                         break;
                     case SDL_WINDOWEVENT_FOCUS_GAINED: Engine.hasFocus = true; break;
                 }
                 break;
+            // TODO!!!!:
+            // Due to a design choice in SDL2, the `which` that the controller added event reports is different to the `which` that the controller removed
+            // event reports. controller added event reports back the index for `which`, whereas the device removed event `which` reports the controllerID
+            // this is fixed in SDL3, but for now we'll just hack around it.
             case SDL_CONTROLLERDEVICEADDED: controllerInit(Engine.sdlEvents.cdevice.which); break;
             case SDL_CONTROLLERDEVICEREMOVED: controllerClose(Engine.sdlEvents.cdevice.which); break;
+            // ---
             case SDL_APP_WILLENTERBACKGROUND:
+				/*
                 if (Engine.gameMode == ENGINE_MAINGAME && !(disableFocusPause & 1))
                     Engine.gameMode = ENGINE_INITPAUSE;
 #if RETRO_REV00
                 if (!(disableFocusPause & 1))
                     Engine.message = MESSAGE_LOSTFOCUS;
 #endif
+				*/
                 Engine.hasFocus = false;
                 break;
             case SDL_APP_WILLENTERFOREGROUND: Engine.hasFocus = true; break;
@@ -352,7 +365,7 @@ void RetroEngine::Init()
                     InitStartingStage(startList_Game == 0xFF ? STAGELIST_PRESENTATION : startList_Game, startStage_Game == 0xFF ? 0 : startStage_Game,
                                       startPlayer == 0xFF ? 0 : startPlayer);
                 }
-                else if (startSave != 0xFF && startSave <= 4) {
+                else if (startSave != 0xFF && startSave < 4) {
                     if (startSave == 0) {
                         SetGlobalVariableByName("options.saveSlot", 0);
                         SetGlobalVariableByName("options.gameMode", 0);
@@ -439,7 +452,7 @@ void RetroEngine::Init()
 
 #if !RETRO_USE_ORIGINAL_CODE
     // Calculate Skip frame
-    int lower        = GetLowerRate(targetRefreshRate, refreshRate);
+    int lower        = getLowerRate(targetRefreshRate, refreshRate);
     renderFrameIndex = targetRefreshRate / lower;
     skipFrameIndex   = refreshRate / lower;
 
@@ -449,7 +462,7 @@ void RetroEngine::Init()
         AddAchievement("Ramp Ring Acrobatics",
                        "Without touching the ground,\rcollect all the rings in a\rtrapezoid formation in Green\rHill Zone Act 1");
         AddAchievement("Blast Processing", "Clear Green Hill Zone Act 1\rin under 30 seconds");
-        AddAchievement("Secret of Marble Zone", "Travel though a secret\rroom in Marble Zone Act 3");
+        AddAchievement("Secret of Marble Zone", "Travel though a secret\rroom in Marbale Zone Act 3");
         AddAchievement("Block Buster", "Break 16 blocks in a row\rwithout stopping");
         AddAchievement("Ring King", "Collect 200 Rings");
         AddAchievement("Secret of Labyrinth Zone", "Activate and ride the\rhidden platform in\rLabyrinth Zone Act 1");
@@ -479,46 +492,6 @@ void RetroEngine::Init()
         Engine.gameMode = ENGINE_MAINGAME;
     else
         Engine.gameMode = ENGINE_WAIT;
-
-    // "error message"
-    if (!running) {
-        char rootDir[0x80];
-        char pathBuffer[0x80];
-
-#if RETRO_PLATFORM == RETRO_UWP
-        if (!usingCWD)
-            sprintf(rootDir, "%s/", getResourcesPath());
-        else
-            sprintf(rootDir, "%s", "");
-#elif RETRO_PLATFORM == RETRO_OSX
-        sprintf(rootDir, "%s/", gamePath);
-#else
-        sprintf(rootDir, "%s", "");
-#endif
-        sprintf(pathBuffer, "%s%s", rootDir, "usage.txt");
-
-        FileIO *f;
-        if ((f = fOpen(pathBuffer, "w")) == NULL) {
-            PrintLog("ERROR: Couldn't open file '%s' for writing!", "usage.txt");
-            return;
-        }
-
-        char textBuf[0x100];
-        sprintf(textBuf, "RETRO ENGINE v4 USAGE:\n");
-        fWrite(textBuf, 1, strlen(textBuf), f);
-
-        sprintf(textBuf, "- Open the asset directory '%s' in a file browser\n", !rootDir[0] ? "./" : rootDir);
-        fWrite(textBuf, 1, strlen(textBuf), f);
-
-        sprintf(textBuf, "- Place a data pack named '%s' in the asset directory\n", Engine.dataFile[0]);
-        fWrite(textBuf, 1, strlen(textBuf), f);
-
-        sprintf(textBuf, "- OR extract a data pack and place the \"Data\" & \"Bytecode\" folders in the asset directory\n");
-        fWrite(textBuf, 1, strlen(textBuf), f);
-
-        fClose(f);
-    }
-
 #endif
 }
 
@@ -529,21 +502,28 @@ void RetroEngine::Run()
     unsigned long long targetFreq = SDL_GetPerformanceFrequency() / Engine.refreshRate;
     unsigned long long curTicks   = 0;
     unsigned long long prevTicks  = 0;
+	int lastFPS = Engine.refreshRate;
 
     while (running) {
 #if !RETRO_USE_ORIGINAL_CODE
-        if (!vsync) {
+        //if (!vsync) {
             curTicks = SDL_GetPerformanceCounter();
             if (curTicks < prevTicks + targetFreq)
                 continue;
             prevTicks = curTicks;
-        }
+        //}
 
         Engine.deltaTime = 1.0 / 60;
 #endif
-        running = ProcessEvents();
+        running = processEvents();
 
+        if (lastFPS != Engine.refreshRate) {
+		    targetFreq = SDL_GetPerformanceFrequency() / Engine.refreshRate;
+			lastFPS = Engine.refreshRate;
+		}
+		
         // Focus Checks
+		/*
         if (!(disableFocusPause & 2)) {
             if (!Engine.hasFocus) {
                 if (!(Engine.focusState & 1))
@@ -555,6 +535,7 @@ void RetroEngine::Run()
                 Engine.focusState = 0;
             }
         }
+		*/
 
         if (!(Engine.focusState & 1) || vsPlaying) {
 #if !RETRO_USE_ORIGINAL_CODE
@@ -584,6 +565,45 @@ void RetroEngine::Run()
             }
 #endif
 
+#if RETRO_PLATFORM == RETRO_SWITCH
+            //it's time for some devmenu switch hacks
+            if (getControllerButton(SDL_CONTROLLER_BUTTON_LEFTSHOULDER) && Engine.devMenu) {
+                if (getControllerButton(SDL_CONTROLLER_BUTTON_BACK)) {
+                    SDL_Event event;
+                    event.type           = SDL_KEYDOWN;
+                    event.key.keysym.sym = SDLK_ESCAPE;
+                    SDL_PushEvent(&event);
+                }
+                if (getControllerButton(SDL_CONTROLLER_BUTTON_ZL)) {
+                    if (!masterPaused) masterPaused = true;
+                }
+                else {
+                    if (masterPaused) masterPaused = false;
+                }
+
+                if (masterPaused) {
+                    if (getControllerButton(SDL_CONTROLLER_BUTTON_RIGHTSHOULDER)) {
+                        if (!devDownTimer++) frameStep = true;
+                    }
+                    else devDownTimer = 0;
+                }
+                else {
+                    if (getControllerButton(SDL_CONTROLLER_BUTTON_ZR)) {
+                        Engine.gameSpeed = Engine.fastForwardSpeed;
+                    }
+                    else Engine.gameSpeed = 1;
+                }
+            }
+            else {
+                if (Engine.gameSpeed != 1) 
+                    Engine.gameSpeed = 1;
+                
+                if (masterPaused)
+                    masterPaused = false;
+            } 
+#endif
+
+
 #if RETRO_REV00
             Engine.message = MESSAGE_NONE;
 #endif
@@ -601,6 +621,7 @@ void RetroEngine::Run()
     }
 
     ReleaseAudioDevice();
+    StopVideoPlayback();
     ReleaseRenderDevice();
 #if !RETRO_USE_ORIGINAL_CODE
     ReleaseInputDevices();
@@ -619,7 +640,7 @@ void RetroEngine::Run()
 }
 
 #if RETRO_USE_MOD_LOADER
-const tinyxml2::XMLElement *FirstXMLChildElement(tinyxml2::XMLDocument *doc, const tinyxml2::XMLElement *elementPtr, const char *name)
+const tinyxml2::XMLElement *firstXMLChildElement(tinyxml2::XMLDocument *doc, const tinyxml2::XMLElement *elementPtr, const char *name)
 {
     if (doc) {
         if (!elementPtr)
@@ -630,7 +651,7 @@ const tinyxml2::XMLElement *FirstXMLChildElement(tinyxml2::XMLDocument *doc, con
     return NULL;
 }
 
-const tinyxml2::XMLElement *NextXMLSiblingElement(tinyxml2::XMLDocument *doc, const tinyxml2::XMLElement *elementPtr, const char *name)
+const tinyxml2::XMLElement *nextXMLSiblingElement(tinyxml2::XMLDocument *doc, const tinyxml2::XMLElement *elementPtr, const char *name)
 {
     if (doc) {
         if (!elementPtr)
@@ -641,51 +662,19 @@ const tinyxml2::XMLElement *NextXMLSiblingElement(tinyxml2::XMLDocument *doc, co
     return NULL;
 }
 
-const tinyxml2::XMLAttribute *FindXMLAttribute(const tinyxml2::XMLElement *elementPtr, const char *name) { return elementPtr->FindAttribute(name); }
-const char *GetXMLAttributeName(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->Name(); }
-int GetXMLAttributeValueInt(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->IntValue(); }
-bool GetXMLAttributeValueBool(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->BoolValue(); }
-const char *GetXMLAttributeValueString(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->Value(); }
-
-void RetroEngine::LoadXMLWindowText()
-{
-    FileInfo info;
-    for (int m = 0; m < (int)modList.size(); ++m) {
-        if (!modList[m].active)
-            continue;
-
-        SetActiveMod(m);
-        if (LoadFile("Data/Game/Game.xml", &info)) {
-            tinyxml2::XMLDocument *doc = new tinyxml2::XMLDocument;
+const tinyxml2::XMLAttribute *findXMLAttribute(const tinyxml2::XMLElement *elementPtr, const char *name) { return elementPtr->FindAttribute(name); }
+const char *getXMLAttributeName(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->Name(); }
+int getXMLAttributeValueInt(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->IntValue(); }
+bool getXMLAttributeValueBool(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->BoolValue(); }
+const char *getXMLAttributeValueString(const tinyxml2::XMLAttribute *attributePtr) { return attributePtr->Value(); }
 
-            char *xmlData = new char[info.fileSize + 1];
-            FileRead(xmlData, info.fileSize);
-            xmlData[info.fileSize] = 0;
-
-            bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
-
-            if (success) {
-                const tinyxml2::XMLElement *gameElement  = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *titleElement = FirstXMLChildElement(doc, gameElement, "title");
-                if (titleElement) {
-                    const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(titleElement, "name");
-                    if (nameAttr)
-                        StrCopy(gameWindowText, GetXMLAttributeValueString(nameAttr));
-                }
-            }
-
-            delete[] xmlData;
-            delete doc;
-
-            CloseFile();
-        }
-    }
-    SetActiveMod(-1);
-}
 void RetroEngine::LoadXMLVariables()
 {
     FileInfo info;
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -700,27 +689,27 @@ void RetroEngine::LoadXMLVariables()
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement      = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *variablesElement = FirstXMLChildElement(doc, gameElement, "variables");
+                const tinyxml2::XMLElement *gameElement      = firstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *variablesElement = firstXMLChildElement(doc, gameElement, "variables");
                 if (variablesElement) {
-                    const tinyxml2::XMLElement *varElement = FirstXMLChildElement(doc, variablesElement, "variable");
+                    const tinyxml2::XMLElement *varElement = firstXMLChildElement(doc, variablesElement, "variable");
                     if (varElement) {
                         do {
-                            const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(varElement, "name");
+                            const tinyxml2::XMLAttribute *nameAttr = findXMLAttribute(varElement, "name");
                             const char *varName                    = "unknownVariable";
                             if (nameAttr)
-                                varName = GetXMLAttributeValueString(nameAttr);
+                                varName = getXMLAttributeValueString(nameAttr);
 
-                            const tinyxml2::XMLAttribute *valAttr = FindXMLAttribute(varElement, "value");
+                            const tinyxml2::XMLAttribute *valAttr = findXMLAttribute(varElement, "value");
                             int varValue                          = 0;
                             if (valAttr)
-                                varValue = GetXMLAttributeValueInt(valAttr);
+                                varValue = getXMLAttributeValueInt(valAttr);
 
                             StrCopy(globalVariableNames[globalVariablesCount], varName);
                             globalVariables[globalVariablesCount] = varValue;
                             globalVariablesCount++;
 
-                        } while ((varElement = NextXMLSiblingElement(doc, varElement, "variable")));
+                        } while ((varElement = nextXMLSiblingElement(doc, varElement, "variable")));
                     }
                 }
             }
@@ -737,6 +726,9 @@ void RetroEngine::LoadXMLPalettes()
 {
     FileInfo info;
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -751,77 +743,40 @@ void RetroEngine::LoadXMLPalettes()
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement    = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *paletteElement = FirstXMLChildElement(doc, gameElement, "palette");
+                const tinyxml2::XMLElement *gameElement    = firstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *paletteElement = firstXMLChildElement(doc, gameElement, "palette");
                 if (paletteElement) {
-                    for (const tinyxml2::XMLElement *clrElement = paletteElement->FirstChildElement("color"); clrElement;
-                         clrElement = clrElement->NextSiblingElement("color")) {
-                        const tinyxml2::XMLAttribute *bankAttr = clrElement->FindAttribute("bank");
-                        int clrBank = 0;
-                        if (bankAttr)
-                            clrBank = bankAttr->IntValue();
-
-                        const tinyxml2::XMLAttribute *indAttr = clrElement->FindAttribute("index");
-                        int clrInd = 0;
-                        if (indAttr)
-                            clrInd = indAttr->IntValue();
-
-                        const tinyxml2::XMLAttribute *rAttr = clrElement->FindAttribute("r");
-                        int clrR = 0;
-                        if (rAttr)
-                            clrR = rAttr->IntValue();
-
-                        const tinyxml2::XMLAttribute *gAttr = clrElement->FindAttribute("g");
-                        int clrG = 0;
-                        if (gAttr)
-                            clrG = gAttr->IntValue();
-
-                        const tinyxml2::XMLAttribute *bAttr = clrElement->FindAttribute("b");
-                        int clrB = 0;
-                        if (bAttr)
-                            clrB = bAttr->IntValue();
-
-                        SetPaletteEntry(clrBank, clrInd, clrR, clrG, clrB);
-                    }
-
-                    for (const tinyxml2::XMLElement *clrsElement = paletteElement->FirstChildElement("colors"); clrsElement;
-                         clrsElement = clrsElement->NextSiblingElement("colors")) {
-                        const tinyxml2::XMLAttribute *bankAttr = clrsElement->FindAttribute("bank");
-                        int bank = 0;
-                        if (bankAttr)
-                            bank = bankAttr->IntValue();
-
-                        const tinyxml2::XMLAttribute *indAttr = clrsElement->FindAttribute("start");
-                        int index = 0;
-                        if (indAttr)
-                            index = indAttr->IntValue();
-
-                        std::string text = clrsElement->GetText();
-                        // working: AABBFF #FFaaFF (12, 32, 34) (145 53 234)
-                        std::regex search(R"((?:#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2}))|(?:\((\d+),?\s*(\d+),?\s*(\d+)\)))",
-                                          std::regex_constants::icase | std::regex_constants::ECMAScript);
-                        std::smatch match;
-                        while (std::regex_search(text, match, search)) {
-                            int r, g, b;
-                            int base, start;
-                            if (match[1].matched) {
-                                // we have hex
-                                base  = 16;
-                                start = 1;
-                            }
-                            else {
-                                // triplet
-                                base  = 10;
-                                start = 4;
-                            }
-
-                            r = std::stoi(match[start + 0].str(), nullptr, base);
-                            g = std::stoi(match[start + 1].str(), nullptr, base);
-                            b = std::stoi(match[start + 2].str(), nullptr, base);
-
-                            SetPaletteEntry(bank, index++, r, g, b);
-                            text = match.suffix();
-                        }
+                    const tinyxml2::XMLElement *clrElement = firstXMLChildElement(doc, paletteElement, "color");
+                    if (clrElement) {
+                        do {
+                            const tinyxml2::XMLAttribute *bankAttr = findXMLAttribute(clrElement, "bank");
+                            int clrBank                            = 0;
+                            if (bankAttr)
+                                clrBank = getXMLAttributeValueInt(bankAttr);
+
+                            const tinyxml2::XMLAttribute *indAttr = findXMLAttribute(clrElement, "index");
+                            int clrInd                            = 0;
+                            if (indAttr)
+                                clrInd = getXMLAttributeValueInt(indAttr);
+
+                            const tinyxml2::XMLAttribute *rAttr = findXMLAttribute(clrElement, "r");
+                            int clrR                            = 0;
+                            if (rAttr)
+                                clrR = getXMLAttributeValueInt(rAttr);
+
+                            const tinyxml2::XMLAttribute *gAttr = findXMLAttribute(clrElement, "g");
+                            int clrG                            = 0;
+                            if (gAttr)
+                                clrG = getXMLAttributeValueInt(gAttr);
+
+                            const tinyxml2::XMLAttribute *bAttr = findXMLAttribute(clrElement, "b");
+                            int clrB                            = 0;
+                            if (bAttr)
+                                clrB = getXMLAttributeValueInt(bAttr);
+
+                            SetPaletteEntry(clrBank, clrInd, clrR, clrG, clrB);
+
+                        } while ((clrElement = nextXMLSiblingElement(doc, clrElement, "color")));
                     }
                 }
             }
@@ -840,6 +795,9 @@ void RetroEngine::LoadXMLObjects()
     modObjCount = 0;
 
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -854,30 +812,30 @@ void RetroEngine::LoadXMLObjects()
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement    = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *objectsElement = FirstXMLChildElement(doc, gameElement, "objects");
+                const tinyxml2::XMLElement *gameElement    = firstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *objectsElement = firstXMLChildElement(doc, gameElement, "objects");
                 if (objectsElement) {
-                    const tinyxml2::XMLElement *objElement = FirstXMLChildElement(doc, objectsElement, "object");
+                    const tinyxml2::XMLElement *objElement = firstXMLChildElement(doc, objectsElement, "object");
                     if (objElement) {
                         do {
-                            const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(objElement, "name");
+                            const tinyxml2::XMLAttribute *nameAttr = findXMLAttribute(objElement, "name");
                             const char *objName                    = "unknownObject";
                             if (nameAttr)
-                                objName = GetXMLAttributeValueString(nameAttr);
+                                objName = getXMLAttributeValueString(nameAttr);
 
-                            const tinyxml2::XMLAttribute *scrAttr = FindXMLAttribute(objElement, "script");
+                            const tinyxml2::XMLAttribute *scrAttr = findXMLAttribute(objElement, "script");
                             const char *objScript                 = "unknownObject.txt";
                             if (scrAttr)
-                                objScript = GetXMLAttributeValueString(scrAttr);
+                                objScript = getXMLAttributeValueString(scrAttr);
 
                             byte flags = 0;
 
                             // forces the object to be loaded, this means the object doesn't have to be and *SHOULD NOT* be in the stage object list
                             // if it is, it'll cause issues!!!!
-                            const tinyxml2::XMLAttribute *loadAttr = FindXMLAttribute(objElement, "forceLoad");
+                            const tinyxml2::XMLAttribute *loadAttr = findXMLAttribute(objElement, "forceLoad");
                             int objForceLoad                       = false;
                             if (loadAttr)
-                                objForceLoad = GetXMLAttributeValueBool(loadAttr);
+                                objForceLoad = getXMLAttributeValueBool(loadAttr);
 
                             flags |= (objForceLoad & 1);
 
@@ -886,12 +844,12 @@ void RetroEngine::LoadXMLObjects()
                             modScriptFlags[modObjCount] = flags;
                             modObjCount++;
 
-                        } while ((objElement = NextXMLSiblingElement(doc, objElement, "object")));
+                        } while ((objElement = nextXMLSiblingElement(doc, objElement, "object")));
                     }
                 }
             }
             else {
-                PrintLog("Failed to parse game.xml File!");
+                PrintLog("Failed to parse Game.xml File!");
             }
 
             delete[] xmlData;
@@ -907,6 +865,9 @@ void RetroEngine::LoadXMLSoundFX()
     FileInfo info;
     FileInfo infoStore;
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -921,21 +882,21 @@ void RetroEngine::LoadXMLSoundFX()
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement   = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *soundsElement = FirstXMLChildElement(doc, gameElement, "sounds");
+                const tinyxml2::XMLElement *gameElement   = firstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *soundsElement = firstXMLChildElement(doc, gameElement, "sounds");
                 if (soundsElement) {
-                    const tinyxml2::XMLElement *sfxElement = FirstXMLChildElement(doc, soundsElement, "soundfx");
+                    const tinyxml2::XMLElement *sfxElement = firstXMLChildElement(doc, soundsElement, "soundfx");
                     if (sfxElement) {
                         do {
-                            const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(sfxElement, "name");
+                            const tinyxml2::XMLAttribute *nameAttr = findXMLAttribute(sfxElement, "name");
                             const char *sfxName                    = "unknownSFX";
                             if (nameAttr)
-                                sfxName = GetXMLAttributeValueString(nameAttr);
+                                sfxName = getXMLAttributeValueString(nameAttr);
 
-                            const tinyxml2::XMLAttribute *valAttr = FindXMLAttribute(sfxElement, "path");
+                            const tinyxml2::XMLAttribute *valAttr = findXMLAttribute(sfxElement, "path");
                             const char *sfxPath                   = "unknownSFX.wav";
                             if (valAttr)
-                                sfxPath = GetXMLAttributeValueString(valAttr);
+                                sfxPath = getXMLAttributeValueString(valAttr);
 
                             SetSfxName(sfxName, globalSFXCount);
 
@@ -945,12 +906,12 @@ void RetroEngine::LoadXMLSoundFX()
                             SetFileInfo(&infoStore);
                             globalSFXCount++;
 
-                        } while ((sfxElement = NextXMLSiblingElement(doc, sfxElement, "soundfx")));
+                        } while ((sfxElement = nextXMLSiblingElement(doc, sfxElement, "soundfx")));
                     }
                 }
             }
             else {
-                PrintLog("Failed to parse game.xml File!");
+                PrintLog("Failed to parse Game.xml File!");
             }
 
             delete[] xmlData;
@@ -966,6 +927,9 @@ void RetroEngine::LoadXMLPlayers(TextMenu *menu)
     FileInfo info;
 
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -980,30 +944,28 @@ void RetroEngine::LoadXMLPlayers(TextMenu *menu)
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement    = FirstXMLChildElement(doc, nullptr, "game");
-                const tinyxml2::XMLElement *playersElement = FirstXMLChildElement(doc, gameElement, "players");
+                const tinyxml2::XMLElement *gameElement    = firstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *playersElement = firstXMLChildElement(doc, gameElement, "players");
                 if (playersElement) {
-                    const tinyxml2::XMLElement *plrElement = FirstXMLChildElement(doc, playersElement, "player");
+                    const tinyxml2::XMLElement *plrElement = firstXMLChildElement(doc, playersElement, "player");
                     if (plrElement) {
                         do {
-                            const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(plrElement, "name");
+                            const tinyxml2::XMLAttribute *nameAttr = findXMLAttribute(plrElement, "name");
                             const char *plrName                    = "unknownPlayer";
                             if (nameAttr)
-                                plrName = GetXMLAttributeValueString(nameAttr);
+                                plrName = getXMLAttributeValueString(nameAttr);
 
-                            if (playerCount >= PLAYER_COUNT)
-                                PrintLog("Failed to add dev menu character '%s' (max limit reached)", plrName);
-                            else if (menu)
+                            if (menu)
                                 AddTextMenuEntry(menu, plrName);
                             else
                                 StrCopy(playerNames[playerCount++], plrName);
 
-                        } while ((plrElement = NextXMLSiblingElement(doc, plrElement, "player")));
+                        } while ((plrElement = nextXMLSiblingElement(doc, plrElement, "player")));
                     }
                 }
             }
             else {
-                PrintLog("Failed to parse game.xml File!");
+                PrintLog("Failed to parse Game.xml File!");
             }
 
             delete[] xmlData;
@@ -1018,6 +980,9 @@ void RetroEngine::LoadXMLStages(TextMenu *menu, int listNo)
 {
     FileInfo info;
     for (int m = 0; m < (int)modList.size(); ++m) {
+	//We reversed the load order to fix a bug
+	//Flip yo for real
+	//for (int m = ((int)modList.size() - 1); m >= 0; --m) {
         if (!modList[m].active)
             continue;
 
@@ -1032,34 +997,34 @@ void RetroEngine::LoadXMLStages(TextMenu *menu, int listNo)
             bool success = doc->Parse(xmlData) == tinyxml2::XML_SUCCESS;
 
             if (success) {
-                const tinyxml2::XMLElement *gameElement = FirstXMLChildElement(doc, nullptr, "game");
+                const tinyxml2::XMLElement *gameElement = firstXMLChildElement(doc, nullptr, "game");
                 const char *elementNames[]              = { "presentationStages", "regularStages", "bonusStages", "specialStages" };
 
                 for (int l = 0; l < STAGELIST_MAX; ++l) {
-                    const tinyxml2::XMLElement *listElement = FirstXMLChildElement(doc, gameElement, elementNames[l]);
+                    const tinyxml2::XMLElement *listElement = firstXMLChildElement(doc, gameElement, elementNames[l]);
                     if (listElement) {
-                        const tinyxml2::XMLElement *stgElement = FirstXMLChildElement(doc, listElement, "stage");
+                        const tinyxml2::XMLElement *stgElement = firstXMLChildElement(doc, listElement, "stage");
                         if (stgElement) {
                             do {
-                                const tinyxml2::XMLAttribute *nameAttr = FindXMLAttribute(stgElement, "name");
+                                const tinyxml2::XMLAttribute *nameAttr = findXMLAttribute(stgElement, "name");
                                 const char *stgName                    = "unknownStage";
                                 if (nameAttr)
-                                    stgName = GetXMLAttributeValueString(nameAttr);
+                                    stgName = getXMLAttributeValueString(nameAttr);
 
-                                const tinyxml2::XMLAttribute *folderAttr = FindXMLAttribute(stgElement, "folder");
+                                const tinyxml2::XMLAttribute *folderAttr = findXMLAttribute(stgElement, "folder");
                                 const char *stgFolder                    = "unknownStageFolder";
-                                if (folderAttr)
-                                    stgFolder = GetXMLAttributeValueString(folderAttr);
+                                if (nameAttr)
+                                    stgFolder = getXMLAttributeValueString(folderAttr);
 
-                                const tinyxml2::XMLAttribute *idAttr = FindXMLAttribute(stgElement, "id");
+                                const tinyxml2::XMLAttribute *idAttr = findXMLAttribute(stgElement, "id");
                                 const char *stgID                    = "unknownStageID";
                                 if (idAttr)
-                                    stgID = GetXMLAttributeValueString(idAttr);
+                                    stgID = getXMLAttributeValueString(idAttr);
 
-                                const tinyxml2::XMLAttribute *highlightAttr = FindXMLAttribute(stgElement, "highlight");
+                                const tinyxml2::XMLAttribute *highlightAttr = findXMLAttribute(stgElement, "highlight");
                                 bool stgHighlighted                         = false;
                                 if (highlightAttr)
-                                    stgHighlighted = GetXMLAttributeValueBool(highlightAttr);
+                                    stgHighlighted = getXMLAttributeValueBool(highlightAttr);
 
                                 if (menu) {
                                     if (listNo == 3 || listNo == 4) {
@@ -1082,13 +1047,13 @@ void RetroEngine::LoadXMLStages(TextMenu *menu, int listNo)
                                     stageListCount[l]++;
                                 }
 
-                            } while ((stgElement = NextXMLSiblingElement(doc, stgElement, "stage")));
+                            } while ((stgElement = nextXMLSiblingElement(doc, stgElement, "stage")));
                         }
                     }
                 }
             }
             else {
-                PrintLog("Failed to parse game.xml File!");
+                PrintLog("Failed to parse Game.xml File!");
             }
 
             delete[] xmlData;
@@ -1181,13 +1146,6 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
         // Read Player Names
         byte plrCount = 0;
         FileRead(&plrCount, 1);
-#if RETRO_USE_MOD_LOADER
-        // Check for max player limit
-        if (plrCount >= PLAYER_COUNT) {
-            PrintLog("WARNING: GameConfig attempted to exceed the player limit, truncating to supported limit");
-            plrCount = PLAYER_COUNT;
-        }
-#endif
         for (byte p = 0; p < plrCount; ++p) {
             FileRead(&fileBuffer, 1);
             FileRead(&strBuffer, fileBuffer);
@@ -1234,24 +1192,19 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
         }
 
         CloseFile();
-
 #if RETRO_USE_MOD_LOADER
-        LoadXMLWindowText();
         LoadXMLVariables();
         LoadXMLPalettes();
         LoadXMLObjects();
         LoadXMLPlayers(NULL);
         LoadXMLStages(NULL, 0);
 
-        SetGlobalVariableByName("options.devMenuFlag", devMenu ? 1 : 0);
-        SetGlobalVariableByName("engine.standalone", 1);
+        SetGlobalVariableByName("options.devMenuFlag", false);
+        if (Engine.devMenu)
+            SetGlobalVariableByName("options.devMenuFlag", true);
 #endif
     }
 
-#if RETRO_REV03
-    SetGlobalVariableByName("game.hasPlusDLC", !RSDK_AUTOBUILD);
-#endif
-
     // These need to be set every time its reloaded
     nativeFunctionCount = 0;
     AddNativeFunction("SetAchievement", SetAchievement);
@@ -1267,19 +1220,9 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
     AddNativeFunction("ReceiveValue", ReceiveValue);
     AddNativeFunction("TransmitGlobal", TransmitGlobal);
     AddNativeFunction("ShowPromoPopup", ShowPromoPopup);
-
-    // Introduced in the Sega Forever versions of S1 (3.9.0) and S2 (1.7.0)
-    AddNativeFunction("NativePlayerWaitingAds", NativePlayerWaitingAds);
-    AddNativeFunction("NativeWaterPlayerWaitingAds", NativeWaterPlayerWaitingAds);
-
-#if RETRO_REV03
-    AddNativeFunction("NotifyCallback", NotifyCallback);
-#endif
-
 #if RETRO_USE_NETWORKING
     AddNativeFunction("SetNetworkGameName", SetNetworkGameName);
 #endif
-
 #if RETRO_USE_MOD_LOADER
     AddNativeFunction("ExitGame", ExitGame);
     AddNativeFunction("FileExists", FileExists);
@@ -1291,19 +1234,21 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
     AddNativeFunction("GetAchievement", GetAchievement);
     AddNativeFunction("GetAchievementName", GetAchievementName);
     AddNativeFunction("GetAchievementDescription", GetAchievementDescription);
-    AddNativeFunction("GetScreenWidth", GetScreenWidth);
+	AddNativeFunction("GetScreenWidth", GetScreenWidth);
     AddNativeFunction("SetScreenWidth", SetScreenWidth);
-    AddNativeFunction("GetWindowScale", GetWindowScale);
+	AddNativeFunction("GetWindowScale", GetWindowScale);
     AddNativeFunction("SetWindowScale", SetWindowScale);
     AddNativeFunction("GetWindowScaleMode", GetWindowScaleMode);
     AddNativeFunction("SetWindowScaleMode", SetWindowScaleMode);
-    AddNativeFunction("GetWindowFullScreen", GetWindowFullScreen);
+	AddNativeFunction("GetWindowFullScreen", GetWindowFullScreen);
     AddNativeFunction("SetWindowFullScreen", SetWindowFullScreen);
-    AddNativeFunction("GetWindowBorderless", GetWindowBorderless);
+	AddNativeFunction("GetWindowBorderless", GetWindowBorderless);
     AddNativeFunction("SetWindowBorderless", SetWindowBorderless);
-    AddNativeFunction("GetWindowVSync", GetWindowVSync);
+	AddNativeFunction("GetWindowVSync", GetWindowVSync);
     AddNativeFunction("SetWindowVSync", SetWindowVSync);
-    AddNativeFunction("ApplyWindowChanges", ApplyWindowChanges); // Refresh window after changing window options
+	AddNativeFunction("GetFrameRate", GetFrameRate);
+    AddNativeFunction("SetFrameRate", SetFrameRate);
+    AddNativeFunction("ApplyWindowChanges", ApplyWindowChanges); //todo: this prolly tbh
     AddNativeFunction("GetModCount", GetModCount);
     AddNativeFunction("GetModName", GetModName);
     AddNativeFunction("GetModDescription", GetModDescription);
@@ -1311,7 +1256,7 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
     AddNativeFunction("GetModVersion", GetModVersion);
     AddNativeFunction("GetModActive", GetModActive);
     AddNativeFunction("SetModActive", SetModActive);
-    AddNativeFunction("MoveMod", MoveMod);
+	AddNativeFunction("MoveMod", MoveMod);
     AddNativeFunction("RefreshEngine", RefreshEngine); // Reload engine after changing mod status
 #endif
 
@@ -1324,10 +1269,6 @@ bool RetroEngine::LoadGameConfig(const char *filePath)
         startList_Game  = STAGELIST_BONUS;
         startStage_Game = 0xFE;
     }
-
-#if RETRO_REV03
-    Engine.usingOrigins = GetGlobalVariableID("game.playMode") != 0xFF;
-#endif
 #endif
 
     return loaded;
diff --git a/RSDKv4/RetroEngine.hpp b/RSDKv4/RetroEngine.hpp
index 803ae1f..7c24cbc 100644
--- a/RSDKv4/RetroEngine.hpp
+++ b/RSDKv4/RetroEngine.hpp
@@ -6,22 +6,10 @@
 
 // Setting this to true removes (almost) ALL changes from the original code, the trade off is that a playable game cannot be built, it is advised to
 // be set to true only for preservation purposes
-#ifndef RETRO_USE_ORIGINAL_CODE
 #define RETRO_USE_ORIGINAL_CODE (0)
-#endif
 
-#ifndef RETRO_USE_MOD_LOADER
 #define RETRO_USE_MOD_LOADER (!RETRO_USE_ORIGINAL_CODE && 1)
-#endif
-
-#ifndef RETRO_USE_NETWORKING
 #define RETRO_USE_NETWORKING (!RETRO_USE_ORIGINAL_CODE && 1)
-#endif
-
-// Forces all DLC flags to be disabled, this should be enabled in any public releases
-#ifndef RSDK_AUTOBUILD
-#define RSDK_AUTOBUILD (0)
-#endif
 
 // ================
 // STANDARD LIBS
@@ -29,9 +17,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <cmath>
-#if RETRO_USE_MOD_LOADER
-#include <regex>
-#endif
 
 // ================
 // STANDARD TYPES
@@ -53,6 +38,7 @@ typedef unsigned int uint;
 // Custom Platforms start here
 #define RETRO_UWP   (7)
 #define RETRO_LINUX (8)
+#define RETRO_SWITCH (9)
 
 // Platform types (Game manages platform-specific code such as HUD position using this rather than the above)
 #define RETRO_STANDARD (0)
@@ -83,6 +69,9 @@ typedef unsigned int uint;
 #define RETRO_PLATFORM   (RETRO_OSX)
 #define RETRO_DEVICETYPE (RETRO_STANDARD)
 #endif
+#elif defined __SWITCH__
+#define RETRO_PLATFORM   (RETRO_SWITCH)
+#define RETRO_DEVICETYPE (RETRO_STANDARD)
 #elif defined __ANDROID__
 #define RETRO_PLATFORM   (RETRO_ANDROID)
 #define RETRO_DEVICETYPE (RETRO_MOBILE)
@@ -92,11 +81,11 @@ typedef unsigned int uint;
 #define RETRO_DEVICETYPE (RETRO_STANDARD)
 #else
 //#error "No Platform was defined"
-#define RETRO_PLATFORM   (RETRO_LINUX)
+#define RETRO_PLATFORM   (RETRO_WIN)
 #define RETRO_DEVICETYPE (RETRO_STANDARD)
 #endif
 
-#define DEFAULT_SCREEN_XSIZE 424
+#define DEFAULT_SCREEN_XSIZE 426
 #define DEFAULT_FULLSCREEN   false
 #define RETRO_USING_MOUSE
 #define RETRO_USING_TOUCH
@@ -105,19 +94,10 @@ typedef unsigned int uint;
 #define BASE_PATH ""
 #endif
 
-#if !defined(RETRO_USE_SDL2) && !defined(RETRO_USE_SDL1)
-#define RETRO_USE_SDL2 (1)
-#endif
-
 #if RETRO_PLATFORM == RETRO_WIN || RETRO_PLATFORM == RETRO_OSX || RETRO_PLATFORM == RETRO_LINUX || RETRO_PLATFORM == RETRO_UWP                       \
-    || RETRO_PLATFORM == RETRO_ANDROID
-#ifdef RETRO_USE_SDL2
+    || RETRO_PLATFORM == RETRO_ANDROID || RETRO_PLATFORM == RETRO_SWITCH
 #define RETRO_USING_SDL1 (0)
 #define RETRO_USING_SDL2 (1)
-#elif defined(RETRO_USE_SDL1)
-#define RETRO_USING_SDL1 (1)
-#define RETRO_USING_SDL2 (0)
-#endif
 #else // Since its an else & not an elif these platforms probably aren't supported yet
 #define RETRO_USING_SDL1 (0)
 #define RETRO_USING_SDL2 (0)
@@ -131,23 +111,24 @@ typedef unsigned int uint;
 #define RETRO_GAMEPLATFORM (RETRO_STANDARD)
 #endif
 
-#define RETRO_SW_RENDER (0)
-#define RETRO_HW_RENDER (1)
+#define RETRO_SW_RENDER  (0)
+#define RETRO_HW_RENDER  (1)
+#define RETRO_RENDERTYPE (RETRO_SW_RENDER)
 
 #ifdef USE_SW_REN
-#define RETRO_RENDERTYPE (RETRO_SW_RENDER)
-#elif defined(USE_HW_REN)
-#define RETRO_RENDERTYPE (RETRO_HW_RENDER)
-#elif !defined(RETRO_RENDERTYPE)
+#undef RETRO_RENDERTYPE
 #define RETRO_RENDERTYPE (RETRO_SW_RENDER)
 #endif
 
-#ifndef RETRO_USING_OPENGL
-#define RETRO_USING_OPENGL (1)
+#ifdef USE_HW_REN
+#undef RETRO_RENDERTYPE
+#define RETRO_RENDERTYPE (RETRO_HW_RENDER)
 #endif
 
+#define RETRO_USING_OPENGL (0)
+
 #define RETRO_SOFTWARE_RENDER (RETRO_RENDERTYPE == RETRO_SW_RENDER)
-//#define RETRO_HARDWARE_RENDER (RETRO_RENDERTYPE == RETRO_HW_RENDER)
+#define RETRO_HARDWARE_RENDER (RETRO_RENDERTYPE == RETRO_HW_RENDER)
 
 #if RETRO_USING_OPENGL
 #if RETRO_PLATFORM == RETRO_ANDROID
@@ -197,6 +178,11 @@ typedef unsigned int uint;
 #define GL_FRAMEBUFFER         GL_FRAMEBUFFER_EXT
 #define GL_COLOR_ATTACHMENT0   GL_COLOR_ATTACHMENT0_EXT
 #define GL_FRAMEBUFFER_BINDING GL_FRAMEBUFFER_BINDING_EXT
+#elif RETRO_PLATFORM == RETRO_SWITCH
+#include <GLES/gl.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <glad/glad.h>  // OpenGL loader
 #else
 #include <GL/glew.h>
 #endif
@@ -214,28 +200,31 @@ typedef unsigned int uint;
 #define RETRO_GAMEPLATFORMID (RETRO_WIN)
 #elif RETRO_PLATFORM == RETRO_UWP
 #define RETRO_GAMEPLATFORMID (UAP_GetRetroGamePlatformId())
+#elif RETRO_PLATFORM == RETRO_SWITCH
+#define RETRO_GAMEPLATFORMID (RETRO_SWITCH)
 #else
 #error Unspecified RETRO_GAMEPLATFORMID
 #endif
 
 #endif
 
-// Determines which revision to use (see defines below for specifics). Datafiles from REV00 and REV01 builds will not work on later revisions and vice versa.
-#ifndef RSDK_REVISION
-#define RSDK_REVISION (3)
-#endif
+// Timeline:
+// 0 = S1 release RSDKv4 version
+// 1 = S2 release RSDKv4 version
+// 2 = S3 POC RSDKv4 version (I have no idea how we have this but woohoo apparently)
+#define RSDK_REVISION (2)
 
-// Revision from early versions of Sonic 1
+// reverts opcode list back to how it was in earliest S1 builds, fixes bugs on some datafiles
+// generally advised to keep this set to 0
 #define RETRO_REV00 (RSDK_REVISION == 0)
 
-// Revision from early versions of Sonic 2
-#define RETRO_REV01 (RSDK_REVISION >= 1)
-
-// Revision from the S3&K POC, this is also used in the Sega Forever versions of S1 & S2
-#define RETRO_REV02 (RSDK_REVISION >= 2)
+// reverts opcode list back to how it was in earliest S2 builds, fixes bugs on some datafiles
+// generally advised to keep this set to 0
+#define RETRO_REV01 (RSDK_REVISION == 1)
 
-// Revision included as part of RSDKv5U (Sonic Origins)
-#define RETRO_REV03 (RSDK_REVISION >= 3)
+// the default, uses the S3 POC opcode list, which is the latest version of RSDKv4
+// generally advised to keep this set to 1
+#define RETRO_REV02 (RSDK_REVISION == 2)
 
 enum RetroLanguages {
     RETRO_EN = 0,
@@ -271,6 +260,7 @@ enum RetroStates {
     ENGINE_EXITPAUSE   = 6,
     ENGINE_ENDGAME     = 7,
     ENGINE_RESETGAME   = 8,
+    ENGINE_VIDEOWAIT   = 9,
 
 #if !RETRO_USE_ORIGINAL_CODE && RETRO_USE_NETWORKING
     // Custom GameModes (required to make some features work)
@@ -342,6 +332,7 @@ extern bool engineDebugMode;
 #include "Userdata.hpp"
 #include "Debug.hpp"
 #include "ModAPI.hpp"
+#include "Video.hpp"
 
 // Native Entities
 #include "NativeObjects.hpp"
@@ -366,9 +357,6 @@ public:
 #endif
     bool usingDataFile = false;
     bool usingBytecode = false;
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-    bool usingOrigins = false;
-#endif
 
     char dataFile[RETRO_PACKFILE_COUNT][0x80];
 
@@ -430,7 +418,6 @@ public:
 
     bool LoadGameConfig(const char *filepath);
 #if RETRO_USE_MOD_LOADER
-    void LoadXMLWindowText();
     void LoadXMLVariables();
     void LoadXMLPalettes();
     void LoadXMLObjects();
@@ -441,16 +428,9 @@ public:
 
     char gameWindowText[0x40];
     char gameDescriptionText[0x100];
-#ifdef DECOMP_VERSION
-    const char *gameVersion = DECOMP_VERSION;
-#else
-    const char *gameVersion  = "1.3.3";
-#endif
+    const char *gameVersion  = "v4";
     const char *gamePlatform = nullptr;
 
-    int gameTypeID       = 0;
-    const char *releaseType = "USE_STANDALONE";
-
 #if RETRO_RENDERTYPE == RETRO_SW_RENDER
     const char *gameRenderType = "SW_RENDERING";
 #elif RETRO_RENDERTYPE == RETRO_HW_RENDER
@@ -482,7 +462,7 @@ public:
 
     bool startFullScreen  = false; // if should start as fullscreen
     bool borderless       = false;
-    bool vsync            = false;
+    bool vsync            = true;
     int scalingMode       = 0;
     int windowScale       = 2;
     int refreshRate       = 60; // user-picked screen update rate
@@ -504,6 +484,7 @@ public:
 #if RETRO_SOFTWARE_RENDER
     SDL_Texture *screenBuffer   = nullptr;
     SDL_Texture *screenBuffer2x = nullptr;
+    SDL_Texture *videoBuffer = nullptr;
 #endif // RETRO_SOFTWARE_RENDERER
 #endif
 
@@ -519,6 +500,7 @@ public:
 
     SDL_Surface *screenBuffer   = nullptr;
     SDL_Surface *screenBuffer2x = nullptr;
+    SDL_Surface *videoBuffer = nullptr;
 
     SDL_Event sdlEvents;
 #endif // RETRO_USING_SDL1
diff --git a/RSDKv4/Scene.cpp b/RSDKv4/Scene.cpp
index a450c82..d0f72de 100644
--- a/RSDKv4/Scene.cpp
+++ b/RSDKv4/Scene.cpp
@@ -131,6 +131,8 @@ void ProcessStage(void)
 
     switch (stageMode) {
         case STAGEMODE_LOAD: // Startup
+			ClearGraphicsData();
+			ClearAnimationData();
             SetActivePalette(0, 0, 256);
             gameMenu[0].visibleRowOffset = 0;
             gameMenu[1].alignment        = 0;
@@ -158,14 +160,6 @@ void ProcessStage(void)
             stageMinutes                 = 0;
             stageMode                    = STAGEMODE_NORMAL;
 
-#if RSDK_AUTOBUILD
-            // Prevent playing as Amy if on autobuilds
-            if (GetGlobalVariableByName("PLAYER_AMY") && playerListPos == GetGlobalVariableByName("PLAYER_AMY"))
-                playerListPos = 0;
-            else if (GetGlobalVariableByName("PLAYER_AMY_TAILS") && playerListPos == GetGlobalVariableByName("PLAYER_AMY_TAILS"))
-                playerListPos = 0;
-#endif
-
 #if RETRO_USE_MOD_LOADER
             for (int m = 0; m < modList.size(); ++m) ScanModFolder(&modList[m]);
 #endif
@@ -218,24 +212,25 @@ void ProcessStage(void)
         case STAGEMODE_NORMAL:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
-            if (pauseEnabled && keyPress.start) {
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
+			/*
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_NORMAL_STEP;
                 PauseSound();
             }
-
+			*/
+			
             if (timeEnabled) {
                 if (++frameCounter == 60) {
                     frameCounter = 0;
                     if (++stageSeconds > 59) {
                         stageSeconds = 0;
-                        if (++stageMinutes > 59)
-                            stageMinutes = 0;
+                        ++stageMinutes;
                     }
                 }
                 stageMilliseconds = 100 * frameCounter / 60;
@@ -270,18 +265,20 @@ void ProcessStage(void)
         case STAGEMODE_PAUSED:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
-            if (pauseEnabled && keyPress.start) {
+			/*
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_PAUSED_STEP;
                 PauseSound();
             }
-
+			*/
+			
             // Update
             ProcessPausedObjects();
 
@@ -298,13 +295,6 @@ void ProcessStage(void)
             DrawObjectList(3);
             DrawObjectList(4);
             DrawObjectList(5);
-#if RETRO_REV03
-#if !RETRO_USE_ORIGINAL_CODE
-            // Hacky fix for Tails Object not working properly in special stages on non-Origins bytecode
-            if (forceUseScripts || Engine.usingOrigins)
-#endif
-                DrawObjectList(7);
-#endif
             DrawObjectList(6);
 
 #if !RETRO_USE_ORIGINAL_CODE
@@ -315,12 +305,12 @@ void ProcessStage(void)
         case STAGEMODE_FROZEN:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
             // Update
             ProcessFrozenObjects();
@@ -348,48 +338,51 @@ void ProcessStage(void)
         case STAGEMODE_2P:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
-            if (pauseEnabled && keyPress.start) {
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
+			/*
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_2P_STEP;
                 PauseSound();
             }
+			*/
 
-            if (timeEnabled) {
-                if (++frameCounter == 60) {
-                    frameCounter = 0;
-                    if (++stageSeconds > 59) {
-                        stageSeconds = 0;
-                        if (++stageMinutes > 59)
-                            stageMinutes = 0;
+            if (!waitForVerify) {
+                if (timeEnabled) {
+                    if (++frameCounter == 60) {
+                        frameCounter = 0;
+                        if (++stageSeconds > 59) {
+                            stageSeconds = 0;
+                            ++stageMinutes;
+                        }
                     }
+                    stageMilliseconds = 100 * frameCounter / 60;
+                }
+                else {
+                    frameCounter = 60 * stageMilliseconds / 100;
                 }
-                stageMilliseconds = 100 * frameCounter / 60;
-            }
-            else {
-                frameCounter = 60 * stageMilliseconds / 100;
-            }
 
-            // Update
-            Process2PObjects();
+                // Update
+                Process2PObjects();
 
-            if (cameraTarget > -1) {
-                if (cameraEnabled == 1) {
-                    switch (cameraStyle) {
-                        case CAMERASTYLE_FOLLOW: SetPlayerScreenPosition(&objectEntityList[cameraTarget]); break;
-                        case CAMERASTYLE_EXTENDED:
-                        case CAMERASTYLE_EXTENDED_OFFSET_L:
-                        case CAMERASTYLE_EXTENDED_OFFSET_R: SetPlayerScreenPositionCDStyle(&objectEntityList[cameraTarget]); break;
-                        case CAMERASTYLE_HLOCKED: SetPlayerHLockedScreenPosition(&objectEntityList[cameraTarget]); break;
-                        default: break;
+                if (cameraTarget > -1) {
+                    if (cameraEnabled == 1) {
+                        switch (cameraStyle) {
+                            case CAMERASTYLE_FOLLOW: SetPlayerScreenPosition(&objectEntityList[cameraTarget]); break;
+                            case CAMERASTYLE_EXTENDED:
+                            case CAMERASTYLE_EXTENDED_OFFSET_L:
+                            case CAMERASTYLE_EXTENDED_OFFSET_R: SetPlayerScreenPositionCDStyle(&objectEntityList[cameraTarget]); break;
+                            case CAMERASTYLE_HLOCKED: SetPlayerHLockedScreenPosition(&objectEntityList[cameraTarget]); break;
+                            default: break;
+                        }
+                    }
+                    else {
+                        SetPlayerLockedScreenPosition(&objectEntityList[cameraTarget]);
                     }
-                }
-                else {
-                    SetPlayerLockedScreenPosition(&objectEntityList[cameraTarget]);
                 }
             }
 
@@ -401,23 +394,22 @@ void ProcessStage(void)
         case STAGEMODE_NORMAL_STEP:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
-            if (keyPress.C) {
-                keyPress.C = false;
+            if (inputPress.C) {
+                inputPress.C = false;
 
                 if (timeEnabled) {
                     if (++frameCounter == 60) {
                         frameCounter = 0;
                         if (++stageSeconds > 59) {
                             stageSeconds = 0;
-                            if (++stageMinutes > 59)
-                                stageMinutes = 0;
+                            ++stageMinutes;
                         }
                     }
                     stageMilliseconds = 100 * frameCounter / 60;
@@ -447,7 +439,7 @@ void ProcessStage(void)
                 ProcessParallaxAutoScroll();
             }
 
-            if (pauseEnabled && keyPress.start) {
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_NORMAL;
                 ResumeSound();
             }
@@ -456,14 +448,14 @@ void ProcessStage(void)
         case STAGEMODE_PAUSED_STEP:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
-            if (keyPress.C) {
+            if (inputPress.C) {
 #if RETRO_HARDWARE_RENDER
                 gfxIndexSize        = 0;
                 gfxVertexSize       = 0;
@@ -471,7 +463,7 @@ void ProcessStage(void)
                 gfxVertexSizeOpaque = 0;
 #endif
 
-                keyPress.C = false;
+                inputPress.C = false;
                 ProcessPausedObjects();
                 DrawObjectList(0);
                 DrawObjectList(1);
@@ -479,13 +471,6 @@ void ProcessStage(void)
                 DrawObjectList(3);
                 DrawObjectList(4);
                 DrawObjectList(5);
-#if RETRO_REV03
-#if !RETRO_USE_ORIGINAL_CODE
-                // Hacky fix for Tails Object not working properly in special stages on non-Origins bytecode
-                if (forceUseScripts || Engine.usingOrigins)
-#endif
-                    DrawObjectList(7);
-#endif
                 DrawObjectList(6);
 
 #if !RETRO_USE_ORIGINAL_CODE
@@ -493,7 +478,7 @@ void ProcessStage(void)
 #endif
             }
 
-            if (pauseEnabled && keyPress.start) {
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_PAUSED;
                 ResumeSound();
             }
@@ -502,15 +487,15 @@ void ProcessStage(void)
         case STAGEMODE_FROZEN_STEP:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
 
-            if (keyPress.C) {
-                keyPress.C = false;
+            if (inputPress.C) {
+                inputPress.C = false;
 
                 // Update
                 ProcessFrozenObjects();
@@ -533,7 +518,7 @@ void ProcessStage(void)
 
                 DrawStageGFX();
             }
-            if (pauseEnabled && keyPress.start) {
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_FROZEN;
                 ResumeSound();
             }
@@ -543,22 +528,21 @@ void ProcessStage(void)
         case STAGEMODE_2P_STEP:
             drawStageGFXHQ = false;
             if (fadeMode > 0)
-                fadeMode--;
+                fadeMode = 0;
 
             lastXSize = -1;
             lastYSize = -1;
-            CheckKeyDown(&keyDown);
-            CheckKeyPress(&keyPress);
-            if (keyPress.C) {
-                keyPress.C = false;
+            CheckKeyDown(&inputDown);
+            CheckKeyPress(&inputPress);
+            if (inputPress.C) {
+                inputPress.C = false;
 
                 if (timeEnabled) {
                     if (++frameCounter == 60) {
                         frameCounter = 0;
                         if (++stageSeconds > 59) {
                             stageSeconds = 0;
-                            if (++stageMinutes > 59)
-                                stageMinutes = 0;
+                            ++stageMinutes;
                         }
                     }
                     stageMilliseconds = 100 * frameCounter / 60;
@@ -590,7 +574,7 @@ void ProcessStage(void)
                 ProcessParallaxAutoScroll();
             }
 
-            if (pauseEnabled && keyPress.start) {
+            if (pauseEnabled && inputPress.start) {
                 stageMode = STAGEMODE_2P;
                 ResumeSound();
             }
@@ -633,7 +617,7 @@ void LoadStageFiles(void)
             CloseFile();
         }
 
-        if (loadGlobalScripts && LoadFile("Data/Game/GameConfig.bin", &info)) {
+        if (LoadFile("Data/Game/GameConfig.bin", &info)) {
             FileRead(&fileBuffer, 1);
             FileRead(&strBuffer, fileBuffer);
             FileRead(&fileBuffer, 1);
@@ -645,82 +629,86 @@ void LoadStageFiles(void)
                 SetPaletteEntry(-1, c, buf[0], buf[1], buf[2]);
             }
 
-            byte globalObjectCount = 0;
-            FileRead(&globalObjectCount, 1);
-            for (byte i = 0; i < globalObjectCount; ++i) {
-                FileRead(&fileBuffer2, 1);
-                FileRead(strBuffer, fileBuffer2);
-                strBuffer[fileBuffer2] = 0;
-                SetObjectTypeName(strBuffer, scriptID + i);
-            }
+			if (loadGlobalScripts) {
+				byte globalObjectCount = 0;
+				FileRead(&globalObjectCount, 1);
+				for (byte i = 0; i < globalObjectCount; ++i) {
+					FileRead(&fileBuffer2, 1);
+					FileRead(strBuffer, fileBuffer2);
+					strBuffer[fileBuffer2] = 0;
+					SetObjectTypeName(strBuffer, scriptID + i);
+				}
 
 #if RETRO_USE_MOD_LOADER && RETRO_USE_COMPILER
-            for (byte i = 0; i < modObjCount && loadGlobalScripts; ++i) {
-                SetObjectTypeName(modTypeNames[i], globalObjectCount + i + 1);
-            }
+				for (byte i = 0; i < modObjCount && loadGlobalScripts; ++i) {
+					SetObjectTypeName(modTypeNames[i], globalObjectCount + i + 1);
+				}
 #endif
 
 #if RETRO_USE_COMPILER
 #if !RETRO_USE_ORIGINAL_CODE
-            bool bytecodeExists = false;
-            FileInfo bytecodeInfo;
-            GetFileInfo(&bytecodeInfo);
-            CloseFile();
-            if (LoadFile("Bytecode/GlobalCode.bin", &info)) {
-                bytecodeExists = true;
-                CloseFile();
-            }
-            SetFileInfo(&bytecodeInfo);
-
-            if (bytecodeExists && !forceUseScripts) {
+				bool bytecodeExists = false;
+				FileInfo bytecodeInfo;
+				GetFileInfo(&bytecodeInfo);
+				CloseFile();
+				if (LoadFile("Bytecode/GlobalCode.bin", &info)) {
+					bytecodeExists = true;
+					CloseFile();
+				}
+				SetFileInfo(&bytecodeInfo);
+
+				if (bytecodeExists && !forceUseScripts) {
 #else
-            if (Engine.usingBytecode) {
+				if (Engine.usingBytecode) {
 #endif
-                GetFileInfo(&infoStore);
-                CloseFile();
-                LoadBytecode(4, scriptID);
-                scriptID += globalObjectCount;
-                SetFileInfo(&infoStore);
-            }
-            else {
-                for (byte i = 0; i < globalObjectCount; ++i) {
-                    FileRead(&fileBuffer2, 1);
-                    FileRead(strBuffer, fileBuffer2);
-                    strBuffer[fileBuffer2] = 0;
-                    GetFileInfo(&infoStore);
-                    CloseFile();
-                    ParseScriptFile(strBuffer, scriptID++);
-                    SetFileInfo(&infoStore);
-                    if (Engine.gameMode == ENGINE_SCRIPTERROR)
-                        return;
-                }
-            }
+					GetFileInfo(&infoStore);
+					CloseFile();
+					LoadBytecode(4, scriptID);
+					scriptID += globalObjectCount;
+					SetFileInfo(&infoStore);
+				}
+				else {
+					for (byte i = 0; i < globalObjectCount; ++i) {
+						FileRead(&fileBuffer2, 1);
+						FileRead(strBuffer, fileBuffer2);
+						strBuffer[fileBuffer2] = 0;
+						GetFileInfo(&infoStore);
+						CloseFile();
+						ParseScriptFile(strBuffer, scriptID++);
+						SetFileInfo(&infoStore);
+						if (Engine.gameMode == ENGINE_SCRIPTERROR)
+							return;
+					}
+				}
 #else
-            GetFileInfo(&infoStore);
-            CloseFile();
-            LoadBytecode(4, scriptID);
-            scriptID += globalObjectCount;
-            SetFileInfo(&infoStore);
+				GetFileInfo(&infoStore);
+				CloseFile();
+				LoadBytecode(4, scriptID);
+				scriptID += globalObjectCount;
+				SetFileInfo(&infoStore);
 #endif
-            CloseFile();
+				CloseFile();
 
 #if RETRO_USE_MOD_LOADER
-            Engine.LoadXMLPalettes();
+				Engine.LoadXMLPalettes();
 #endif
 
 #if RETRO_USE_MOD_LOADER && RETRO_USE_COMPILER
-            globalObjCount = globalObjectCount;
-            for (byte i = 0; i < modObjCount && loadGlobalScripts; ++i) {
-                SetObjectTypeName(modTypeNames[i], scriptID);
-
-                GetFileInfo(&infoStore);
-                CloseFile();
-                ParseScriptFile(modScriptPaths[i], scriptID++);
-                SetFileInfo(&infoStore);
-                if (Engine.gameMode == ENGINE_SCRIPTERROR)
-                    return;
-            }
+				globalObjCount = globalObjectCount;
+				for (byte i = 0; i < modObjCount && loadGlobalScripts; ++i) {
+					SetObjectTypeName(modTypeNames[i], scriptID);
+
+					//SetFileInfo here was causing a crash when XML mods were mixed with non XML mods
+					//so GET IT THE FUCK OUTTA HERE
+					//GetFileInfo(&infoStore);
+					CloseFile();
+					ParseScriptFile(modScriptPaths[i], scriptID++);
+					//SetFileInfo(&infoStore);
+					if (Engine.gameMode == ENGINE_SCRIPTERROR)
+						return;
+				}
 #endif
+			}
         }
 
         if (LoadStageFile("StageConfig.bin", stageListPosition, &info)) {
diff --git a/RSDKv4/Scene3D.cpp b/RSDKv4/Scene3D.cpp
index ba88a46..ced3208 100644
--- a/RSDKv4/Scene3D.cpp
+++ b/RSDKv4/Scene3D.cpp
@@ -492,16 +492,16 @@ void Draw3DScene(int spriteSheetID)
                     SpriteFrame *frame       = &scriptFrames[scriptInfo->frameListOffset + vertexBuffer[face->b].u];
 
                     switch (vertexBuffer[face->a].v) {
-                        case FX_SCALE:
+                        case D_SCALE:
                             DrawSpriteScaled(vertexBuffer[face->b].v, xpos, ypos, -frame->pivotX, -frame->pivotY, vertexBuffer[face->c].u,
                                              vertexBuffer[face->c].u, frame->width, frame->height, frame->sprX, frame->sprY,
                                              scriptInfo->spriteSheetID);
                             break;
-                        case FX_ROTATE:
+                        case D_ROTATE:
                             DrawSpriteRotated(vertexBuffer[face->b].v, xpos, ypos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY,
                                               frame->width, frame->height, vertexBuffer[face->c].v, scriptInfo->spriteSheetID);
                             break;
-                        case FX_ROTOZOOM:
+                        case D_ROTOZOOM:
                             DrawSpriteRotozoom(vertexBuffer[face->b].v, xpos, ypos, -frame->pivotX, -frame->pivotY, frame->sprX, frame->sprY,
                                                frame->width, frame->height, vertexBuffer[face->c].v, vertexBuffer[face->c].u,
                                                scriptInfo->spriteSheetID);
diff --git a/RSDKv4/Script.cpp b/RSDKv4/Script.cpp
index 71e569f..ec188f3 100644
--- a/RSDKv4/Script.cpp
+++ b/RSDKv4/Script.cpp
@@ -1,43 +1,58 @@
 #include "RetroEngine.hpp"
 #include <cmath>
 
+ObjectScript objectScriptList[OBJECT_COUNT];
+ScriptPtr functionScriptList[FUNCTION_COUNT];
+
+int scriptData[SCRIPTDATA_COUNT];
+int jumpTableData[JUMPTABLE_COUNT];
+int jumpTableStack[JUMPSTACK_COUNT];
+int functionStack[FUNCSTACK_COUNT];
+int foreachStack[FORSTACK_COUNT];
+
+int scriptCodePos     = 0;
+int jumpTablePos      = 0;
+int jumpTableStackPos = 0;
+int functionStackPos  = 0;
+int foreachStackPos   = 0;
+
+ScriptEngine scriptEng = ScriptEngine();
+char scriptText[0x4000];
+
+int scriptDataPos       = 0;
+int scriptDataOffset    = 0;
+int jumpTableDataPos    = 0;
+int jumpTableDataOffset = 0;
+
 #if RETRO_USE_COMPILER
 #if !RETRO_REV00
-#define COMMON_SCRIPT_VAR_COUNT (34)
+#define COMMONALIAS_COUNT (0x75)
 #else
-#define COMMON_SCRIPT_VAR_COUNT (33)
-#endif
+#define COMMONALIAS_COUNT (0x74)
 #endif
-
-#define SCRIPT_VAR_COUNT (COMMON_SCRIPT_VAR_COUNT + 0x1DF)
+#define ALIAS_COUNT_TRIM (0xE0)
+#define ALIAS_COUNT      (COMMONALIAS_COUNT + ALIAS_COUNT_TRIM)
 int lineID = 0;
 
-enum ScriptVarType { VAR_ALIAS, VAR_STATICVALUE, VAR_TABLE };
-enum ScriptVarAccessModifier { ACCESS_NONE, ACCESS_PUBLIC, ACCESS_PRIVATE };
-
-struct ScriptVariableInfo {
-    ScriptVariableInfo()
+struct AliasInfo {
+    AliasInfo()
     {
-        type   = VAR_ALIAS;
-        access = ACCESS_NONE;
         StrCopy(name, "");
         StrCopy(value, "");
     }
-
-    ScriptVariableInfo(byte type, byte access, const char *name, const char *value)
+    AliasInfo(const char *aliasName, const char *aliasVal)
     {
-        this->type   = type;
-        this->access = access;
-        StrCopy(this->name, name);
-        StrCopy(this->value, value);
+        StrCopy(name, aliasName);
+        StrCopy(value, aliasVal);
     }
 
-    byte type;
-    byte access;
     char name[0x20];
     char value[0x20];
 };
 
+#define STATICVAR_COUNT (0x200)
+#endif
+
 struct FunctionInfo {
     FunctionInfo()
     {
@@ -49,12 +64,8 @@ struct FunctionInfo {
         StrCopy(name, functionName);
         opcodeSize = opSize;
     }
-    
-#if RETRO_REV03
-    char name[0x30];
-#else
+
     char name[0x20];
-#endif
     int opcodeSize;
 };
 
@@ -246,34 +257,34 @@ const char variableNames[][0x20] = {
     "music.position",
 
     // Input Properties
-    "keyDown.up",
-    "keyDown.down",
-    "keyDown.left",
-    "keyDown.right",
-    "keyDown.buttonA",
-    "keyDown.buttonB",
-    "keyDown.buttonC",
-    "keyDown.buttonX",
-    "keyDown.buttonY",
-    "keyDown.buttonZ",
-    "keyDown.buttonL",
-    "keyDown.buttonR",
-    "keyDown.start",
-    "keyDown.select",
-    "keyPress.up",
-    "keyPress.down",
-    "keyPress.left",
-    "keyPress.right",
-    "keyPress.buttonA",
-    "keyPress.buttonB",
-    "keyPress.buttonC",
-    "keyPress.buttonX",
-    "keyPress.buttonY",
-    "keyPress.buttonZ",
-    "keyPress.buttonL",
-    "keyPress.buttonR",
-    "keyPress.start",
-    "keyPress.select",
+    "inputDown.up",
+    "inputDown.down",
+    "inputDown.left",
+    "inputDown.right",
+    "inputDown.buttonA",
+    "inputDown.buttonB",
+    "inputDown.buttonC",
+    "inputDown.buttonX",
+    "inputDown.buttonY",
+    "inputDown.buttonZ",
+    "inputDown.buttonL",
+    "inputDown.buttonR",
+    "inputDown.start",
+    "inputDown.select",
+    "inputPress.up",
+    "inputPress.down",
+    "inputPress.left",
+    "inputPress.right",
+    "inputPress.buttonA",
+    "inputPress.buttonB",
+    "inputPress.buttonC",
+    "inputPress.buttonX",
+    "inputPress.buttonY",
+    "inputPress.buttonZ",
+    "inputPress.buttonL",
+    "inputPress.buttonR",
+    "inputPress.start",
+    "inputPress.select",
 
     // Menu Properties
     "menu1.selection",
@@ -331,26 +342,9 @@ const char variableNames[][0x20] = {
     "engine.onlineActive",
     "engine.sfxVolume",
     "engine.bgmVolume",
-#if RETRO_REV00
     "engine.platformID",
-#endif
     "engine.trialMode",
-#if !RETRO_REV00
     "engine.deviceType",
-#endif
-
-// Extras
-#if RETRO_REV03
-    "screen.currentID",
-    "camera.enabled",
-    "camera.target",
-    "camera.style",
-    "camera.xpos",
-    "camera.ypos",
-    "camera.adjustY",
-#endif
-
-// Haptics
 #if RETRO_USE_HAPTICS
     "engine.hapticsEnabled",
 #endif
@@ -429,12 +423,9 @@ const FunctionInfo functions[] = {
     FunctionInfo("LoadPalette", 5),
     FunctionInfo("RotatePalette", 4),
     FunctionInfo("SetScreenFade", 4),
+    FunctionInfo("SetClassicFade", 4),
     FunctionInfo("SetActivePalette", 3),
-#if RETRO_REV00
-    FunctionInfo("SetPaletteFade", 7),
-#else
-    FunctionInfo("SetPaletteFade", 6),
-#endif
+    FunctionInfo("SetPaletteFade", RETRO_REV00 ? 7 : 6),
     FunctionInfo("SetPaletteEntry", 3),
     FunctionInfo("GetPaletteEntry", 3),
     FunctionInfo("CopyPalette", 5),
@@ -449,6 +440,7 @@ const FunctionInfo functions[] = {
     FunctionInfo("EditMenuEntry", 4),
     FunctionInfo("LoadStage", 0),
     FunctionInfo("DrawRect", 8),
+    FunctionInfo("ClassicTint", 8),
     FunctionInfo("ResetObjectEntity", 5),
     FunctionInfo("BoxCollisionTest", 11),
     FunctionInfo("CreateTempObject", 4),
@@ -476,6 +468,10 @@ const FunctionInfo functions[] = {
     FunctionInfo("ObjectTileCollision", 4),
     FunctionInfo("ObjectTileGrip", 4),
 
+    // Video
+    FunctionInfo("LoadVideo", 1),
+    FunctionInfo("NextVideoFrame", 0),
+
     // Bitwise Not
     FunctionInfo("Not", 1),
 
@@ -517,14 +513,12 @@ const FunctionInfo functions[] = {
     FunctionInfo("ReadSaveRAM", 0),
     FunctionInfo("WriteSaveRAM", 0),
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
     FunctionInfo("LoadFontFile", 1),
-    FunctionInfo("LoadTextFile", 3),
-#else
-    FunctionInfo("LoadTextFile", 2),
 #endif
+    FunctionInfo("LoadTextFile", RETRO_REV02 ? 2 : 3),
     FunctionInfo("GetTextInfo", 5),
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
     FunctionInfo("DrawText", 7),
 #endif
     FunctionInfo("GetVersionNumber", 2),
@@ -540,75 +534,163 @@ const FunctionInfo functions[] = {
     FunctionInfo("CallNativeFunction4", 5),
 
     FunctionInfo("SetObjectRange", 1),
-#if RETRO_REV02
+#if !RETRO_REV00 || !RETRO_REV01
     FunctionInfo("GetObjectValue", 3),
     FunctionInfo("SetObjectValue", 3),
     FunctionInfo("CopyObject", 3),
 #endif
     FunctionInfo("Print", 3),
-
-#if RETRO_REV03
-    // Extras
-    FunctionInfo("CheckCameraProximity", 4),
-    FunctionInfo("SetScreenCount", 1),
-    FunctionInfo("SetScreenVertices", 5),
-    FunctionInfo("GetInputDeviceID", 2),
-    FunctionInfo("GetFilteredInputDeviceID", 4),
-    FunctionInfo("GetInputDeviceType", 2),
-    FunctionInfo("IsInputDeviceAssigned", 1),
-    FunctionInfo("AssignInputSlotToDevice", 2),
-    FunctionInfo("IsInputSlotAssigned", 1),
-    FunctionInfo("ResetInputSlotAssignments", 0),
-#endif
 };
 
 #if RETRO_USE_COMPILER
-
-int scriptValueListCount = 0;
-// clang-format off
-ScriptVariableInfo scriptValueList[SCRIPT_VAR_COUNT] = {
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "true", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "false", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FX_SCALE", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FX_ROTATE", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FX_ROTOZOOM", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FX_INK", "3"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "PRESENTATION_STAGE", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "REGULAR_STAGE", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "BONUS_STAGE", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "SPECIAL_STAGE", "3"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MENU_1", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MENU_2", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "C_TOUCH", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "C_SOLID", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "C_SOLID2", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "C_PLATFORM", "3"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "C_BOX", "65536"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MAT_WORLD", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MAT_VIEW", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MAT_TEMP", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FX_FLIP", "5"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FACING_LEFT", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "FACING_RIGHT", "0"),
+AliasInfo publicAliases[ALIAS_COUNT] = {
+    AliasInfo("true", "1"),
+    AliasInfo("false", "0"),
+    AliasInfo("FX_FLIP", "1"),
+    AliasInfo("FX_ROTATE", "2"),
+    AliasInfo("FX_HSCALE", "4"),
+    AliasInfo("FX_VSCALE", "8"),
+    AliasInfo("FX_SCALE", "13"), //scale applies hscale, vscale AND flip (but only horizontally? TODO perhaps?
+    AliasInfo("FX_ROTOZOOM", "15"),
+    AliasInfo("FX_INK", "16"),
+	AliasInfo("FX_ALL", "31"),
+    AliasInfo("PRESENTATION_STAGE", "0"),
+    AliasInfo("REGULAR_STAGE", "1"),
+    AliasInfo("BONUS_STAGE", "2"),
+    AliasInfo("SPECIAL_STAGE", "3"),
+    AliasInfo("MENU_1", "0"),
+    AliasInfo("MENU_2", "1"),
+    AliasInfo("C_TOUCH", "0"),
+    AliasInfo("C_BOX", "1"),
+    AliasInfo("C_BOX2", "2"),
+    AliasInfo("C_PLATFORM", "3"),
+    AliasInfo("MAT_WORLD", "0"),
+    AliasInfo("MAT_VIEW", "1"),
+    AliasInfo("MAT_TEMP", "2"),
+    AliasInfo("FACING_LEFT", "1"),
+    AliasInfo("FACING_RIGHT", "0"),
+    AliasInfo("FLIP_NONE", "0"),
+    AliasInfo("FLIP_X", "1"),
+    AliasInfo("FLIP_Y", "2"),
+    AliasInfo("FLIP_XY", "3"),
+    AliasInfo("STAGE_RUNNING", "1"),
+    AliasInfo("STAGE_PAUSED", "2"),
+    AliasInfo("STAGE_FROZEN", "3"),
 #if !RETRO_REV00
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "STAGE_2P_MODE", "4"),
+    AliasInfo("STAGE_2P", "4"),
 #endif
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "STAGE_FROZEN", "3"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "STAGE_PAUSED", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "STAGE_RUNNING", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "RESET_GAME", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "STANDARD", "0"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "MOBILE", "1"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "DEVICE_XBOX", "2"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "DEVICE_PSN", "3"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "DEVICE_IOS", "4"),
-    ScriptVariableInfo(VAR_ALIAS, ACCESS_PUBLIC, "DEVICE_ANDROID", "5"),
+    AliasInfo("ENGINE_DEVMENU", "0"),
+    AliasInfo("ENGINE_MAINGAME", "1"),
+    AliasInfo("ENGINE_INITDEVMENU", "2"),
+    AliasInfo("ENGINE_WAIT", "3"),
+    AliasInfo("ENGINE_SCRIPTERROR", "4"),
+    AliasInfo("ENGINE_INITPAUSE", "5"),
+    AliasInfo("ENGINE_EXITPAUSE", "6"),
+    AliasInfo("ENGINE_ENDGAME", "7"),
+    AliasInfo("ENGINE_RESETGAME", "8"),
+    AliasInfo("RESET_GAME", "2"),
+    AliasInfo("RETRO_STANDARD", "0"),
+    AliasInfo("RETRO_MOBILE", "1"),
+    AliasInfo("INK_NONE", "0"),
+    AliasInfo("INK_BLEND", "1"),
+    AliasInfo("INK_ALPHA", "2"),
+    AliasInfo("INK_ADD", "3"),
+    AliasInfo("INK_SUB", "4"),
+    AliasInfo("CSIDE_FLOOR", "0"),
+    AliasInfo("CSIDE_LWALL", "1"),
+    AliasInfo("CSIDE_RWALL", "2"),
+    AliasInfo("CSIDE_ROOF", "3"),
+    AliasInfo("CMODE_FLOOR", "0"),
+    AliasInfo("CMODE_LWALL", "1"),
+    AliasInfo("CMODE_ROOF", "2"),
+    AliasInfo("CMODE_RWALL", "3"),
+    AliasInfo("COL_NONE", "0"),
+    AliasInfo("COL_TOP", "1"),
+    AliasInfo("COL_LEFT", "2"),
+    AliasInfo("COL_RIGHT", "3"),
+    AliasInfo("COL_BOTTOM", "4"),
+    AliasInfo("PATH_A", "0"),
+    AliasInfo("PATH_B", "1"),
+    AliasInfo("GRAVITY_GROUND", "0"),
+    AliasInfo("GRAVITY_AIR", "1"),
+    AliasInfo("FACE_TEXTURED_3D", "0"),
+    AliasInfo("FACE_TEXTURED_2D", "1"),
+    AliasInfo("FACE_COLOURED_3D", "2"),
+    AliasInfo("FACE_COLOURED_2D", "3"),
+    AliasInfo("FACE_FADED", "4"),
+    AliasInfo("FACE_TEXTURED_C", "5"),
+    AliasInfo("FACE_TEXTURED_C_BLEND", "6"),
+    AliasInfo("FACE_TEXTURED_D", "6"), // identical to "FACE_TEXTURED_C_BLEND", but kept here for backwards compat purposes
+    AliasInfo("FACE_SPRITE_3D", "7"),
+    AliasInfo("PRIORITY_ACTIVE_BOUNDS", "0"),
+    AliasInfo("PRIORITY_ACTIVE", "1"),
+    AliasInfo("PRIORITY_ACTIVE_PAUSED", "2"),
+    AliasInfo("PRIORITY_XBOUNDS", "3"),
+    AliasInfo("PRIORITY_XBOUNDS_DESTROY", "4"),
+    AliasInfo("PRIORITY_INACTIVE", "5"),
+    AliasInfo("PRIORITY_BOUNDS_SMALL", "6"),
+    AliasInfo("PRIORITY_ACTIVE_SMALL", "7"),
+    AliasInfo("PRIORITY_UNKNOWN", "7"), // identical to "PRIORITY_ACTIVE_SMALL", but kept here for backwards compat purposes
+    AliasInfo("CONTROLMODE_NONE", "-1"),
+    AliasInfo("CONTROLMODE_NORMAL", "0"),
+    AliasInfo("CAMERASTYLE_FOLLOW", "0"),
+    AliasInfo("CAMERASTYLE_EXTENDED", "1"),
+    AliasInfo("CAMERASTYLE_EXTENDED_OFFSET_L", "2"),
+    AliasInfo("CAMERASTYLE_EXTENDED_OFFSET_R", "3"),
+    AliasInfo("CAMERASTYLE_HLOCKED", "4"),
+    AliasInfo("TILEINFO_INDEX", "0"),
+    AliasInfo("TILEINFO_DIRECTION", "1"),
+    AliasInfo("TILEINFO_VISUALPLANE", "2"),
+    AliasInfo("TILEINFO_SOLIDITYA", "3"),
+    AliasInfo("TILEINFO_SOLIDITYB", "4"),
+    AliasInfo("TILEINFO_FLAGSA", "5"),
+    AliasInfo("TILEINFO_ANGLEA", "6"),
+    AliasInfo("TILEINFO_FLAGSB", "7"),
+    AliasInfo("TILEINFO_ANGLEB", "8"),
+    AliasInfo("TEXTINFO_TEXTDATA", "0"),
+    AliasInfo("TEXTINFO_TEXTSIZE", "1"),
+    AliasInfo("TEXTINFO_ROWCOUNT", "2"),
+    AliasInfo("TILELAYER_NOSCROLL", "0"),
+    AliasInfo("TILELAYER_HSCROLL", "1"),
+    AliasInfo("TILELAYER_VSCROLL", "2"),
+    AliasInfo("TILELAYER_3DFLOOR", "3"),
+    AliasInfo("TILELAYER_3DSKY", "4"),
+    AliasInfo("GROUP_ALL", "0"),
+    // These are for Engine.PlatformID
+    AliasInfo("RETRO_WIN", "0"),
+    AliasInfo("RETRO_OSX", "1"),
+    AliasInfo("RETRO_XBOX_360", "2"),
+    AliasInfo("RETRO_PS3", "3"),
+    AliasInfo("RETRO_iOS", "4"),
+    AliasInfo("RETRO_ANDROID", "5"),
+    AliasInfo("RETRO_WP7", "6"),
+    AliasInfo("RETRO_UWP", "7"),
+    AliasInfo("RETRO_LINUX", "8"),
+    AliasInfo("RETRO_SWITCH", "9")
 };
-// clang-format on
+AliasInfo privateAliases[ALIAS_COUNT_TRIM];
+int publicAliasCount  = 0;
+int privateAliasCount = 0;
+
+StaticInfo publicStaticVariables[STATICVAR_COUNT];
+StaticInfo privateStaticVariables[STATICVAR_COUNT];
+int publicStaticVarCount  = 0;
+int privateStaticVarCount = 0;
+
+TableInfo *currentTable = NULL;
+bool curTablePublic     = false;
+
+TableInfo publicTables[TABLE_COUNT];
+TableInfo privateTables[TABLE_COUNT];
+int publicTableCount  = 0;
+int privateTableCount = 0;
 
 const char scriptEvaluationTokens[][0x4] = { "=",  "+=", "-=", "++", "--", "*=", "/=", ">>=", "<<=", "&=",
                                              "|=", "^=", "%=", "==", ">",  ">=", "<",  "<=",  "!=" };
 
+int scriptFunctionCount = 0;
+char scriptFunctionNames[FUNCTION_COUNT][0x40];
+
 enum ScriptReadModes { READMODE_NORMAL = 0, READMODE_STRING = 1, READMODE_COMMENTLINE = 2, READMODE_ENDLINE = 3, READMODE_EOF = 4 };
 enum ScriptParseModes {
     PARSEMODE_SCOPELESS    = 0,
@@ -796,34 +878,34 @@ enum ScrVar {
     VAR_MUSICVOLUME,
     VAR_MUSICCURRENTTRACK,
     VAR_MUSICPOSITION,
-    VAR_KEYDOWNUP,
-    VAR_KEYDOWNDOWN,
-    VAR_KEYDOWNLEFT,
-    VAR_KEYDOWNRIGHT,
-    VAR_KEYDOWNBUTTONA,
-    VAR_KEYDOWNBUTTONB,
-    VAR_KEYDOWNBUTTONC,
-    VAR_KEYDOWNBUTTONX,
-    VAR_KEYDOWNBUTTONY,
-    VAR_KEYDOWNBUTTONZ,
-    VAR_KEYDOWNBUTTONL,
-    VAR_KEYDOWNBUTTONR,
-    VAR_KEYDOWNSTART,
-    VAR_KEYDOWNSELECT,
-    VAR_KEYPRESSUP,
-    VAR_KEYPRESSDOWN,
-    VAR_KEYPRESSLEFT,
-    VAR_KEYPRESSRIGHT,
-    VAR_KEYPRESSBUTTONA,
-    VAR_KEYPRESSBUTTONB,
-    VAR_KEYPRESSBUTTONC,
-    VAR_KEYPRESSBUTTONX,
-    VAR_KEYPRESSBUTTONY,
-    VAR_KEYPRESSBUTTONZ,
-    VAR_KEYPRESSBUTTONL,
-    VAR_KEYPRESSBUTTONR,
-    VAR_KEYPRESSSTART,
-    VAR_KEYPRESSSELECT,
+    VAR_INPUTDOWNUP,
+    VAR_INPUTDOWNDOWN,
+    VAR_INPUTDOWNLEFT,
+    VAR_INPUTDOWNRIGHT,
+    VAR_INPUTDOWNBUTTONA,
+    VAR_INPUTDOWNBUTTONB,
+    VAR_INPUTDOWNBUTTONC,
+    VAR_INPUTDOWNBUTTONX,
+    VAR_INPUTDOWNBUTTONY,
+    VAR_INPUTDOWNBUTTONZ,
+    VAR_INPUTDOWNBUTTONL,
+    VAR_INPUTDOWNBUTTONR,
+    VAR_INPUTDOWNSTART,
+    VAR_INPUTDOWNSELECT,
+    VAR_INPUTPRESSUP,
+    VAR_INPUTPRESSDOWN,
+    VAR_INPUTPRESSLEFT,
+    VAR_INPUTPRESSRIGHT,
+    VAR_INPUTPRESSBUTTONA,
+    VAR_INPUTPRESSBUTTONB,
+    VAR_INPUTPRESSBUTTONC,
+    VAR_INPUTPRESSBUTTONX,
+    VAR_INPUTPRESSBUTTONY,
+    VAR_INPUTPRESSBUTTONZ,
+    VAR_INPUTPRESSBUTTONL,
+    VAR_INPUTPRESSBUTTONR,
+    VAR_INPUTPRESSSTART,
+    VAR_INPUTPRESSSELECT,
     VAR_MENU1SELECTION,
     VAR_MENU2SELECTION,
     VAR_TILELAYERXSIZE,
@@ -872,25 +954,9 @@ enum ScrVar {
     VAR_ENGINEONLINEACTIVE,
     VAR_ENGINESFXVOLUME,
     VAR_ENGINEBGMVOLUME,
-#if RETRO_REV00
     VAR_ENGINEPLATFORMID, // v3-style device type aka Windows/Mac/Android/etc
-#endif
     VAR_ENGINETRIALMODE,
-#if !RETRO_REV00
-    VAR_ENGINEDEVICETYPE, // v4-style device type aka Standard/Mobile/Etc
-#endif
-
-#if RETRO_REV03
-    // Extras
-    VAR_SCREENCURRENTID,
-    VAR_CAMERAENABLED,
-    VAR_CAMERATARGET,
-    VAR_CAMERASTYLE,
-    VAR_CAMERAXPOS,
-    VAR_CAMERAYPOS,
-    VAR_CAMERAADJUSTY,
-#endif
-
+    VAR_ENGINEDEVICETYPE,
 #if RETRO_USE_HAPTICS
     VAR_HAPTICSENABLED,
 #endif
@@ -960,6 +1026,7 @@ enum ScrFunc {
     FUNC_LOADPALETTE,
     FUNC_ROTATEPALETTE,
     FUNC_SETSCREENFADE,
+    FUNC_SETCLASSICFADE,
     FUNC_SETACTIVEPALETTE,
     FUNC_SETPALETTEFADE,
     FUNC_SETPALETTEENTRY,
@@ -974,6 +1041,7 @@ enum ScrFunc {
     FUNC_EDITMENUENTRY,
     FUNC_LOADSTAGE,
     FUNC_DRAWRECT,
+    FUNC_CLASSICTINT,
     FUNC_RESETOBJECTENTITY,
     FUNC_BOXCOLLISIONTEST,
     FUNC_CREATETEMPOBJECT,
@@ -992,6 +1060,8 @@ enum ScrFunc {
     FUNC_SETSFXATTRIBUTES,
     FUNC_OBJECTTILECOLLISION,
     FUNC_OBJECTTILEGRIP,
+    FUNC_LOADVIDEO,
+    FUNC_NEXTVIDEOFRAME,
     FUNC_NOT,
     FUNC_DRAW3DSCENE,
     FUNC_SETIDENTITYMATRIX,
@@ -1024,12 +1094,12 @@ enum ScrFunc {
     FUNC_GETANIMATIONBYNAME,
     FUNC_READSAVERAM,
     FUNC_WRITESAVERAM,
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
     FUNC_LOADTEXTFONT,
 #endif
     FUNC_LOADTEXTFILE,
     FUNC_GETTEXTINFO,
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
     FUNC_DRAWTEXT,
 #endif
     FUNC_GETVERSIONNUMBER,
@@ -1041,437 +1111,323 @@ enum ScrFunc {
     FUNC_CALLNATIVEFUNCTION2,
     FUNC_CALLNATIVEFUNCTION4,
     FUNC_SETOBJECTRANGE,
-#if RETRO_REV02
+#if !RETRO_REV00 && !RETRO_REV01
     FUNC_GETOBJECTVALUE,
     FUNC_SETOBJECTVALUE,
     FUNC_COPYOBJECT,
 #endif
     FUNC_PRINT,
-
-#if RETRO_REV03
-    // Extras
-    FUNC_CHECKCAMERAPROXIMITY,
-    FUNC_SETSCREENCOUNT,
-    FUNC_SETSCREENVERTICES,
-    FUNC_GETINPUTDEVICEID,
-    FUNC_GETFILTEREDINPUTDEVICEID,
-    FUNC_GETINPUTDEVICETYPE,
-    FUNC_ISINPUTDEVICEASSIGNED,
-    FUNC_ASSIGNINPUTSLOTTODEVICE,
-    FUNC_ISSLOTASSIGNED,
-    FUNC_RESETINPUTSLOTASSIGNMENTS,
-#endif
     FUNC_MAX_CNT
 };
 
-ObjectScript objectScriptList[OBJECT_COUNT];
-ScriptFunction scriptFunctionList[FUNCTION_COUNT];
-#if RETRO_USE_COMPILER
-int scriptFunctionCount = 0;
-#endif
-
-int scriptCode[SCRIPTCODE_COUNT];
-int jumpTable[JUMPTABLE_COUNT];
-int jumpTableStack[JUMPSTACK_COUNT];
-int functionStack[FUNCSTACK_COUNT];
-int foreachStack[FORSTACK_COUNT];
-
-int scriptCodePos     = 0;
-int scriptCodeOffset  = 0;
-int jumpTablePos      = 0;
-int jumpTableOffset   = 0;
-int jumpTableStackPos = 0;
-int functionStackPos  = 0;
-int foreachStackPos   = 0;
-
-ScriptEngine scriptEng = ScriptEngine();
-char scriptText[0x4000];
-
 #if RETRO_USE_COMPILER
 void CheckAliasText(char *text)
 {
+    sizeof(publicTables);
     if (FindStringToken(text, "publicalias", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
+        
+        if (publicAliasCount >= ALIAS_COUNT) {
             SetupTextMenu(&gameMenu[0], 0);
             AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
             AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
-            Engine.gameMode = ENGINE_SCRIPTERROR;
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PUBLIC ALIASES");
+            Engine.gameMode = ENGINE_SCRIPTERROR;									// public alias & we reached the cap
             return;
         }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
-
-        int textStrPos = 11;
-        int varStrPos  = 0;
-        int parseMode  = 0;
-
-        while (text[textStrPos]) {
-            switch (parseMode) {
-                default: break;
 
-                case 0:
-                    if (text[textStrPos] == ':') {
-                        textStrPos++;
-                        variable->value[varStrPos] = 0;
-                        varStrPos                  = 0;
-                        parseMode                  = 1;
+        AliasInfo *a = &publicAliases[publicAliasCount];
+        int *cnt     = &publicAliasCount;
+        bool priv    = false;
+        MEM_ZEROP(a);
+        int textPos     = 11;
+        int aliasStrPos = 0;
+        int aliasMatch  = 0;
+
+        
+        while (aliasMatch < 2) {
+            if (aliasMatch) {
+                if (aliasMatch == 1) {
+                    a->name[aliasStrPos] = text[textPos];
+                    if (text[textPos]) {
+                        aliasStrPos++;
                     }
                     else {
-                        variable->value[varStrPos++] = text[textStrPos++];
+                        aliasStrPos = 0;
+                        ++aliasMatch;
                     }
-                    break;
-
-                case 1: variable->name[varStrPos++] = text[textStrPos++]; break;
+                }
+            }
+            else if (text[textPos] == ':') {
+                a->value[aliasStrPos] = 0;
+                aliasStrPos           = 0;
+                aliasMatch            = 1;
+            }
+            else {
+                a->value[aliasStrPos++] = text[textPos];
             }
+            ++textPos;
         }
 
-        variable->access = ACCESS_PUBLIC;
-
-#if !RETRO_USE_ORIGINAL_CODE
-        for (int v = 0; v < scriptValueListCount; ++v) {
-            if (StrComp(scriptValueList[v].name, variable->name))
-                PrintLog("WARNING: Variable Name '%s' has already been used!", variable->name);
+        for (int v = 0; v < *cnt; ++v) {
+            if (StrComp(publicAliases[v].name, a->name)) {
+                PrintLog("Warning: Public Alias %s has already been used!", a->name);
+            }
         }
-#endif
 
-        ++scriptValueListCount;
+        ++*cnt;
     }
     else if (FindStringToken(text, "privatealias", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
+        
+        if (privateAliasCount >= ALIAS_COUNT) {
             SetupTextMenu(&gameMenu[0], 0);
             AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
             AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
-            Engine.gameMode = ENGINE_SCRIPTERROR;
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PRIVATE ALIASES");
+            Engine.gameMode = ENGINE_SCRIPTERROR;									// public alias & we reached the cap
             return;
         }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
-
-        int textStrPos = 12;
-        int varStrPos  = 0;
-        int parseMode  = 0;
-
-        while (text[textStrPos]) {
-            switch (parseMode) {
-                default: break;
-
-                case 0:
-                    if (text[textStrPos] == ':') {
-                        textStrPos++;
-                        variable->value[varStrPos] = 0;
-                        varStrPos                  = 0;
-                        parseMode                  = 1;
+        
+        AliasInfo *a = &privateAliases[privateAliasCount];
+        int *cnt     = &privateAliasCount;
+        bool priv    = false;
+        MEM_ZEROP(a);
+        int textPos     = 12;
+        int aliasStrPos = 0;
+        int aliasMatch  = 0;
+        
+
+        while (aliasMatch < 2) {
+            if (aliasMatch) {
+                if (aliasMatch == 1) {
+                    a->name[aliasStrPos] = text[textPos];
+                    if (text[textPos]) {
+                        aliasStrPos++;
                     }
                     else {
-                        variable->value[varStrPos++] = text[textStrPos++];
+                        aliasStrPos = 0;
+                        ++aliasMatch;
                     }
-                    break;
-
-                case 1: variable->name[varStrPos++] = text[textStrPos++]; break;
+                }
             }
+            else if (text[textPos] == ':') {
+                a->value[aliasStrPos] = 0;
+                aliasStrPos           = 0;
+                aliasMatch            = 1;
+            }
+            else {
+                a->value[aliasStrPos++] = text[textPos];
+            }
+            ++textPos;
         }
 
-        variable->access = ACCESS_PRIVATE;
-
-#if !RETRO_USE_ORIGINAL_CODE
-        for (int v = 0; v < scriptValueListCount; ++v) {
-            if (StrComp(scriptValueList[v].name, variable->name))
-                PrintLog("WARNING: Variable Name '%s' has already been used!", variable->name);
+        for (int v = 0; v < *cnt; ++v) {
+            if (StrComp(privateAliases[v].name, a->name)) {
+                PrintLog("Warning: Private Alias %s has already been used!", a->name);
+            }
         }
-#endif
 
-        ++scriptValueListCount;
+        ++*cnt;
     }
 }
 void CheckStaticText(char *text)
 {
     if (FindStringToken(text, "publicvalue", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
+         if (publicStaticVarCount >= STATICVAR_COUNT) {
             SetupTextMenu(&gameMenu[0], 0);
             AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
             AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PUBLIC VALUES");
             Engine.gameMode = ENGINE_SCRIPTERROR;
             return;
-        }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
+         }
+        
+        StaticInfo *var = &publicStaticVariables[publicStaticVarCount];
+        int *cnt        = &publicStaticVarCount;
+        MEM_ZEROP(var);
+        int textPos      = 11;
+        int staticStrPos = 0;
+        int staticMatch  = 0;
+        char strBuffer[0x10];	
+        
+        var->dataPos = -1;
+
+        while (staticMatch < 2) {
+            if (staticMatch == 1) {
+                if (text[staticStrPos] != ';' && text[textPos]) {
+                    strBuffer[staticStrPos++] = text[textPos];
+                }
+                else {
+                    strBuffer[staticStrPos] = 0;
 
-        int textStrPos = 11;
-        int varStrPos  = 0;
-        int parseMode  = 0;
+                    if (!ConvertStringToInteger(strBuffer, &var->value)) {
+                        bool flag = false;
 
-        StrCopy(variable->value, "0"); // default value is 0
-        while (text[textStrPos]) {
-            switch (parseMode) {
-                default: break;
+                        for (int a = 0; a < publicAliasCount && !flag; ++a) {
+                            if (StrComp(publicAliases[a].name, strBuffer)) {
+                                StrCopy(strBuffer, publicAliases[a].value);
+                                break;
+                            }
+                        }
 
-                case 0:
-                    if (text[textStrPos] == '=') {
-                        textStrPos++;
-                        variable->name[varStrPos] = 0;
-                        varStrPos                 = 0;
-                        parseMode                 = 1;
-                    }
-                    else {
-                        variable->name[varStrPos++] = text[textStrPos++];
+                        if (!ConvertStringToInteger(strBuffer, &var->value)) {
+                            PrintLog("WARNING: unable to convert static var value \"%s\" to int, on line %d", strBuffer, lineID);
+                        }
                     }
-                    break;
 
-                case 1: variable->value[varStrPos++] = text[textStrPos++]; break;
+                    var->dataPos                = scriptDataPos;
+                    scriptData[scriptDataPos++] = var->value;
+                    staticStrPos                = 0;
+                    ++staticMatch;
+                }
+            }
+            else if (text[textPos] == '=') {
+                var->name[staticStrPos] = 0;
+                staticStrPos            = 0;
+                staticMatch             = 1;
+            }
+            else if (!text[textPos]) {
+                break;
+            }
+            else {
+                var->name[staticStrPos++] = text[textPos];
             }
+            ++textPos;
         }
 
-        variable->access = ACCESS_PUBLIC;
-
-        if (!ConvertStringToInteger(variable->value, &scriptCode[scriptCodePos]))
-            scriptCode[scriptCodePos] = 0;
-
-        StrCopy(variable->value, "local[");
-        AppendIntegerToString(variable->value, scriptCodePos++);
-        StrAdd(variable->value, "]");
+        // no assigned value, default to 0
+        if (var->dataPos == -1) {
+            var->dataPos                = scriptDataPos;
+            var->value                  = 0;
+            scriptData[scriptDataPos++] = var->value;
+        }
 
-#if !RETRO_USE_ORIGINAL_CODE
-        for (int v = 0; v < scriptValueListCount; ++v) {
-            if (StrComp(scriptValueList[v].name, variable->name))
-                PrintLog("WARNING: Variable Name '%s' has already been used!", variable->name);
+        for (int v = 0; v < *cnt; ++v) {
+            if (StrComp(publicStaticVariables[v].name, var->name)) {
+                PrintLog("Warning: Public Variable %s has already been used!", var->name);
+            }
         }
-#endif
 
-        ++scriptValueListCount;
+        ++*cnt;
     }
     else if (FindStringToken(text, "privatevalue", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
+        if (privateStaticVarCount >= STATICVAR_COUNT) {
             SetupTextMenu(&gameMenu[0], 0);
             AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
             AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PRIVATE VALUES");
             Engine.gameMode = ENGINE_SCRIPTERROR;
             return;
         }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
-
-        int textStrPos = 12;
-        int varStrPos  = 0;
-        int parseMode  = 0;
-
-        StrCopy(variable->value, "0"); // default value is 0
-        while (text[textStrPos]) {
-            switch (parseMode) {
-                default: break;
+        
+        StaticInfo *var = &privateStaticVariables[privateStaticVarCount];
+        int *cnt        = &privateStaticVarCount;
+        MEM_ZEROP(var);
+        int textPos      = 12;
+        int staticStrPos = 0;
+        int staticMatch  = 0;
+        char strBuffer[0x10];	
+        
+        var->dataPos = -1;
+
+        while (staticMatch < 2) {
+            if (staticMatch == 1) {
+                if (text[staticStrPos] != ';' && text[textPos]) {
+                    strBuffer[staticStrPos++] = text[textPos];
+                }
+                else {
+                    strBuffer[staticStrPos] = 0;
+
+                    if (!ConvertStringToInteger(strBuffer, &var->value)) {
+                        bool flag = false;
+                        for (int a = 0; a < privateAliasCount; ++a) {
+                            if (StrComp(privateAliases[a].name, strBuffer)) {
+                                StrCopy(strBuffer, privateAliases[a].value);
+                                flag = true;
+                                break;
+                            }
+                        }
 
-                case 0:
-                    if (text[textStrPos] == '=') {
-                        textStrPos++;
-                        variable->name[varStrPos] = 0;
-                        varStrPos                 = 0;
-                        parseMode                 = 1;
-                    }
-                    else {
-                        variable->name[varStrPos++] = text[textStrPos++];
+                        if (!ConvertStringToInteger(strBuffer, &var->value)) {
+                            PrintLog("WARNING: unable to convert static var value \"%s\" to int, on line %d", strBuffer, lineID);
+                        }
                     }
-                    break;
 
-                case 1: variable->value[varStrPos++] = text[textStrPos++]; break;
+                    var->dataPos                = scriptDataPos;
+                    scriptData[scriptDataPos++] = var->value;
+                    staticStrPos                = 0;
+                    ++staticMatch;
+                }
             }
-        }
-
-        variable->access = ACCESS_PRIVATE;
-
-        if (!ConvertStringToInteger(variable->value, &scriptCode[scriptCodePos]))
-            scriptCode[scriptCodePos] = 0;
-
-        StrCopy(variable->value, "local[");
-        AppendIntegerToString(variable->value, scriptCodePos++);
-        StrAdd(variable->value, "]");
-
-#if !RETRO_USE_ORIGINAL_CODE
-        for (int v = 0; v < scriptValueListCount; ++v) {
-            if (StrComp(scriptValueList[v].name, variable->name))
-                PrintLog("WARNING: Variable Name '%s' has already been used!", variable->name);
-        }
-#endif
-
-        ++scriptValueListCount;
-    }
-}
-bool CheckTableText(char *text)
-{
-    bool hasValues = false;
-
-    if (FindStringToken(text, "publictable", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
-            SetupTextMenu(&gameMenu[0], 0);
-            AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
-            AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
-            Engine.gameMode = ENGINE_SCRIPTERROR;
-            return false;
-        }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
-
-        int textStrPos = 11;
-        int varStrPos  = 0;
-
-        while (text[textStrPos]) {
-            if (text[textStrPos] == '[' || text[textStrPos] == ']') {
-                variable->name[varStrPos] = 0;
-                textStrPos++;
+            else if (text[textPos] == '=') {
+                var->name[staticStrPos] = 0;
+                staticStrPos            = 0;
+                staticMatch             = 1;
+            }
+            else if (!text[textPos]) {
                 break;
             }
             else {
-                variable->name[varStrPos++] = text[textStrPos++];
+                var->name[staticStrPos++] = text[textPos];
             }
+            ++textPos;
         }
 
-        if (FindStringToken(text, "]", 1) < 1) {
-            // has default values, we'll stop here and read stuff in a seperate mode
-            scriptCode[scriptCodePos] = 0;
-            StrCopy(variable->value, "");
-            AppendIntegerToString(variable->value, scriptCodePos);
-            scriptCodeOffset = scriptCodePos++;
-            hasValues        = true;
+        // no assigned value, default to 0
+        if (var->dataPos == -1) {
+            var->dataPos                = scriptDataPos;
+            var->value                  = 0;
+            scriptData[scriptDataPos++] = var->value;
         }
-        else {
-            // no default values, just an array size
 
-            varStrPos = 0;
-            while (text[textStrPos]) {
-                if (text[textStrPos] == '[' || text[textStrPos] == ']') {
-                    variable->value[varStrPos] = 0;
-                    textStrPos++;
-                    break;
-                }
-                else {
-                    variable->value[varStrPos++] = text[textStrPos++];
-                }
-            }
-
-            // array size can be an variable (alias), how cool!
-            for (int v = 0; v < scriptValueListCount; ++v) {
-                if (StrComp(variable->value, scriptValueList[v].name))
-                    StrCopy(variable->value, scriptValueList[v].value);
+        for (int v = 0; v < *cnt; ++v) {
+            if (StrComp(privateStaticVariables[v].name, var->name)) {
+                PrintLog("Warning: Private Variable %s has already been used!", var->name);
             }
-
-            if (!ConvertStringToInteger(variable->value, &scriptCode[scriptCodePos])) {
-                scriptCode[scriptCodePos] = 1;
-#if !RETRO_USE_ORIGINAL_CODE
-                PrintLog("WARNING: Unable to parse table size!");
-#endif
-            }
-
-            StrCopy(variable->value, "");
-            AppendIntegerToString(variable->value, scriptCodePos);
-
-            int valueCount = scriptCode[scriptCodePos++];
-            for (int v = 0; v < valueCount; ++v) scriptCode[scriptCodePos++] = 0;
         }
 
-        variable->access = ACCESS_PUBLIC;
-        scriptValueListCount++;
+        ++*cnt;
     }
-    else if (FindStringToken(text, "privatetable", 1) == 0) {
-#if !RETRO_USE_ORIGINAL_CODE
-        if (scriptValueListCount >= SCRIPT_VAR_COUNT) {
+}
+TableInfo *CheckTableText(char *text)
+{
+    if (FindStringToken(text, "publictable", 1) && FindStringToken(text, "privatetable", 1))
+        return NULL;
+    
+    if (FindStringToken(text, "publictable", 1) == 0) { // public table & we reached the cap
+        if (publicTableCount >= TABLE_COUNT) {
             SetupTextMenu(&gameMenu[0], 0);
             AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
             AddTextMenuEntry(&gameMenu[0], " ");
-            AddTextMenuEntry(&gameMenu[0], "TOO MANY ALIASES, STATIC");
-            AddTextMenuEntry(&gameMenu[0], "VALUES, AND TABLES");
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PUBLIC TABLES");
             Engine.gameMode = ENGINE_SCRIPTERROR;
-            return false;
-        }
-#endif
-
-        ScriptVariableInfo *variable = &scriptValueList[scriptValueListCount];
-        MEM_ZEROP(variable);
-
-        int textStrPos = 12;
-        int varStrPos  = 0;
-
-        while (text[textStrPos]) {
-            if (text[textStrPos] == '[' || text[textStrPos] == ']') {
-                variable->name[varStrPos] = 0;
-                textStrPos++;
-                break;
-            }
-            else {
-                variable->name[varStrPos++] = text[textStrPos++];
-            }
-        }
-
-        if (FindStringToken(text, "]", 1) < 1) {
-            // has default values, we'll stop here and read stuff in a seperate mode
-            scriptCode[scriptCodePos] = 0;
-            StrCopy(variable->value, "");
-            AppendIntegerToString(variable->value, scriptCodePos);
-            scriptCodeOffset = scriptCodePos++;
-            hasValues        = true;
-        }
-        else {
-            // no default values, just an array size
-
-            varStrPos = 0;
-            while (text[textStrPos]) {
-                if (text[textStrPos] == '[' || text[textStrPos] == ']') {
-                    variable->value[varStrPos] = 0;
-                    textStrPos++;
-                    break;
-                }
-                else {
-                    variable->value[varStrPos++] = text[textStrPos++];
-                }
-            }
-
-            // array size can be an variable (alias), how cool!
-            for (int v = 0; v < scriptValueListCount; ++v) {
-                if (StrComp(variable->value, scriptValueList[v].name))
-                    StrCopy(variable->value, scriptValueList[v].value);
-            }
-
-            if (!ConvertStringToInteger(variable->value, &scriptCode[scriptCodePos])) {
-                scriptCode[scriptCodePos] = 1;
-#if !RETRO_USE_ORIGINAL_CODE
-                PrintLog("WARNING: Unable to parse table size!");
-#endif
-            }
-
-            StrCopy(variable->value, "");
-            AppendIntegerToString(variable->value, scriptCodePos);
-
-            int valueCount = scriptCode[scriptCodePos++];
-            for (int v = 0; v < valueCount; ++v) scriptCode[scriptCodePos++] = 0;
+            return NULL;
         }
+    }
 
-        variable->access = ACCESS_PRIVATE;
-        scriptValueListCount++;
+    TableInfo *table = &publicTables[publicTableCount];
+    int strPos       = 11;
+    curTablePublic   = true;
+    if (FindStringToken(text, "privatetable", 1) == 0) {
+        if (privateTableCount >= TABLE_COUNT) { // private table and we reached the cap
+            SetupTextMenu(&gameMenu[0], 0);
+            AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
+            AddTextMenuEntry(&gameMenu[0], " ");
+            AddTextMenuEntry(&gameMenu[0], "TOO MANY PRIVATE TABLES");
+            Engine.gameMode = ENGINE_SCRIPTERROR;
+            return NULL;
+        }	
+        table          = &privateTables[privateTableCount];
+        strPos         = 12;
+        curTablePublic = false;
     }
+    MEM_ZEROP(table);
 
-    return hasValues;
+    int namePos = 0;
+    while (text[strPos]) {
+        table->name[namePos++] = text[strPos++];
+    }
+    table->name[namePos] = 0;
+    return table;
 }
 void ConvertArithmaticSyntax(char *text)
 {
@@ -1487,7 +1443,6 @@ void ConvertArithmaticSyntax(char *text)
             token  = i;
         }
     }
-
     if (token > 0) {
         StrCopy(dest, functions[token].name);
         StrAdd(dest, "(");
@@ -1505,14 +1460,42 @@ void ConvertArithmaticSyntax(char *text)
         StrCopy(text, dest);
     }
 }
-void ConvertConditionalStatement(char *text)
+void ConvertIfWhileStatement(char *text)
 {
     char dest[260];
     int compareOp  = -1;
     int strPos     = 0;
     int destStrPos = 0;
-
-    if (FindStringToken(text, "if", 1) == 0) {
+    if (FindStringToken(text, "if", 1)) {
+        if (!FindStringToken(text, "while", 1)) {
+            for (int i = 0; i < 6; ++i) {
+                destStrPos = FindStringToken(text, scriptEvaluationTokens[i + FUNC_MOD], 1);
+                if (destStrPos > -1) {
+                    strPos    = destStrPos;
+                    compareOp = i;
+                }
+            }
+            if (compareOp > -1) {
+                text[strPos] = ',';
+                StrCopy(dest, functions[compareOp + FUNC_WEQUAL].name);
+                StrAdd(dest, "(");
+                AppendIntegerToString(dest, jumpTableDataPos - jumpTableDataOffset);
+                StrAdd(dest, ",");
+                destStrPos = StrLength(dest);
+                for (int i = 5; text[i]; ++i) {
+                    if (text[i] != '=' && text[i] != '(' && text[i] != ')')
+                        dest[destStrPos++] = text[i];
+                }
+                dest[destStrPos] = 0;
+                StrAdd(dest, ")");
+                StrCopy(text, dest);
+                jumpTableStack[++jumpTableStackPos] = jumpTableDataPos;
+                jumpTableData[jumpTableDataPos++]   = scriptDataPos - scriptDataOffset;
+                jumpTableData[jumpTableDataPos++]   = 0;
+            }
+        }
+    }
+    else {
         for (int i = 0; i < 6; ++i) {
             destStrPos = FindStringToken(text, scriptEvaluationTokens[i + FUNC_MOD], 1);
             if (destStrPos > -1) {
@@ -1520,94 +1503,94 @@ void ConvertConditionalStatement(char *text)
                 compareOp = i;
             }
         }
-
         if (compareOp > -1) {
             text[strPos] = ',';
             StrCopy(dest, functions[compareOp + FUNC_IFEQUAL].name);
             StrAdd(dest, "(");
-            AppendIntegerToString(dest, jumpTablePos - jumpTableOffset);
+            AppendIntegerToString(dest, jumpTableDataPos - jumpTableDataOffset);
             StrAdd(dest, ",");
-
             destStrPos = StrLength(dest);
             for (int i = 2; text[i]; ++i) {
                 if (text[i] != '=' && text[i] != '(' && text[i] != ')')
                     dest[destStrPos++] = text[i];
             }
             dest[destStrPos] = 0;
-
             StrAdd(dest, ")");
             StrCopy(text, dest);
-
-            jumpTableStack[++jumpTableStackPos] = jumpTablePos;
-            jumpTable[jumpTablePos++]       = -1;
-            jumpTable[jumpTablePos++]       = 0;
+            jumpTableStack[++jumpTableStackPos] = jumpTableDataPos;
+            jumpTableData[jumpTableDataPos++]   = -1;
+            jumpTableData[jumpTableDataPos++]   = 0;
         }
     }
-    else if (FindStringToken(text, "while", 1) == 0) {
-        for (int i = 0; i < 6; ++i) {
-            destStrPos = FindStringToken(text, scriptEvaluationTokens[i + FUNC_MOD], 1);
-            if (destStrPos > -1) {
-                strPos    = destStrPos;
-                compareOp = i;
-            }
-        }
-
-        if (compareOp > -1) {
-            text[strPos] = ',';
-            StrCopy(dest, functions[compareOp + FUNC_WEQUAL].name);
-            StrAdd(dest, "(");
-            AppendIntegerToString(dest, jumpTablePos - jumpTableOffset);
-            StrAdd(dest, ",");
+}
+void ConvertForeachStatement(char *text)
+{
+    if (FindStringToken(text, "foreach", 1))
+        return;
+    char dest[260];
+    int destStrPos = 0;
 
-            destStrPos = StrLength(dest);
-            for (int i = 5; text[i]; ++i) {
-                if (text[i] != '=' && text[i] != '(' && text[i] != ')')
+    if (FindStringToken(text, "ACTIVE_ENTITIES", 1) > 0) { // foreach (just actively interacting entities)
+        StrCopy(dest, functions[FUNC_FOREACHACTIVE].name);
+        StrAdd(dest, "(");
+        AppendIntegerToString(dest, jumpTableDataPos - jumpTableDataOffset);
+        StrAdd(dest, ",");
+        destStrPos = StrLength(dest);
+        int cnt    = 0;
+        for (int i = 7; text[i]; ++i) {
+            if (text[i] != '(' && text[i] != ')' && text[i] != ',') {
+                dest[destStrPos++] = text[i];
+            }
+            else if (text[i] == ',') {
+                if (!cnt)
                     dest[destStrPos++] = text[i];
+                else
+                    break;
+                ++cnt;
             }
-            dest[destStrPos] = 0;
-
-            StrAdd(dest, ")");
-            StrCopy(text, dest);
-
-            jumpTableStack[++jumpTableStackPos] = jumpTablePos;
-            jumpTable[jumpTablePos++]       = scriptCodePos - scriptCodeOffset;
-            jumpTable[jumpTablePos++]       = 0;
         }
+        dest[destStrPos] = 0;
+        StrAdd(dest, ")");
+        StrCopy(text, dest);
+        jumpTableStack[++jumpTableStackPos] = jumpTableDataPos;
+        jumpTableData[jumpTableDataPos++]   = scriptDataPos - scriptDataOffset;
+        jumpTableData[jumpTableDataPos++]   = 0;
     }
-    else if (FindStringToken(text, "foreach", 1) == 0) {
-        int argStrPos = FindStringToken(text, ",", 2);
-
-        if (argStrPos > -1) {
-            StrCopy(dest, functions[text[argStrPos + 2] == 'C' ? (int)FUNC_FOREACHACTIVE : (int)FUNC_FOREACHALL].name);
-            StrAdd(dest, "(");
-            AppendIntegerToString(dest, jumpTablePos - jumpTableOffset);
-            StrAdd(dest, ",");
-
-            destStrPos = StrLength(dest);
-            for (int i = 7; text[i] && i < argStrPos; ++i) {
-                if (text[i] != '(' && text[i] != ')')
+    else if (FindStringToken(text, "ALL_ENTITIES", 1) > 0) { // foreach (all entities)
+        StrCopy(dest, functions[FUNC_FOREACHALL].name);
+        StrAdd(dest, "(");
+        AppendIntegerToString(dest, jumpTableDataPos - jumpTableDataOffset);
+        StrAdd(dest, ",");
+        destStrPos = StrLength(dest);
+        int cnt    = 0;
+        for (int i = 7; text[i] && cnt < 2; ++i) {
+            if (text[i] != '(' && text[i] != ')' && text[i] != ',') {
+                dest[destStrPos++] = text[i];
+            }
+            else if (text[i] == ',') {
+                if (!cnt)
                     dest[destStrPos++] = text[i];
+                else
+                    break;
+                ++cnt;
             }
-            dest[destStrPos] = 0;
-
-            StrAdd(dest, ")");
-            StrCopy(text, dest);
-
-            jumpTableStack[++jumpTableStackPos] = jumpTablePos;
-            jumpTable[jumpTablePos++]       = scriptCodePos - scriptCodeOffset;
-            jumpTable[jumpTablePos++]       = 0;
         }
+        dest[destStrPos] = 0;
+        StrAdd(dest, ")");
+        StrCopy(text, dest);
+        jumpTableStack[++jumpTableStackPos] = jumpTableDataPos;
+        jumpTableData[jumpTableDataPos++]   = scriptDataPos - scriptDataOffset;
+        jumpTableData[jumpTableDataPos++]   = 0;
     }
 }
 bool ConvertSwitchStatement(char *text)
 {
-    if (FindStringToken(text, "switch", 1) != 0)
+    if (FindStringToken(text, "switch", 1))
         return false;
-
     char switchText[260];
     StrCopy(switchText, "switch");
     StrAdd(switchText, "(");
-    AppendIntegerToString(switchText, jumpTablePos - jumpTableOffset);
+    AppendIntegerToString(switchText, jumpTableDataPos - jumpTableDataOffset);
     StrAdd(switchText, ",");
     int pos = StrLength(switchText);
     for (int i = 6; text[i]; ++i) {
@@ -1617,27 +1600,23 @@ bool ConvertSwitchStatement(char *text)
     switchText[pos] = 0;
     StrAdd(switchText, ")");
     StrCopy(text, switchText);
-    jumpTableStack[++jumpTableStackPos] = jumpTablePos;
-    jumpTable[jumpTablePos++]       = 0x10000;
-    jumpTable[jumpTablePos++]       = -0x10000;
-    jumpTable[jumpTablePos++]       = -1;
-    jumpTable[jumpTablePos++]       = 0;
-
+    jumpTableStack[++jumpTableStackPos] = jumpTableDataPos;
+    jumpTableData[jumpTableDataPos++]   = 0x10000;
+    jumpTableData[jumpTableDataPos++]   = -0x10000;
+    jumpTableData[jumpTableDataPos++]   = -1;
+    jumpTableData[jumpTableDataPos++]   = 0;
     return true;
 }
 void ConvertFunctionText(char *text)
 {
     char arrayStr[0x80];
     char funcName[132];
-
     int opcode     = 0;
     int opcodeSize = 0;
     int textPos    = 0;
     int namePos    = 0;
-
     for (namePos = 0; text[namePos] != '(' && text[namePos]; ++namePos) funcName[namePos] = text[namePos];
     funcName[namePos] = 0;
-
     for (int i = 0; i < FUNC_MAX_CNT; ++i) {
         if (StrComp(funcName, functions[i].name)) {
             opcode     = i;
@@ -1646,7 +1625,6 @@ void ConvertFunctionText(char *text)
             i          = FUNC_MAX_CNT;
         }
     }
-
     if (opcode <= 0) {
         SetupTextMenu(&gameMenu[0], 0);
         AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
@@ -1664,36 +1642,36 @@ void ConvertFunctionText(char *text)
         Engine.gameMode = ENGINE_SCRIPTERROR;
     }
     else {
-        scriptCode[scriptCodePos++] = opcode;
+        scriptData[scriptDataPos++] = opcode;
         if (StrComp("else", functions[opcode].name))
-            jumpTable[jumpTableStack[jumpTableStackPos]] = scriptCodePos - scriptCodeOffset;
+            jumpTableData[jumpTableStack[jumpTableStackPos]] = scriptDataPos - scriptDataOffset;
 
         if (StrComp("endif", functions[opcode].name) == 1) {
             int jPos                = jumpTableStack[jumpTableStackPos];
-            jumpTable[jPos + 1] = scriptCodePos - scriptCodeOffset;
-            if (jumpTable[jPos] == -1)
-                jumpTable[jPos] = (scriptCodePos - scriptCodeOffset) - 1;
+            jumpTableData[jPos + 1] = scriptDataPos - scriptDataOffset;
+            if (jumpTableData[jPos] == -1)
+                jumpTableData[jPos] = (scriptDataPos - scriptDataOffset) - 1;
             --jumpTableStackPos;
         }
 
         if (StrComp("endswitch", functions[opcode].name)) {
             int jPos                = jumpTableStack[jumpTableStackPos];
-            jumpTable[jPos + 3] = scriptCodePos - scriptCodeOffset;
-            if (jumpTable[jPos + 2] == -1) {
-                jumpTable[jPos + 2] = (scriptCodePos - scriptCodeOffset) - 1;
-                int caseCnt             = abs(jumpTable[jPos + 1] - jumpTable[jPos]) + 1;
+            jumpTableData[jPos + 3] = scriptDataPos - scriptDataOffset;
+            if (jumpTableData[jPos + 2] == -1) {
+                jumpTableData[jPos + 2] = (scriptDataPos - scriptDataOffset) - 1;
+                int caseCnt             = abs(jumpTableData[jPos + 1] - jumpTableData[jPos]) + 1;
 
                 int jOffset = jPos + 4;
                 for (int c = 0; c < caseCnt; ++c) {
-                    if (jumpTable[jOffset + c] < 0)
-                        jumpTable[jOffset + c] = jumpTable[jPos + 2];
+                    if (jumpTableData[jOffset + c] < 0)
+                        jumpTableData[jOffset + c] = jumpTableData[jPos + 2];
                 }
             }
             --jumpTableStackPos;
         }
 
         if (StrComp("loop", functions[opcode].name) || StrComp("next", functions[opcode].name)) {
-            jumpTable[jumpTableStack[jumpTableStackPos--] + 1] = scriptCodePos - scriptCodeOffset;
+            jumpTableData[jumpTableStack[jumpTableStackPos--] + 1] = scriptDataPos - scriptDataOffset;
         }
 
         for (int i = 0; i < opcodeSize; ++i) {
@@ -1716,7 +1694,6 @@ void ConvertFunctionText(char *text)
                             funcName[funcNamePos++] = text[textPos];
                         ++textPos;
                         break;
-
                     case 1: // array val
                         if (text[textPos] == ']')
                             mode = 0;
@@ -1728,7 +1705,6 @@ void ConvertFunctionText(char *text)
                             arrayStr[arrayStrPos++] = text[textPos];
                         ++textPos;
                         break;
-
                     case 2: // string
                         if (text[textPos] == '"') {
                             mode                    = prevMode;
@@ -1743,11 +1719,22 @@ void ConvertFunctionText(char *text)
             funcName[funcNamePos] = 0;
             arrayStr[arrayStrPos] = 0;
 
-            for (int v = 0; v < scriptValueListCount; ++v) {
-                if (StrComp(funcName, scriptValueList[v].name)) {
-                    CopyAliasStr(funcName, scriptValueList[v].value, 0);
-                    if (FindStringToken(scriptValueList[v].value, "[", 1) > -1)
-                        CopyAliasStr(arrayStr, scriptValueList[v].value, 1);
+            int value = 0;
+            // Eg: temp0 = FX_SCALE
+            // Private (this script only)
+            for (int a = 0; a < privateAliasCount; ++a) {
+                if (StrComp(funcName, privateAliases[a].name)) {
+                    CopyAliasStr(funcName, privateAliases[a].value, 0);
+                    if (FindStringToken(privateAliases[a].value, "[", 1) > -1)
+                        CopyAliasStr(arrayStr, privateAliases[a].value, 1);
+                }
+            }
+            // Public (this script & all following scripts)
+            for (int a = 0; a < publicAliasCount; ++a) {
+                if (StrComp(funcName, publicAliases[a].name)) {
+                    CopyAliasStr(funcName, publicAliases[a].value, 0);
+                    if (FindStringToken(publicAliases[a].value, "[", 1) > -1)
+                        CopyAliasStr(arrayStr, publicAliases[a].value, 1);
                 }
             }
 
@@ -1760,10 +1747,24 @@ void ConvertFunctionText(char *text)
                 while (arrayStr[arrPos]) arrStrBuf[bufPos++] = arrayStr[arrPos++];
                 arrStrBuf[bufPos] = 0;
 
-                for (int v = 0; v < scriptValueListCount; ++v) {
-                    if (StrComp(arrStrBuf, scriptValueList[v].name)) {
+                // Private (this script only)
+                for (int a = 0; a < privateAliasCount; ++a) {
+                    if (StrComp(arrStrBuf, privateAliases[a].name)) {
                         char pref = arrayStr[0];
-                        CopyAliasStr(arrayStr, scriptValueList[v].value, 0);
+                        CopyAliasStr(arrayStr, privateAliases[a].value, 0);
+
+                        if (pref == '+' || pref == '-') {
+                            int len = StrLength(arrayStr);
+                            for (int i = len; i >= 0; --i) arrayStr[i + 1] = arrayStr[i];
+                            arrayStr[0] = pref;
+                        }
+                    }
+                }
+                // Public (this script & all following scripts)
+                for (int a = 0; a < publicAliasCount; ++a) {
+                    if (StrComp(arrStrBuf, publicAliases[a].name)) {
+                        char pref = arrayStr[0];
+                        CopyAliasStr(arrayStr, publicAliases[a].value, 0);
 
                         if (pref == '+' || pref == '-') {
                             int len = StrLength(arrayStr);
@@ -1774,6 +1775,42 @@ void ConvertFunctionText(char *text)
                 }
             }
 
+            // Eg: temp0 = value0
+            // Private (this script only)
+            for (int s = 0; s < privateStaticVarCount; ++s) {
+                if (StrComp(funcName, privateStaticVariables[s].name)) {
+                    StrCopy(funcName, "local");
+                    arrayStr[0] = 0;
+                    AppendIntegerToString(arrayStr, privateStaticVariables[s].dataPos);
+                }
+            }
+            // Public (this script & all following scripts)
+            for (int s = 0; s < publicStaticVarCount; ++s) {
+                if (StrComp(funcName, publicStaticVariables[s].name)) {
+                    StrCopy(funcName, "local");
+                    arrayStr[0] = 0;
+                    AppendIntegerToString(arrayStr, publicStaticVariables[s].dataPos);
+                }
+            }
+
+            // Eg: GetTableValue(temp0, 1, arrayPos0)
+            // Private (this script only)
+            for (int a = 0; a < privateTableCount; ++a) {
+                if (StrComp(funcName, privateTables[a].name)) {
+                    funcName[0] = 0;
+                    AppendIntegerToString(funcName, privateTables[a].dataPos);
+                    arrayStr[0] = 0;
+                }
+            }
+            // Public (this script & all following scripts)
+            for (int a = 0; a < publicTableCount; ++a) {
+                if (StrComp(funcName, publicTables[a].name)) {
+                    funcName[0] = 0;
+                    AppendIntegerToString(funcName, publicTables[a].dataPos);
+                    arrayStr[0] = 0;
+                }
+            }
+
             // Eg: temp0 = game.variable
             for (int v = 0; v < globalVariablesCount; ++v) {
                 if (StrComp(funcName, globalVariableNames[v])) {
@@ -1782,10 +1819,9 @@ void ConvertFunctionText(char *text)
                     AppendIntegerToString(arrayStr, v);
                 }
             }
-
             // Eg: temp0 = Function1
             for (int f = 0; f < scriptFunctionCount; ++f) {
-                if (StrComp(funcName, scriptFunctionList[f].name)) {
+                if (StrComp(funcName, scriptFunctionNames[f])) {
                     funcName[0] = 0;
                     AppendIntegerToString(funcName, f);
                 }
@@ -1793,9 +1829,8 @@ void ConvertFunctionText(char *text)
 
             // Eg: temp0 = TypeName[Player Object]
             if (StrComp(funcName, "TypeName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
+                funcName[0] = 0;
+                AppendIntegerToString(funcName, 0);
                 int o = 0;
                 for (; o < OBJECT_COUNT; ++o) {
                     if (StrComp(arrayStr, typeNames[o])) {
@@ -1805,16 +1840,15 @@ void ConvertFunctionText(char *text)
                     }
                 }
 
-                if (o == OBJECT_COUNT)
+                if (o == OBJECT_COUNT) {
                     PrintLog("WARNING: Unknown typename \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
-#if !RETRO_USE_ORIGINAL_CODE
             // Eg: temp0 = SfxName[Jump]
             if (StrComp(funcName, "SfxName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
+                funcName[0] = 0;
+                AppendIntegerToString(funcName, 0);
                 int s = 0;
                 for (; s < SFX_COUNT; ++s) {
                     if (StrComp(arrayStr, sfxNames[s])) {
@@ -1824,15 +1858,15 @@ void ConvertFunctionText(char *text)
                     }
                 }
 
-                if (s == SFX_COUNT)
+                if (s == SFX_COUNT) {
                     PrintLog("WARNING: Unknown sfxName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = VarName[player.lives]
             if (StrComp(funcName, "VarName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
+                funcName[0] = 0;
+                AppendIntegerToString(funcName, 0);
                 int v = 0;
                 for (; v < globalVariablesCount; ++v) {
                     if (StrComp(arrayStr, globalVariableNames[v])) {
@@ -1842,15 +1876,16 @@ void ConvertFunctionText(char *text)
                     }
                 }
 
-                if (v == globalVariablesCount)
+                if (v == globalVariablesCount) {
                     PrintLog("WARNING: Unknown varName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
+#if !RETRO_USE_ORIGINAL_CODE
             // Eg: temp0 = AchievementName[Ring King]
             if (StrComp(funcName, "AchievementName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
+                funcName[0] = 0;
+                AppendIntegerToString(funcName, 0);
                 int a = 0;
                 for (; a < achievementCount; ++a) {
                     char buf[0x40];
@@ -1871,15 +1906,15 @@ void ConvertFunctionText(char *text)
                     }
                 }
 
-                if (a == achievementCount)
+                if (a == achievementCount) {
                     PrintLog("WARNING: Unknown AchievementName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = PlayerName[SONIC]
             if (StrComp(funcName, "PlayerName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
+                funcName[0] = 0;
+                AppendIntegerToString(funcName, 0);
                 int p = 0;
                 for (; p < PLAYER_COUNT; ++p) {
                     char buf[0x40];
@@ -1900,16 +1935,15 @@ void ConvertFunctionText(char *text)
                     }
                 }
 
-                if (p == PLAYER_COUNT)
+                if (p == PLAYER_COUNT) {
                     PrintLog("WARNING: Unknown PlayerName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = StageName[R - GREEN HILL ZONE 1]
             if (StrComp(funcName, "StageName")) {
-                funcName[0] = '0';
-                funcName[1] = 0;
-
-                int s = -1;
+                funcName[0] = 0;
+                int s       = -1;
                 if (StrLength(arrayStr) >= 2) {
                     char list = arrayStr[0];
                     switch (list) {
@@ -1922,9 +1956,7 @@ void ConvertFunctionText(char *text)
                 }
 
                 if (s == -1) {
-                    char buf[0x40];
-                    sprintf(buf, "WARNING: Unknown StageName \"%s\", on line %d", arrayStr, lineID);
-                    PrintLog(buf);
+                    PrintLog("WARNING: Unknown StageName \"%s\", on line %d", arrayStr, lineID);
                     s = 0;
                 }
                 funcName[0] = 0;
@@ -1933,45 +1965,38 @@ void ConvertFunctionText(char *text)
 #endif
 
             // Storing Values
-            int constant = 0;
-            if (ConvertStringToInteger(funcName, &constant)) {
-                scriptCode[scriptCodePos++] = SCRIPTVAR_INTCONST;
-                scriptCode[scriptCodePos++] = constant;
+            if (ConvertStringToInteger(funcName, &value)) {
+                scriptData[scriptDataPos++] = SCRIPTVAR_INTCONST;
+                scriptData[scriptDataPos++] = value;
             }
             else if (funcName[0] == '"') {
-                scriptCode[scriptCodePos++] = SCRIPTVAR_STRCONST;
-                scriptCode[scriptCodePos++] = StrLength(funcName) - 2;
-
-                int scriptTextPos = 1;
-                arrayStrPos       = 0;
+                scriptData[scriptDataPos++] = SCRIPTVAR_STRCONST;
+                scriptData[scriptDataPos++] = StrLength(funcName) - 2;
+                int scriptTextPos           = 1;
+                arrayStrPos                 = 0;
                 while (scriptTextPos > -1) {
                     switch (arrayStrPos) {
                         case 0:
-                            scriptCode[scriptCodePos] = funcName[scriptTextPos] << 24;
+                            scriptData[scriptDataPos] = funcName[scriptTextPos] << 24;
                             ++arrayStrPos;
                             break;
-
                         case 1:
-                            scriptCode[scriptCodePos] += funcName[scriptTextPos] << 16;
+                            scriptData[scriptDataPos] += funcName[scriptTextPos] << 16;
                             ++arrayStrPos;
                             break;
-
                         case 2:
-                            scriptCode[scriptCodePos] += funcName[scriptTextPos] << 8;
+                            scriptData[scriptDataPos] += funcName[scriptTextPos] << 8;
                             ++arrayStrPos;
                             break;
-
                         case 3:
-                            scriptCode[scriptCodePos++] += funcName[scriptTextPos];
+                            scriptData[scriptDataPos++] += funcName[scriptTextPos];
                             arrayStrPos = 0;
                             break;
-
                         default: break;
                     }
-
                     if (funcName[scriptTextPos] == '"') {
                         if (arrayStrPos > 0)
-                            ++scriptCodePos;
+                            ++scriptDataPos;
                         scriptTextPos = -1;
                     }
                     else {
@@ -1980,62 +2005,54 @@ void ConvertFunctionText(char *text)
                 }
             }
             else {
-                scriptCode[scriptCodePos++] = SCRIPTVAR_VAR;
-
+                scriptData[scriptDataPos++] = SCRIPTVAR_VAR;
                 if (arrayStr[0]) {
-                    scriptCode[scriptCodePos] = VARARR_ARRAY;
-
+                    scriptData[scriptDataPos] = VARARR_ARRAY;
                     if (arrayStr[0] == '+')
-                        scriptCode[scriptCodePos] = VARARR_ENTNOPLUS1;
-
+                        scriptData[scriptDataPos] = VARARR_ENTNOPLUS1;
                     if (arrayStr[0] == '-')
-                        scriptCode[scriptCodePos] = VARARR_ENTNOMINUS1;
-
-                    ++scriptCodePos;
-
+                        scriptData[scriptDataPos] = VARARR_ENTNOMINUS1;
+                    ++scriptDataPos;
                     if (arrayStr[0] == '-' || arrayStr[0] == '+') {
                         for (int i = 0; i < StrLength(arrayStr); ++i) arrayStr[i] = arrayStr[i + 1];
                     }
-
-                    if (ConvertStringToInteger(arrayStr, &constant) == 1) {
-                        scriptCode[scriptCodePos++] = 0;
-                        scriptCode[scriptCodePos++] = constant;
+                    if (ConvertStringToInteger(arrayStr, &value) == 1) {
+                        scriptData[scriptDataPos++] = 0;
+                        scriptData[scriptDataPos++] = value;
                     }
                     else {
                         if (StrComp(arrayStr, "arrayPos0"))
-                            constant = 0;
+                            value = 0;
                         if (StrComp(arrayStr, "arrayPos1"))
-                            constant = 1;
+                            value = 1;
                         if (StrComp(arrayStr, "arrayPos2"))
-                            constant = 2;
+                            value = 2;
                         if (StrComp(arrayStr, "arrayPos3"))
-                            constant = 3;
+                            value = 3;
                         if (StrComp(arrayStr, "arrayPos4"))
-                            constant = 4;
+                            value = 4;
                         if (StrComp(arrayStr, "arrayPos5"))
-                            constant = 5;
+                            value = 5;
                         if (StrComp(arrayStr, "arrayPos6"))
-                            constant = 6;
+                            value = 6;
                         if (StrComp(arrayStr, "arrayPos7"))
-                            constant = 7;
+                            value = 7;
                         if (StrComp(arrayStr, "tempObjectPos"))
-                            constant = 8;
-
-                        scriptCode[scriptCodePos++] = 1;
-                        scriptCode[scriptCodePos++] = constant;
+                            value = 8;
+                        scriptData[scriptDataPos++] = 1;
+                        scriptData[scriptDataPos++] = value;
                     }
                 }
                 else {
-                    scriptCode[scriptCodePos++] = VARARR_NONE;
+                    scriptData[scriptDataPos++] = VARARR_NONE;
                 }
-
-                constant = -1;
+                value = -1;
                 for (int i = 0; i < VAR_MAX_CNT; ++i) {
                     if (StrComp(funcName, variableNames[i]))
-                        constant = i;
+                        value = i;
                 }
 
-                if (constant == -1 && Engine.gameMode != ENGINE_SCRIPTERROR) {
+                if (value == -1 && Engine.gameMode != ENGINE_SCRIPTERROR) {
                     SetupTextMenu(&gameMenu[0], 0);
                     AddTextMenuEntry(&gameMenu[0], "SCRIPT PARSING FAILED");
                     AddTextMenuEntry(&gameMenu[0], " ");
@@ -2047,32 +2064,35 @@ void ConvertFunctionText(char *text)
                     AppendIntegerToString(funcName, lineID);
                     AddTextMenuEntry(&gameMenu[0], funcName);
                     Engine.gameMode = ENGINE_SCRIPTERROR;
-                    constant        = 0;
+                    value           = 0;
                 }
-
-                scriptCode[scriptCodePos++] = constant;
+                scriptData[scriptDataPos++] = value;
             }
         }
     }
 }
 void CheckCaseNumber(char *text)
 {
-    if (FindStringToken(text, "case", 1) != 0)
+    if (FindStringToken(text, "case", 1))
         return;
 
     char caseString[128];
-    char caseChar = text[4];
-
-    int textPos    = 5;
     int caseStrPos = 0;
-    while (caseChar) {
-        if (caseChar != ':')
-            caseString[caseStrPos++] = caseChar;
-        caseChar = text[textPos++];
+    char caseChar  = text[4];
+    if (text[4]) {
+        int textPos = 5;
+        do {
+            if (caseChar != ':')
+                caseString[caseStrPos++] = caseChar;
+            caseChar = text[textPos++];
+        } while (caseChar);
+    }
+    else {
+        caseStrPos = 0;
     }
     caseString[caseStrPos] = 0;
 
-    bool foundValue = false;
+    bool flag = false;
 
     if (FindStringToken(caseString, "[", 1) >= 0) {
         char caseValue[0x80];
@@ -2103,9 +2123,8 @@ void CheckCaseNumber(char *text)
 
         // Eg: temp0 = TypeName[Player Object]
         if (StrComp(caseValue, "TypeName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
+            caseValue[0] = 0;
+            AppendIntegerToString(caseValue, 0);
             int o = 0;
             for (; o < OBJECT_COUNT; ++o) {
                 if (StrComp(arrayStr, typeNames[o])) {
@@ -2115,15 +2134,15 @@ void CheckCaseNumber(char *text)
                 }
             }
 
-            if (o == OBJECT_COUNT)
+            if (o == OBJECT_COUNT) {
                 PrintLog("WARNING: Unknown typename \"%s\", on line %d", arrayStr, lineID);
+            }
         }
 
         // Eg: temp0 = SfxName[Jump]
         if (StrComp(caseValue, "SfxName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
+            caseValue[0] = 0;
+            AppendIntegerToString(caseValue, 0);
             int s = 0;
             for (; s < SFX_COUNT; ++s) {
                 if (StrComp(arrayStr, sfxNames[s])) {
@@ -2133,16 +2152,15 @@ void CheckCaseNumber(char *text)
                 }
             }
 
-            if (s == SFX_COUNT)
+            if (s == SFX_COUNT) {
                 PrintLog("WARNING: Unknown sfxName \"%s\", on line %d", arrayStr, lineID);
+            }
         }
 
-#if !RETRO_USE_ORIGINAL_CODE
         // Eg: temp0 = VarName[player.lives]
         if (StrComp(caseValue, "VarName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
+            caseValue[0] = 0;
+            AppendIntegerToString(caseValue, 0);
             int v = 0;
             for (; v < globalVariablesCount; ++v) {
                 if (StrComp(arrayStr, globalVariableNames[v])) {
@@ -2157,11 +2175,11 @@ void CheckCaseNumber(char *text)
             }
         }
 
+#if !RETRO_USE_ORIGINAL_CODE
         // Eg: temp0 = AchievementName[Ring King]
         if (StrComp(caseValue, "AchievementName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
+            caseValue[0] = 0;
+            AppendIntegerToString(caseValue, 0);
             int a = 0;
             for (; a < achievementCount; ++a) {
                 char buf[0x40];
@@ -2189,9 +2207,8 @@ void CheckCaseNumber(char *text)
 
         // Eg: temp0 = PlayerName[SONIC]
         if (StrComp(caseValue, "PlayerName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
+            caseValue[0] = 0;
+            AppendIntegerToString(caseValue, 0);
             int p = 0;
             for (; p < PLAYER_COUNT; ++p) {
                 char buf[0x40];
@@ -2219,10 +2236,8 @@ void CheckCaseNumber(char *text)
 
         // Eg: temp0 = StageName[R - GREEN HILL ZONE 1]
         if (StrComp(caseValue, "StageName")) {
-            caseValue[0] = '0';
-            caseValue[1] = 0;
-
-            int s = -1;
+            caseValue[0] = 0;
+            int s        = -1;
             if (StrLength(arrayStr) >= 2) {
                 char list = arrayStr[0];
                 switch (list) {
@@ -2243,12 +2258,20 @@ void CheckCaseNumber(char *text)
         }
 #endif
         StrCopy(caseString, caseValue);
-        foundValue = true;
+        flag = true;
+    }
+
+    for (int a = 0; a < privateAliasCount && !flag; ++a) {
+        if (StrComp(privateAliases[a].name, caseString)) {
+            StrCopy(caseString, privateAliases[a].value);
+            flag = true;
+            break;
+        }
     }
 
-    for (int a = 0; a < scriptValueListCount && !foundValue; ++a) {
-        if (StrComp(scriptValueList[a].name, caseString)) {
-            StrCopy(caseString, scriptValueList[a].value);
+    for (int a = 0; a < publicAliasCount && !flag; ++a) {
+        if (StrComp(publicAliases[a].name, caseString)) {
+            StrCopy(caseString, publicAliases[a].value);
             break;
         }
     }
@@ -2256,11 +2279,11 @@ void CheckCaseNumber(char *text)
     int caseID = 0;
     if (ConvertStringToInteger(caseString, &caseID)) {
         int stackValue = jumpTableStack[jumpTableStackPos];
-        if (caseID < jumpTable[stackValue])
-            jumpTable[stackValue] = caseID;
+        if (caseID < jumpTableData[stackValue])
+            jumpTableData[stackValue] = caseID;
         stackValue++;
-        if (caseID > jumpTable[stackValue])
-            jumpTable[stackValue] = caseID;
+        if (caseID > jumpTableData[stackValue])
+            jumpTableData[stackValue] = caseID;
     }
     else {
         PrintLog("WARNING: unable to convert case string \"%s\" to int, on line %d", caseString, lineID);
@@ -2269,7 +2292,24 @@ void CheckCaseNumber(char *text)
 bool ReadSwitchCase(char *text)
 {
     char caseText[0x80];
-    if (FindStringToken(text, "case", 1) == 0) {
+    if (FindStringToken(text, "case", 1)) {
+        if (FindStringToken(text, "default", 1)) {
+            return false;
+        }
+        else {
+            int jumpTablepos                = jumpTableStack[jumpTableStackPos];
+            jumpTableData[jumpTablepos + 2] = scriptDataPos - scriptDataOffset;
+            int cnt                         = abs(jumpTableData[jumpTablepos + 1] - jumpTableData[jumpTablepos]) + 1;
+
+            int jOffset = jumpTablepos + 4;
+            for (int i = 0; i < cnt; ++i) {
+                if (jumpTableData[jOffset + i] < 0)
+                    jumpTableData[jOffset + i] = scriptDataPos - scriptDataOffset;
+            }
+            return true;
+        }
+    }
+    else {
         int textPos       = 4;
         int caseStringPos = 0;
         while (text[textPos]) {
@@ -2279,7 +2319,7 @@ bool ReadSwitchCase(char *text)
         }
         caseText[caseStringPos] = 0;
 
-        bool foundValue = false;
+        bool flag = false;
         if (FindStringToken(caseText, "[", 1) >= 0) {
             char caseValue[0x80];
             char arrayStr[0x80];
@@ -2309,9 +2349,8 @@ bool ReadSwitchCase(char *text)
 
             // Eg: temp0 = TypeName[Player Object]
             if (StrComp(caseValue, "TypeName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
+                caseValue[0] = 0;
+                AppendIntegerToString(caseValue, 0);
                 int o = 0;
                 for (; o < OBJECT_COUNT; ++o) {
                     if (StrComp(arrayStr, typeNames[o])) {
@@ -2321,15 +2360,15 @@ bool ReadSwitchCase(char *text)
                     }
                 }
 
-                if (o == OBJECT_COUNT)
+                if (o == OBJECT_COUNT) {
                     PrintLog("WARNING: Unknown typename \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = SfxName[Jump]
             if (StrComp(caseValue, "SfxName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
+                caseValue[0] = 0;
+                AppendIntegerToString(caseValue, 0);
                 int s = 0;
                 for (; s < SFX_COUNT; ++s) {
                     if (StrComp(arrayStr, sfxNames[s])) {
@@ -2339,16 +2378,15 @@ bool ReadSwitchCase(char *text)
                     }
                 }
 
-                if (s == SFX_COUNT)
+                if (s == SFX_COUNT) {
                     PrintLog("WARNING: Unknown sfxName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
-#if !RETRO_USE_ORIGINAL_CODE
             // Eg: temp0 = VarName[player.lives]
             if (StrComp(caseValue, "VarName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
+                caseValue[0] = 0;
+                AppendIntegerToString(caseValue, 0);
                 int v = 0;
                 for (; v < globalVariablesCount; ++v) {
                     if (StrComp(arrayStr, globalVariableNames[v])) {
@@ -2358,15 +2396,16 @@ bool ReadSwitchCase(char *text)
                     }
                 }
 
-                if (v == globalVariablesCount)
+                if (v == globalVariablesCount) {
                     PrintLog("WARNING: Unknown varName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
+#if !RETRO_USE_ORIGINAL_CODE
             // Eg: temp0 = AchievementName[Ring King]
             if (StrComp(caseValue, "AchievementName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
+                caseValue[0] = 0;
+                AppendIntegerToString(caseValue, 0);
                 int a = 0;
                 for (; a < achievementCount; ++a) {
                     char buf[0x40];
@@ -2387,15 +2426,15 @@ bool ReadSwitchCase(char *text)
                     }
                 }
 
-                if (a == achievementCount)
+                if (a == achievementCount) {
                     PrintLog("WARNING: Unknown AchievementName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = PlayerName[SONIC]
             if (StrComp(caseValue, "PlayerName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
+                caseValue[0] = 0;
+                AppendIntegerToString(caseValue, 0);
                 int p = 0;
                 for (; p < PLAYER_COUNT; ++p) {
                     char buf[0x40];
@@ -2416,16 +2455,15 @@ bool ReadSwitchCase(char *text)
                     }
                 }
 
-                if (p == PLAYER_COUNT)
+                if (p == PLAYER_COUNT) {
                     PrintLog("WARNING: Unknown PlayerName \"%s\", on line %d", arrayStr, lineID);
+                }
             }
 
             // Eg: temp0 = StageName[R - GREEN HILL ZONE 1]
             if (StrComp(caseValue, "StageName")) {
-                caseValue[0] = '0';
-                caseValue[1] = 0;
-
-                int s = -1;
+                caseValue[0] = 0;
+                int s        = -1;
                 if (StrLength(arrayStr) >= 2) {
                     char list = arrayStr[0];
                     switch (list) {
@@ -2446,12 +2484,20 @@ bool ReadSwitchCase(char *text)
             }
 #endif
             StrCopy(caseText, caseValue);
-            foundValue = true;
+            flag = true;
         }
 
-        for (int v = 0; v < scriptValueListCount && !foundValue; ++v) {
-            if (StrComp(caseText, scriptValueList[v].name)) {
-                StrCopy(caseText, scriptValueList[v].value);
+        for (int a = 0; a < privateAliasCount && !flag; ++a) {
+            if (StrComp(caseText, privateAliases[a].name)) {
+                StrCopy(caseText, privateAliases[a].value);
+                flag = true;
+                break;
+            }
+        }
+
+        for (int a = 0; a < publicAliasCount && !flag; ++a) {
+            if (StrComp(caseText, publicAliases[a].name)) {
+                StrCopy(caseText, publicAliases[a].value);
                 break;
             }
         }
@@ -2461,63 +2507,57 @@ bool ReadSwitchCase(char *text)
         int jPos    = jumpTableStack[jumpTableStackPos];
         int jOffset = jPos + 4;
         if (ConvertStringToInteger(caseText, &val))
-            jumpTable[val - jumpTable[jPos] + jOffset] = scriptCodePos - scriptCodeOffset;
+            jumpTableData[val - jumpTableData[jPos] + jOffset] = scriptDataPos - scriptDataOffset;
         else
             PrintLog("WARNING: unable to read case string \"%s\" as an int, on line %d", caseText, lineID);
-
-        return true;
-    }
-    else if (FindStringToken(text, "default", 1) == 0) {
-        int jumpTablepos                = jumpTableStack[jumpTableStackPos];
-        jumpTable[jumpTablepos + 2] = scriptCodePos - scriptCodeOffset;
-        int cnt                         = abs(jumpTable[jumpTablepos + 1] - jumpTable[jumpTablepos]) + 1;
-
-        int jOffset = jumpTablepos + 4;
-        for (int i = 0; i < cnt; ++i) {
-            if (jumpTable[jOffset + i] < 0)
-                jumpTable[jOffset + i] = scriptCodePos - scriptCodeOffset;
-        }
-
         return true;
     }
-
     return false;
 }
 void ReadTableValues(char *text)
 {
-    int textStrPos = 0;
-
-    char valueBuffer[256];
-    int valueBufferPos = 0;
+    int textPos = 0;
+    char strBuffer[0x20];
+    int strPos = 0;
+    while (true) {
+        if (text[textPos] == ',' || !text[textPos]) {
+            strBuffer[strPos] = 0;
+            if (strBuffer[0]) { // only try if something exists
+                int cnt = currentTable->valueCount;
+
+                if (!ConvertStringToInteger(strBuffer, &currentTable->values[cnt].value)) {
+                    bool flag = false;
+                    for (int a = 0; a < privateAliasCount; ++a) {
+                        if (StrComp(privateAliases[a].name, strBuffer)) {
+                            StrCopy(strBuffer, privateAliases[a].value);
+                            flag = true;
+                            break;
+                        }
+                    }
 
-    while (text[textStrPos]) {
-        valueBuffer[valueBufferPos++] = text[textStrPos++];
+                    for (int a = 0; a < publicAliasCount && !flag; ++a) {
+                        if (StrComp(publicAliases[a].name, strBuffer)) {
+                            StrCopy(strBuffer, publicAliases[a].value);
+                            break;
+                        }
+                    }
 
-        while (text[textStrPos] == ',') {
-            valueBuffer[valueBufferPos] = 0;
-            ++scriptCode[scriptCodeOffset];
-            if (!ConvertStringToInteger(valueBuffer, &scriptCode[scriptCodePos])) {
-                scriptCode[scriptCodePos] = 0;
-#if !RETRO_USE_ORIGINAL_CODE
-                PrintLog("WARNING: unable to parse table value \"%s\" as an int, on line %d", valueBuffer, lineID);
-#endif
+                    if (!ConvertStringToInteger(strBuffer, &currentTable->values[cnt].value)) {
+                        PrintLog("WARNING: unable to convert table var %d value \"%s\" to int, on line %d", cnt, strBuffer, lineID);
+                    }
+                }
+                currentTable->valueCount++;
             }
-            scriptCodePos++;
-            valueBufferPos = 0;
-            textStrPos++;
-        }
-    }
 
-    if (StrLength(valueBuffer)) {
-        valueBuffer[valueBufferPos] = 0;
-        ++scriptCode[scriptCodeOffset];
-        if (!ConvertStringToInteger(valueBuffer, &scriptCode[scriptCodePos])) {
-            scriptCode[scriptCodePos] = 0;
-#if !RETRO_USE_ORIGINAL_CODE
-            PrintLog("WARNING: unable to parse table value \"%s\" as an int, on line %d", valueBuffer, lineID);
-#endif
+            strPos = 0;
+
+            if (!text[textPos])
+                break;
+        }
+        else {
+            strBuffer[strPos++] = text[textPos];
         }
-        scriptCodePos++;
+        textPos++;
     }
 }
 void AppendIntegerToString(char *text, int value)
@@ -2607,12 +2647,10 @@ bool ConvertStringToInteger(const char *text, int *value)
     if (text[charID] == '0') {
         if (text[charID + 1] == 'x' || text[charID + 1] == 'X')
             base = 0x10;
-#if !RETRO_USE_ORIGINAL_CODE
         else if (text[charID + 1] == 'b' || text[charID + 1] == 'B')
             base = 0b10;
         else if (text[charID + 1] == 'o' || text[charID + 1] == 'O')
             base = 0010; // base 8
-#endif
 
         if (base != 10) {
             charID += 2;
@@ -2625,12 +2663,10 @@ bool ConvertStringToInteger(const char *text, int *value)
         if (!flag) {
             if (base == 0x10 && text[charID] > 'f')
                 flag = true;
-#if !RETRO_USE_ORIGINAL_CODE
             if (base == 0010 && text[charID] > '7')
                 flag = true;
             if (base == 0b10 && text[charID] > '1')
                 flag = true;
-#endif
         }
 
         if (flag) {
@@ -2672,10 +2708,8 @@ bool ConvertStringToInteger(const char *text, int *value)
         --strLength;
         ++charID;
     }
-
     if (negative)
         *value = -*value;
-
     return true;
 }
 
@@ -2737,35 +2771,14 @@ void ParseScriptFile(char *scriptName, int scriptID)
     jumpTableStackPos = 0;
     lineID            = 0;
 
-    for (int f = 0; f < scriptFunctionCount; ++f) {
-        if (scriptFunctionList[f].access != ACCESS_PUBLIC)
-            StrCopy(scriptFunctionList[f].name, "");
-    }
-
-    int newScriptValueCount = COMMON_SCRIPT_VAR_COUNT;
-    for (int v = COMMON_SCRIPT_VAR_COUNT; v < scriptValueListCount; ++v) {
-        if (scriptValueList[v].access != ACCESS_PUBLIC) {
-            StrCopy(scriptValueList[v].name, "");
-        }
-        else {
-            if (newScriptValueCount != v)
-                memcpy(&scriptValueList[newScriptValueCount], &scriptValueList[v], sizeof(ScriptVariableInfo));
-
-            newScriptValueCount++;
-        }
-    }
-    scriptValueListCount = newScriptValueCount;
-
-    for (int v = scriptValueListCount; v < SCRIPT_VAR_COUNT; ++v) {
-        MEM_ZERO(scriptValueList[v]);
-    }
+    privateAliasCount     = 0;
+    privateStaticVarCount = 0;
+    privateTableCount     = 0;
 
-    FileInfo info;
     char scriptPath[0x40];
-
-    // Try the original script folder
-    StrCopy(scriptPath, "Data/Scripts/");
+    StrCopy(scriptPath, "Scripts/");
     StrAdd(scriptPath, scriptName);
+    FileInfo info;
     if (LoadFile(scriptPath, &info)) {
         int readMode   = READMODE_NORMAL;
         int parseMode  = PARSEMODE_SCOPELESS;
@@ -2774,10 +2787,9 @@ void ParseScriptFile(char *scriptName, int scriptID)
         int switchDeep = 0;
 
         while (readMode < READMODE_EOF) {
-            int textPos               = 0;
-            readMode                  = READMODE_NORMAL;
-            bool disableLineIncrement = false;
-
+            int textPos   = 0;
+            readMode      = READMODE_NORMAL;
+            bool semiFlag = false;
             while (readMode < READMODE_ENDLINE) {
                 prevChar = curChar;
                 FileRead(&curChar, 1);
@@ -2787,7 +2799,7 @@ void ParseScriptFile(char *scriptName, int scriptID)
                             readMode            = READMODE_ENDLINE;
                             scriptText[textPos] = 0;
                             if (curChar == ';')
-                                disableLineIncrement = true;
+                                semiFlag = true;
                         }
                     }
                     else if (curChar != '/' || textPos <= 0) {
@@ -2809,7 +2821,7 @@ void ParseScriptFile(char *scriptName, int scriptID)
                         readMode            = READMODE_ENDLINE;
                         scriptText[textPos] = 0;
                         if (curChar == ';')
-                            disableLineIncrement = true;
+                            semiFlag = true;
                     }
                 }
                 else if (curChar != '/' || textPos <= 0) {
@@ -2832,237 +2844,203 @@ void ParseScriptFile(char *scriptName, int scriptID)
 
             switch (parseMode) {
                 case PARSEMODE_SCOPELESS:
-                    if (!disableLineIncrement)
+                    if (!semiFlag)
                         ++lineID;
-
                     CheckAliasText(scriptText);
                     CheckStaticText(scriptText);
 
-                    if (CheckTableText(scriptText)) {
+                    currentTable = CheckTableText(scriptText);
+                    if (currentTable) {
                         parseMode = PARSEMODE_TABLEREAD;
                         StrCopy(scriptText, "");
                     }
 
-                    if (StrComp(scriptText, "eventObjectUpdate")) {
+                    if (StrComp(scriptText, "eventObjectMain")) {
                         parseMode                                          = PARSEMODE_FUNCTION;
-                        objectScriptList[scriptID].eventUpdate.scriptCodePtr = scriptCodePos;
-                        objectScriptList[scriptID].eventUpdate.jumpTablePtr  = jumpTablePos;
-                        scriptCodeOffset                                   = scriptCodePos;
-                        jumpTableOffset                                    = jumpTablePos;
+                        objectScriptList[scriptID].eventMain.scriptCodePtr = scriptDataPos;
+                        objectScriptList[scriptID].eventMain.jumpTablePtr  = jumpTableDataPos;
+                        scriptDataOffset                                   = scriptDataPos;
+                        jumpTableDataOffset                                = jumpTableDataPos;
                     }
-
                     if (StrComp(scriptText, "eventObjectDraw")) {
                         parseMode                                          = PARSEMODE_FUNCTION;
-                        objectScriptList[scriptID].eventDraw.scriptCodePtr = scriptCodePos;
-                        objectScriptList[scriptID].eventDraw.jumpTablePtr  = jumpTablePos;
-                        scriptCodeOffset                                   = scriptCodePos;
-                        jumpTableOffset                                    = jumpTablePos;
+                        objectScriptList[scriptID].eventDraw.scriptCodePtr = scriptDataPos;
+                        objectScriptList[scriptID].eventDraw.jumpTablePtr  = jumpTableDataPos;
+                        scriptDataOffset                                   = scriptDataPos;
+                        jumpTableDataOffset                                = jumpTableDataPos;
                     }
-
                     if (StrComp(scriptText, "eventObjectStartup")) {
                         parseMode                                             = PARSEMODE_FUNCTION;
-                        objectScriptList[scriptID].eventStartup.scriptCodePtr = scriptCodePos;
-                        objectScriptList[scriptID].eventStartup.jumpTablePtr  = jumpTablePos;
-                        scriptCodeOffset                                      = scriptCodePos;
-                        jumpTableOffset                                       = jumpTablePos;
+                        objectScriptList[scriptID].eventStartup.scriptCodePtr = scriptDataPos;
+                        objectScriptList[scriptID].eventStartup.jumpTablePtr  = jumpTableDataPos;
+                        scriptDataOffset                                      = scriptDataPos;
+                        jumpTableDataOffset                                   = jumpTableDataPos;
                     }
-
-                    if (FindStringToken(scriptText, "reservefunction", 1) == 0) { // forward decl
+                    if (!FindStringToken(scriptText, "reservefunction", 1)) { // forward decl
                         char funcName[0x40];
                         for (textPos = 15; scriptText[textPos]; ++textPos) funcName[textPos - 15] = scriptText[textPos];
                         funcName[textPos - 15] = 0;
                         int funcID             = -1;
                         for (int f = 0; f < scriptFunctionCount; ++f) {
-                            if (StrComp(funcName, scriptFunctionList[f].name))
+                            if (StrComp(funcName, scriptFunctionNames[f]))
                                 funcID = f;
                         }
-
                         if (scriptFunctionCount < FUNCTION_COUNT && funcID == -1) {
-                            StrCopy(scriptFunctionList[scriptFunctionCount++].name, funcName);
+                            StrCopy(scriptFunctionNames[scriptFunctionCount++], funcName);
                         }
                         else {
-                            PrintLog("WARNING: Function %s has already been reserved!", funcName);
+                            PrintLog("Warning: Function %s has already been reserved!", funcName);
                         }
-
                         parseMode = PARSEMODE_SCOPELESS;
                     }
-                    else if (FindStringToken(scriptText, "publicfunction", 1) == 0) { // regular public decl
-                        char funcName[0x40];
-                        for (textPos = 14; scriptText[textPos]; ++textPos) funcName[textPos - 14] = scriptText[textPos];
-
-                        funcName[textPos - 14] = 0;
-                        int funcID             = -1;
-                        for (int f = 0; f < scriptFunctionCount; ++f) {
-                            if (StrComp(funcName, scriptFunctionList[f].name))
-                                funcID = f;
-                        }
-
-                        if (funcID <= -1) {
-                            if (scriptFunctionCount >= FUNCTION_COUNT) {
-                                parseMode = PARSEMODE_SCOPELESS;
-                            }
-                            else {
-                                StrCopy(scriptFunctionList[scriptFunctionCount].name, funcName);
-                                scriptFunctionList[scriptFunctionCount].access            = ACCESS_PUBLIC;
-                                scriptFunctionList[scriptFunctionCount].ptr.scriptCodePtr = scriptCodePos;
-                                scriptFunctionList[scriptFunctionCount].ptr.jumpTablePtr  = jumpTablePos;
-
-                                scriptCodeOffset = scriptCodePos;
-                                jumpTableOffset  = jumpTablePos;
-                                parseMode        = PARSEMODE_FUNCTION;
-                                ++scriptFunctionCount;
-                            }
-                        }
-                        else {
-                            StrCopy(scriptFunctionList[funcID].name, funcName);
-                            scriptFunctionList[funcID].access            = ACCESS_PUBLIC;
-                            scriptFunctionList[funcID].ptr.scriptCodePtr = scriptCodePos;
-                            scriptFunctionList[funcID].ptr.jumpTablePtr  = jumpTablePos;
-
-                            scriptCodeOffset = scriptCodePos;
-                            jumpTableOffset  = jumpTablePos;
-                            parseMode        = PARSEMODE_FUNCTION;
-                        }
-                    }
-                    else if (FindStringToken(scriptText, "privatefunction", 1) == 0) { // regular private decl
+                    else if (!FindStringToken(scriptText, "function", 1)) { // regular decl
                         char funcName[0x40];
-                        for (textPos = 15; scriptText[textPos]; ++textPos) funcName[textPos - 15] = scriptText[textPos];
-
-                        funcName[textPos - 15] = 0;
-                        int funcID             = -1;
+                        for (textPos = 8; scriptText[textPos]; ++textPos) funcName[textPos - 8] = scriptText[textPos];
+                        funcName[textPos - 8] = 0;
+                        int funcID            = -1;
                         for (int f = 0; f < scriptFunctionCount; ++f) {
-                            if (StrComp(funcName, scriptFunctionList[f].name))
+                            if (StrComp(funcName, scriptFunctionNames[f]))
                                 funcID = f;
                         }
-
                         if (funcID <= -1) {
                             if (scriptFunctionCount >= FUNCTION_COUNT) {
                                 parseMode = PARSEMODE_SCOPELESS;
                             }
                             else {
-                                StrCopy(scriptFunctionList[scriptFunctionCount].name, funcName);
-                                scriptFunctionList[scriptFunctionCount].access            = ACCESS_PRIVATE;
-                                scriptFunctionList[scriptFunctionCount].ptr.scriptCodePtr = scriptCodePos;
-                                scriptFunctionList[scriptFunctionCount].ptr.jumpTablePtr  = jumpTablePos;
-
-                                scriptCodeOffset = scriptCodePos;
-                                jumpTableOffset  = jumpTablePos;
-                                parseMode        = PARSEMODE_FUNCTION;
+                                StrCopy(scriptFunctionNames[scriptFunctionCount], funcName);
+                                functionScriptList[scriptFunctionCount].scriptCodePtr = scriptDataPos;
+                                functionScriptList[scriptFunctionCount].jumpTablePtr  = jumpTableDataPos;
+                                scriptDataOffset                                      = scriptDataPos;
+                                jumpTableDataOffset                                   = jumpTableDataPos;
+                                parseMode                                             = PARSEMODE_FUNCTION;
                                 ++scriptFunctionCount;
                             }
                         }
                         else {
-                            StrCopy(scriptFunctionList[funcID].name, funcName);
-                            scriptFunctionList[funcID].access            = ACCESS_PRIVATE;
-                            scriptFunctionList[funcID].ptr.scriptCodePtr = scriptCodePos;
-                            scriptFunctionList[funcID].ptr.jumpTablePtr  = jumpTablePos;
-
-                            scriptCodeOffset = scriptCodePos;
-                            jumpTableOffset  = jumpTablePos;
-                            parseMode        = PARSEMODE_FUNCTION;
+                            StrCopy(scriptFunctionNames[funcID], funcName);
+                            functionScriptList[funcID].scriptCodePtr = scriptDataPos;
+                            functionScriptList[funcID].jumpTablePtr  = jumpTableDataPos;
+                            scriptDataOffset                         = scriptDataPos;
+                            jumpTableDataOffset                      = jumpTableDataPos;
+                            parseMode                                = PARSEMODE_FUNCTION;
                         }
                     }
                     break;
-
                 case PARSEMODE_PLATFORMSKIP:
-                    if (!disableLineIncrement)
+                    if (!semiFlag)
                         ++lineID;
-
-                    if (FindStringToken(scriptText, "#endplatform", 1) == 0)
+                    if (!FindStringToken(scriptText, "#endplatform", 1))
                         parseMode = PARSEMODE_FUNCTION;
                     break;
-
                 case PARSEMODE_FUNCTION:
-                    if (!disableLineIncrement)
+                    if (!semiFlag)
                         ++lineID;
-
                     if (scriptText[0]) {
                         if (StrComp(scriptText, "endevent")) {
-                            scriptCode[scriptCodePos++] = FUNC_END;
+                            scriptData[scriptDataPos++] = FUNC_END;
                             parseMode                   = PARSEMODE_SCOPELESS;
                         }
                         else if (StrComp(scriptText, "endfunction")) {
-                            scriptCode[scriptCodePos++] = FUNC_RETURN;
+                            scriptData[scriptDataPos++] = FUNC_RETURN;
                             parseMode                   = PARSEMODE_SCOPELESS;
                         }
-                        else if (FindStringToken(scriptText, "#platform:", 1) == 0) {
-                            if (FindStringToken(scriptText, Engine.gamePlatform, 1) == -1
-                                && FindStringToken(scriptText, Engine.gameRenderType, 1) == -1
+                        else if (FindStringToken(scriptText, "#platform:", 1)) {
+                            if (FindStringToken(scriptText, "#endplatform", 1) == -1) {
+                                ConvertIfWhileStatement(scriptText);
+                                ConvertForeachStatement(scriptText);
+                                if (ConvertSwitchStatement(scriptText)) {
+                                    parseMode    = PARSEMODE_SWITCHREAD;
+                                    info.readPos = (int)GetFilePosition();
+                                    switchDeep   = 0;
+                                }
+                                ConvertArithmaticSyntax(scriptText);
+                                if (!ReadSwitchCase(scriptText)) {
+                                    ConvertFunctionText(scriptText);
+                                    if (Engine.gameMode == ENGINE_SCRIPTERROR) {
+                                        AddTextMenuEntry(&gameMenu[0], " ");
+                                        AddTextMenuEntry(&gameMenu[0], "ERROR IN");
+                                        AddTextMenuEntry(&gameMenu[0], scriptName);
+                                        parseMode = PARSEMODE_ERROR;
+                                    }
+                                }
+                            }
+                        }
+                        else if (FindStringToken(scriptText, Engine.gamePlatform, 1) == -1
+                                 && FindStringToken(scriptText, Engine.gameRenderType, 1) == -1
 #if RETRO_USE_HAPTICS
-                                && FindStringToken(scriptText, Engine.gameHapticSetting, 1) == -1
-#endif
-#if !RETRO_USE_ORIGINAL_CODE && RETRO_REV03
-                                && FindStringToken(scriptText, Engine.releaseType, 1) == -1 // general flag for standalone/origins content switching
+                                 && FindStringToken(scriptText, Engine.gameHapticSetting, 1) == -1
 #endif
 #if !RETRO_USE_ORIGINAL_CODE
-                                && FindStringToken(scriptText, "USE_DECOMP", 1) == -1 // general flag for decomp-only stuff
+                                 && FindStringToken(scriptText, "USE_DECOMP", 1) == -1 // general flag for decomp-only stuff
 #endif
 #if RETRO_USE_NETWORKING
-                                && FindStringToken(scriptText, "USE_NETWORKING", 1) == -1
+                                 && FindStringToken(scriptText, "USE_NETWORKING", 1) == -1
 #endif
 #if RETRO_USE_MOD_LOADER
-                                && FindStringToken(scriptText, "USE_MOD_LOADER", 1) == -1
+                                 && FindStringToken(scriptText, "USE_MOD_LOADER", 1) == -1
 #endif
-                            ) {
-                                parseMode = PARSEMODE_PLATFORMSKIP;
-                            }
-                        }
-                        else if (FindStringToken(scriptText, "#endplatform", 1) == -1) {
-                            ConvertConditionalStatement(scriptText);
-                            if (ConvertSwitchStatement(scriptText)) {
-                                parseMode    = PARSEMODE_SWITCHREAD;
-                                info.readPos = (int)GetFilePosition();
-                                switchDeep   = 0;
-                            }
-                            ConvertArithmaticSyntax(scriptText);
-                            if (!ReadSwitchCase(scriptText)) {
-                                ConvertFunctionText(scriptText);
-                                if (Engine.gameMode == ENGINE_SCRIPTERROR) {
-                                    AddTextMenuEntry(&gameMenu[0], " ");
-                                    AddTextMenuEntry(&gameMenu[0], "ERROR IN");
-                                    AddTextMenuEntry(&gameMenu[0], scriptName);
-                                    parseMode = PARSEMODE_ERROR;
-                                }
-                            }
+                        ) {
+                            parseMode = PARSEMODE_PLATFORMSKIP;
                         }
                     }
                     break;
-
                 case PARSEMODE_SWITCHREAD:
-                    if (FindStringToken(scriptText, "switch", 1) == 0)
+                    if (!FindStringToken(scriptText, "switch", 1))
                         ++switchDeep;
-
                     if (switchDeep) {
-                        if (FindStringToken(scriptText, "endswitch", 1) == 0)
+                        if (!FindStringToken(scriptText, "endswitch", 1))
                             --switchDeep;
                     }
-                    else if (FindStringToken(scriptText, "endswitch", 1) == 0) {
+                    else if (FindStringToken(scriptText, "endswitch", 1)) {
+                        CheckCaseNumber(scriptText);
+                    }
+                    else {
                         SetFilePosition(info.readPos);
                         parseMode  = PARSEMODE_FUNCTION;
                         int jPos   = jumpTableStack[jumpTableStackPos];
-                        switchDeep = abs(jumpTable[jPos + 1] - jumpTable[jPos]) + 1;
-                        for (textPos = 0; textPos < switchDeep; ++textPos) jumpTable[jumpTablePos++] = -1;
-                    }
-                    else {
-                        CheckCaseNumber(scriptText);
+                        switchDeep = abs(jumpTableData[jPos + 1] - jumpTableData[jPos]) + 1;
+                        for (textPos = 0; textPos < switchDeep; ++textPos) jumpTableData[jumpTableDataPos++] = -1;
                     }
                     break;
-
                 case PARSEMODE_TABLEREAD:
-                    if (!disableLineIncrement)
+                    if (!semiFlag)
                         ++lineID;
-
-                    if (FindStringToken(scriptText, "endtable", 1) == 0) {
-                        parseMode = PARSEMODE_SCOPELESS;
+                    if (FindStringToken(scriptText, "endtable", 1)) {
+                        ReadTableValues(scriptText);
                     }
                     else {
-                        if (StrLength(scriptText) >= 1)
-                            ReadTableValues(scriptText);
+                        currentTable->dataPos       = scriptDataPos;
+                        scriptData[scriptDataPos++] = currentTable->valueCount;
+                        for (int v = 0; v < currentTable->valueCount; ++v) {
+                            currentTable->values[v].dataPos = scriptDataPos;
+                            scriptData[scriptDataPos++]     = currentTable->values[v].value;
+                        }
 
-                        parseMode = PARSEMODE_TABLEREAD;
+                        if (curTablePublic) {
+                            for (int t = 0; t < publicTableCount; ++t) {
+                                if (StrComp(publicTables[t].name, currentTable->name)) {
+                                    PrintLog("Warning: Table %s has already been used!", currentTable->name);
+                                }
+                            }
+
+                            publicTables[publicTableCount] = *currentTable;
+                            ++publicTableCount;
+                        }
+                        else {
+                            for (int t = 0; t < privateTableCount; ++t) {
+                                if (StrComp(privateTables[t].name, currentTable->name)) {
+                                    PrintLog("Warning: Table %s has already been used!", currentTable->name);
+                                }
+                            }
+
+                            privateTables[privateTableCount] = *currentTable;
+                            ++privateTableCount;
+                        }
+
+                        currentTable = NULL;
+                        parseMode    = PARSEMODE_SCOPELESS;
                     }
                     break;
-
                 default: break;
             }
         }
@@ -3090,191 +3068,181 @@ void LoadBytecode(int stageListID, int scriptID)
 
     FileInfo info;
     if (LoadFile(scriptPath, &info)) {
-        byte fileBuffer    = 0;
-        int *scriptCodePtr = &scriptCode[scriptCodePos];
-        int *jumpTablePtr  = &jumpTable[jumpTablePos];
-
+        byte fileBuffer = 0;
+        int *scrData    = &scriptData[scriptCodePos];
         FileRead(&fileBuffer, 1);
-        int scriptCodeSize = fileBuffer;
+        int scriptCodeCount = fileBuffer;
         FileRead(&fileBuffer, 1);
-        scriptCodeSize |= fileBuffer << 8;
+        scriptCodeCount += (fileBuffer << 8);
         FileRead(&fileBuffer, 1);
-        scriptCodeSize |= fileBuffer << 16;
+        scriptCodeCount += (fileBuffer << 16);
         FileRead(&fileBuffer, 1);
-        scriptCodeSize |= fileBuffer << 24;
+        scriptCodeCount += (fileBuffer << 24);
 
-        while (scriptCodeSize > 0) {
+        while (scriptCodeCount > 0) {
             FileRead(&fileBuffer, 1);
             int blockSize = fileBuffer & 0x7F;
             if (fileBuffer >= 0x80) {
                 while (blockSize > 0) {
                     FileRead(&fileBuffer, 1);
-                    *scriptCodePtr = fileBuffer;
+                    int data = fileBuffer;
                     FileRead(&fileBuffer, 1);
-                    *scriptCodePtr |= fileBuffer << 8;
+                    data += fileBuffer << 8;
                     FileRead(&fileBuffer, 1);
-                    *scriptCodePtr |= fileBuffer << 16;
+                    data += fileBuffer << 16;
                     FileRead(&fileBuffer, 1);
-                    *scriptCodePtr |= fileBuffer << 24;
-
-                    ++scriptCodePtr;
+                    data += fileBuffer << 24;
+                    *scrData = data;
+                    ++scrData;
                     ++scriptCodePos;
-                    --scriptCodeSize;
+                    --scriptCodeCount;
                     --blockSize;
                 }
             }
             else {
                 while (blockSize > 0) {
                     FileRead(&fileBuffer, 1);
-                    *scriptCodePtr = fileBuffer;
-
-                    ++scriptCodePtr;
+                    *scrData = fileBuffer;
+                    ++scrData;
                     ++scriptCodePos;
-                    --scriptCodeSize;
+                    --scriptCodeCount;
                     --blockSize;
                 }
             }
         }
 
+        int *jumpPtr = &jumpTableData[jumpTablePos];
         FileRead(&fileBuffer, 1);
-        int jumpTableSize = fileBuffer;
+        int jumpDataCnt = fileBuffer;
         FileRead(&fileBuffer, 1);
-        jumpTableSize |= fileBuffer << 8;
+        jumpDataCnt += fileBuffer << 8;
         FileRead(&fileBuffer, 1);
-        jumpTableSize |= fileBuffer << 16;
+        jumpDataCnt += fileBuffer << 16;
         FileRead(&fileBuffer, 1);
-        jumpTableSize |= fileBuffer << 24;
+        jumpDataCnt += fileBuffer << 24;
 
-        while (jumpTableSize > 0) {
+        while (jumpDataCnt > 0) {
             FileRead(&fileBuffer, 1);
             int blockSize = fileBuffer & 0x7F;
-
             if (fileBuffer >= 0x80) {
                 while (blockSize > 0) {
                     FileRead(&fileBuffer, 1);
-                    *jumpTablePtr = fileBuffer;
+                    int data = fileBuffer;
                     FileRead(&fileBuffer, 1);
-                    *jumpTablePtr |= fileBuffer << 8;
+                    data += fileBuffer << 8;
                     FileRead(&fileBuffer, 1);
-                    *jumpTablePtr |= fileBuffer << 16;
+                    data += fileBuffer << 16;
                     FileRead(&fileBuffer, 1);
-                    *jumpTablePtr |= fileBuffer << 24;
-
-                    ++jumpTablePtr;
+                    data += fileBuffer << 24;
+                    *jumpPtr = data;
+                    ++jumpPtr;
                     ++jumpTablePos;
-                    --jumpTableSize;
+                    --jumpDataCnt;
                     --blockSize;
                 }
             }
             else {
                 while (blockSize > 0) {
                     FileRead(&fileBuffer, 1);
-                    *jumpTablePtr = fileBuffer;
-
-                    ++jumpTablePtr;
+                    *jumpPtr = fileBuffer;
+                    ++jumpPtr;
                     ++jumpTablePos;
-                    --jumpTableSize;
+                    --jumpDataCnt;
                     --blockSize;
                 }
             }
         }
-
         FileRead(&fileBuffer, 1);
         int scriptCount = fileBuffer;
         FileRead(&fileBuffer, 1);
-        scriptCount |= fileBuffer << 8;
+        scriptCount += fileBuffer << 8;
 
-        for (int s = 0; s < scriptCount; ++s) {
-            ObjectScript *script = &objectScriptList[scriptID + s];
+        int objType = scriptID;
+        for (int i = 0; i < scriptCount; ++i) {
 
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.scriptCodePtr = fileBuffer;
+            int buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.scriptCodePtr |= fileBuffer << 8;
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.scriptCodePtr |= fileBuffer << 16;
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.scriptCodePtr |= fileBuffer << 24;
+            objectScriptList[objType].eventMain.scriptCodePtr = buf + (fileBuffer << 24);
 
             FileRead(&fileBuffer, 1);
-            script->eventDraw.scriptCodePtr = fileBuffer;
+            buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventDraw.scriptCodePtr |= fileBuffer << 8;
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventDraw.scriptCodePtr |= fileBuffer << 16;
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventDraw.scriptCodePtr |= fileBuffer << 24;
+            objectScriptList[objType].eventDraw.scriptCodePtr = buf + (fileBuffer << 24);
 
             FileRead(&fileBuffer, 1);
-            script->eventStartup.scriptCodePtr = fileBuffer;
+            buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventStartup.scriptCodePtr |= (fileBuffer << 8);
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventStartup.scriptCodePtr |= (fileBuffer << 16);
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventStartup.scriptCodePtr |= fileBuffer << 24;
+            objectScriptList[objType++].eventStartup.scriptCodePtr = buf + (fileBuffer << 24);
         }
 
-        for (int s = 0; s < scriptCount; ++s) {
-            ObjectScript *script = &objectScriptList[scriptID + s];
-
+        objType = scriptID;
+        for (int i = 0; i < scriptCount; ++i) {
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.jumpTablePtr = fileBuffer;
+            int buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.jumpTablePtr |= fileBuffer << 8;
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.jumpTablePtr |= fileBuffer << 16;
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventUpdate.jumpTablePtr |= fileBuffer << 24;
+            objectScriptList[objType].eventMain.jumpTablePtr = buf + (fileBuffer << 24);
 
             FileRead(&fileBuffer, 1);
-            script->eventDraw.jumpTablePtr = fileBuffer;
+            buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventDraw.jumpTablePtr |= fileBuffer << 8;
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventDraw.jumpTablePtr |= fileBuffer << 16;
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventDraw.jumpTablePtr |= fileBuffer << 24;
+            objectScriptList[objType].eventDraw.jumpTablePtr = buf + (fileBuffer << 24);
 
             FileRead(&fileBuffer, 1);
-            script->eventStartup.jumpTablePtr = fileBuffer;
+            buf = fileBuffer;
             FileRead(&fileBuffer, 1);
-            script->eventStartup.jumpTablePtr |= fileBuffer << 8;
+            buf += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            script->eventStartup.jumpTablePtr |= fileBuffer << 16;
+            buf += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            script->eventStartup.jumpTablePtr |= fileBuffer << 24;
+            objectScriptList[objType++].eventStartup.jumpTablePtr = buf + (fileBuffer << 24);
         }
 
         FileRead(&fileBuffer, 1);
         int functionCount = fileBuffer;
         FileRead(&fileBuffer, 1);
-        functionCount |= fileBuffer << 8;
-
-        for (int f = 0; f < functionCount; ++f) {
-            ScriptFunction *function = &scriptFunctionList[f];
+        functionCount += fileBuffer << 8;
 
+        for (int i = 0; i < functionCount; ++i) {
             FileRead(&fileBuffer, 1);
-            function->ptr.scriptCodePtr = fileBuffer;
+            int scrPos = fileBuffer;
             FileRead(&fileBuffer, 1);
-            function->ptr.scriptCodePtr |= fileBuffer << 8;
+            scrPos += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            function->ptr.scriptCodePtr |= fileBuffer << 16;
+            scrPos += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            function->ptr.scriptCodePtr |= fileBuffer << 24;
+            functionScriptList[i].scriptCodePtr = scrPos + (fileBuffer << 24);
         }
 
-        for (int f = 0; f < functionCount; ++f) {
-            ScriptFunction *function = &scriptFunctionList[f];
-
+        for (int i = 0; i < functionCount; ++i) {
             FileRead(&fileBuffer, 1);
-            function->ptr.jumpTablePtr = fileBuffer;
+            int jmpPos = fileBuffer;
             FileRead(&fileBuffer, 1);
-            function->ptr.jumpTablePtr |= fileBuffer << 8;
+            jmpPos += (fileBuffer << 8);
             FileRead(&fileBuffer, 1);
-            function->ptr.jumpTablePtr |= fileBuffer << 16;
+            jmpPos += (fileBuffer << 16);
             FileRead(&fileBuffer, 1);
-            function->ptr.jumpTablePtr |= fileBuffer << 24;
+            functionScriptList[i].jumpTablePtr = jmpPos + (fileBuffer << 24);
         }
 
         CloseFile();
@@ -3283,8 +3251,8 @@ void LoadBytecode(int stageListID, int scriptID)
 
 void ClearScriptData()
 {
-    memset(scriptCode, 0, sizeof(scriptCode));
-    memset(jumpTable, 0, sizeof(jumpTable));
+    memset(scriptData, 0, sizeof(scriptData));
+    memset(jumpTableData, 0, sizeof(jumpTableData));
 
     memset(foreachStack, -1, sizeof(foreachStack));
     memset(jumpTableStack, 0, sizeof(jumpTableStack));
@@ -3297,31 +3265,51 @@ void ClearScriptData()
     jumpTableStackPos = 0;
     functionStackPos  = 0;
 
-    scriptCodePos    = 0;
-    scriptCodeOffset = 0;
-    jumpTablePos     = 0;
-    jumpTableOffset  = 0;
+    scriptDataPos       = 0;
+    scriptDataOffset    = 0;
+    jumpTableDataPos    = 0;
+    jumpTableDataOffset = 0;
 
 #if RETRO_USE_COMPILER
     scriptFunctionCount = 0;
 
     lineID = 0;
 
-    scriptValueListCount = COMMON_SCRIPT_VAR_COUNT;
-    for (int v = COMMON_SCRIPT_VAR_COUNT; v < SCRIPT_VAR_COUNT; ++v) {
-        MEM_ZERO(scriptValueList[v]);
+    publicAliasCount  = COMMONALIAS_COUNT;
+    privateAliasCount = 0;
+
+    publicStaticVarCount  = 0;
+    privateStaticVarCount = 0;
+
+    publicTableCount  = 0;
+    privateTableCount = 0;
+
+    for (int i = COMMONALIAS_COUNT; i < ALIAS_COUNT; ++i) {
+        StrCopy(publicAliases[i].name, "");
+        StrCopy(publicAliases[i].value, "");
+    }
+
+    for (int i = 0; i < ALIAS_COUNT_TRIM; ++i) {
+        StrCopy(privateAliases[i].name, "");
+        StrCopy(privateAliases[i].value, "");
     }
+
+    memset(publicStaticVariables, 0, sizeof(publicStaticVariables));
+    memset(privateStaticVariables, 0, sizeof(privateStaticVariables));
+
+    memset(publicTables, 0, sizeof(publicTables));
+    memset(privateTables, 0, sizeof(privateTables));
 #endif
 
     ClearAnimationData();
 
     for (int o = 0; o < OBJECT_COUNT; ++o) {
         ObjectScript *scriptInfo               = &objectScriptList[o];
-        scriptInfo->eventUpdate.scriptCodePtr  = SCRIPTCODE_COUNT - 1;
-        scriptInfo->eventUpdate.jumpTablePtr   = JUMPTABLE_COUNT - 1;
-        scriptInfo->eventDraw.scriptCodePtr    = SCRIPTCODE_COUNT - 1;
+        scriptInfo->eventMain.scriptCodePtr    = SCRIPTDATA_COUNT - 1;
+        scriptInfo->eventMain.jumpTablePtr     = JUMPTABLE_COUNT - 1;
+        scriptInfo->eventDraw.scriptCodePtr    = SCRIPTDATA_COUNT - 1;
         scriptInfo->eventDraw.jumpTablePtr     = JUMPTABLE_COUNT - 1;
-        scriptInfo->eventStartup.scriptCodePtr = SCRIPTCODE_COUNT - 1;
+        scriptInfo->eventStartup.scriptCodePtr = SCRIPTDATA_COUNT - 1;
         scriptInfo->eventStartup.jumpTablePtr  = JUMPTABLE_COUNT - 1;
         scriptInfo->frameListOffset            = 0;
         scriptInfo->spriteSheetID              = 0;
@@ -3334,70 +3322,60 @@ void ClearScriptData()
     }
 
     for (int f = 0; f < FUNCTION_COUNT; ++f) {
-        scriptFunctionList[f].ptr.scriptCodePtr = SCRIPTCODE_COUNT - 1;
-        scriptFunctionList[f].ptr.jumpTablePtr  = JUMPTABLE_COUNT - 1;
+        functionScriptList[f].scriptCodePtr = SCRIPTDATA_COUNT - 1;
+        functionScriptList[f].jumpTablePtr  = JUMPTABLE_COUNT - 1;
     }
 
     SetObjectTypeName("Blank Object", OBJ_TYPE_BLANKOBJECT);
 }
 
-void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
+void ProcessScript(int scriptCodePtr, int jumpTablePtr, byte scriptEvent)
 {
     bool running      = true;
-    int scriptCodePtr = scriptCodeStart;
+    int scriptDataPtr = scriptCodePtr;
+    // int jumpTableDataPtr = jumpTablePtr;
     jumpTableStackPos = 0;
     functionStackPos  = 0;
     foreachStackPos   = 0;
 
     while (running) {
-        int opcode           = scriptCode[scriptCodePtr++];
+        int opcode           = scriptData[scriptDataPtr++];
         int opcodeSize       = functions[opcode].opcodeSize;
-        int scriptCodeOffset = scriptCodePtr;
+        int scriptCodeOffset = scriptDataPtr;
 
         scriptText[0] = '\0';
 
         // Get Values
         for (int i = 0; i < opcodeSize; ++i) {
-            int opcodeType = scriptCode[scriptCodePtr++];
+            int opcodeType = scriptData[scriptDataPtr++];
 
             if (opcodeType == SCRIPTVAR_VAR) {
                 int arrayVal = 0;
-                switch (scriptCode[scriptCodePtr++]) {
+                switch (scriptData[scriptDataPtr++]) {
                     case VARARR_NONE: arrayVal = objectEntityPos; break;
-
                     case VARARR_ARRAY:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = scriptEng.arrayPosition[scriptCode[scriptCodePtr++]];
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = scriptEng.arrayPosition[scriptData[scriptDataPtr++]];
                         else
-                            arrayVal = scriptCode[scriptCodePtr++];
+                            arrayVal = scriptData[scriptDataPtr++];
                         break;
-
                     case VARARR_ENTNOPLUS1:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = scriptEng.arrayPosition[scriptCode[scriptCodePtr++]] + objectEntityPos;
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = scriptEng.arrayPosition[scriptData[scriptDataPtr++]] + objectEntityPos;
                         else
-                            arrayVal = scriptCode[scriptCodePtr++] + objectEntityPos;
+                            arrayVal = scriptData[scriptDataPtr++] + objectEntityPos;
                         break;
-
                     case VARARR_ENTNOMINUS1:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = objectEntityPos - scriptEng.arrayPosition[scriptCode[scriptCodePtr++]];
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = objectEntityPos - scriptEng.arrayPosition[scriptData[scriptDataPtr++]];
                         else
-                            arrayVal = objectEntityPos - scriptCode[scriptCodePtr++];
+                            arrayVal = objectEntityPos - scriptData[scriptDataPtr++];
                         break;
-
                     default: break;
                 }
 
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-                bool inputCheck = true; // Default to true for mobile bytecode
-                // If we're using the scripts or an Origins datafile, check the array value
-                if (forceUseScripts || Engine.usingOrigins)
-                    inputCheck = arrayVal <= 1;
-#endif
-
                 // Variables
-                switch (scriptCode[scriptCodePtr++]) {
+                switch (scriptData[scriptDataPtr++]) {
                     default: break;
                     case VAR_TEMP0: scriptEng.operands[i] = scriptEng.temp[0]; break;
                     case VAR_TEMP1: scriptEng.operands[i] = scriptEng.temp[1]; break;
@@ -3417,7 +3395,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     case VAR_ARRAYPOS6: scriptEng.operands[i] = scriptEng.arrayPosition[6]; break;
                     case VAR_ARRAYPOS7: scriptEng.operands[i] = scriptEng.arrayPosition[7]; break;
                     case VAR_GLOBAL: scriptEng.operands[i] = globalVariables[arrayVal]; break;
-                    case VAR_LOCAL: scriptEng.operands[i] = scriptCode[arrayVal]; break;
+                    case VAR_LOCAL: scriptEng.operands[i] = scriptData[arrayVal]; break;
                     case VAR_OBJECTENTITYPOS: scriptEng.operands[i] = arrayVal; break;
                     case VAR_OBJECTGROUPID: {
                         scriptEng.operands[i] = objectEntityList[arrayVal].groupID;
@@ -3677,7 +3655,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                         int x          = entPtr->xpos >> 16;
                         int y          = entPtr->ypos >> 16;
 
-                        if (entPtr->priority == PRIORITY_BOUNDS_SMALL || entPtr->priority == PRIORITY_ACTIVE_SMALL) {
+                        if (entPtr->priority == PRIORITY_ACTIVE_BOUNDS_SMALL || entPtr->priority == PRIORITY_ACTIVE_SMALL) {
                             if (stageMode == STAGEMODE_2P) {
                                 x = entPtr->xpos;
                                 y = entPtr->ypos;
@@ -3993,65 +3971,34 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     case VAR_MUSICVOLUME: scriptEng.operands[i] = masterVolume; break;
                     case VAR_MUSICCURRENTTRACK: scriptEng.operands[i] = trackID; break;
                     case VAR_MUSICPOSITION: scriptEng.operands[i] = musicPosition; break;
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-                    case VAR_KEYDOWNUP: scriptEng.operands[i] = keyDown.up && inputCheck; break;
-                    case VAR_KEYDOWNDOWN: scriptEng.operands[i] = keyDown.down && inputCheck; break;
-                    case VAR_KEYDOWNLEFT: scriptEng.operands[i] = keyDown.left && inputCheck; break;
-                    case VAR_KEYDOWNRIGHT: scriptEng.operands[i] = keyDown.right && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONA: scriptEng.operands[i] = keyDown.A && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONB: scriptEng.operands[i] = keyDown.B && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONC: scriptEng.operands[i] = keyDown.C && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONX: scriptEng.operands[i] = keyDown.X && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONY: scriptEng.operands[i] = keyDown.Y && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONZ: scriptEng.operands[i] = keyDown.Z && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONL: scriptEng.operands[i] = keyDown.L && inputCheck; break;
-                    case VAR_KEYDOWNBUTTONR: scriptEng.operands[i] = keyDown.R && inputCheck; break;
-                    case VAR_KEYDOWNSTART: scriptEng.operands[i] = keyDown.start && inputCheck; break;
-                    case VAR_KEYDOWNSELECT: scriptEng.operands[i] = keyDown.select && inputCheck; break;
-                    case VAR_KEYPRESSUP: scriptEng.operands[i] = keyPress.up && inputCheck; break;
-                    case VAR_KEYPRESSDOWN: scriptEng.operands[i] = keyPress.down && inputCheck; break;
-                    case VAR_KEYPRESSLEFT: scriptEng.operands[i] = keyPress.left && inputCheck; break;
-                    case VAR_KEYPRESSRIGHT: scriptEng.operands[i] = keyPress.right && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONA: scriptEng.operands[i] = keyPress.A && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONB: scriptEng.operands[i] = keyPress.B && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONC: scriptEng.operands[i] = keyPress.C && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONX: scriptEng.operands[i] = keyPress.X && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONY: scriptEng.operands[i] = keyPress.Y && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONZ: scriptEng.operands[i] = keyPress.Z && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONL: scriptEng.operands[i] = keyPress.L && inputCheck; break;
-                    case VAR_KEYPRESSBUTTONR: scriptEng.operands[i] = keyPress.R && inputCheck; break;
-                    case VAR_KEYPRESSSTART: scriptEng.operands[i] = keyPress.start && inputCheck; break;
-                    case VAR_KEYPRESSSELECT: scriptEng.operands[i] = keyPress.select && inputCheck; break;
-#else
-                    case VAR_KEYDOWNUP: scriptEng.operands[i] = keyDown.up; break;
-                    case VAR_KEYDOWNDOWN: scriptEng.operands[i] = keyDown.down; break;
-                    case VAR_KEYDOWNLEFT: scriptEng.operands[i] = keyDown.left; break;
-                    case VAR_KEYDOWNRIGHT: scriptEng.operands[i] = keyDown.right; break;
-                    case VAR_KEYDOWNBUTTONA: scriptEng.operands[i] = keyDown.A; break;
-                    case VAR_KEYDOWNBUTTONB: scriptEng.operands[i] = keyDown.B; break;
-                    case VAR_KEYDOWNBUTTONC: scriptEng.operands[i] = keyDown.C; break;
-                    case VAR_KEYDOWNBUTTONX: scriptEng.operands[i] = keyDown.X; break;
-                    case VAR_KEYDOWNBUTTONY: scriptEng.operands[i] = keyDown.Y; break;
-                    case VAR_KEYDOWNBUTTONZ: scriptEng.operands[i] = keyDown.Z; break;
-                    case VAR_KEYDOWNBUTTONL: scriptEng.operands[i] = keyDown.L; break;
-                    case VAR_KEYDOWNBUTTONR: scriptEng.operands[i] = keyDown.R; break;
-                    case VAR_KEYDOWNSTART: scriptEng.operands[i] = keyDown.start; break;
-                    case VAR_KEYDOWNSELECT: scriptEng.operands[i] = keyDown.select; break;
-                    case VAR_KEYPRESSUP: scriptEng.operands[i] = keyPress.up; break;
-                    case VAR_KEYPRESSDOWN: scriptEng.operands[i] = keyPress.down; break;
-                    case VAR_KEYPRESSLEFT: scriptEng.operands[i] = keyPress.left; break;
-                    case VAR_KEYPRESSRIGHT: scriptEng.operands[i] = keyPress.right; break;
-                    case VAR_KEYPRESSBUTTONA: scriptEng.operands[i] = keyPress.A; break;
-                    case VAR_KEYPRESSBUTTONB: scriptEng.operands[i] = keyPress.B; break;
-                    case VAR_KEYPRESSBUTTONC: scriptEng.operands[i] = keyPress.C; break;
-                    case VAR_KEYPRESSBUTTONX: scriptEng.operands[i] = keyPress.X; break;
-                    case VAR_KEYPRESSBUTTONY: scriptEng.operands[i] = keyPress.Y; break;
-                    case VAR_KEYPRESSBUTTONZ: scriptEng.operands[i] = keyPress.Z; break;
-                    case VAR_KEYPRESSBUTTONL: scriptEng.operands[i] = keyPress.L; break;
-                    case VAR_KEYPRESSBUTTONR: scriptEng.operands[i] = keyPress.R; break;
-                    case VAR_KEYPRESSSTART: scriptEng.operands[i] = keyPress.start; break;
-                    case VAR_KEYPRESSSELECT: scriptEng.operands[i] = keyPress.select; break;
-#endif
+                    case VAR_INPUTDOWNUP: scriptEng.operands[i] = inputDown.up; break;
+                    case VAR_INPUTDOWNDOWN: scriptEng.operands[i] = inputDown.down; break;
+                    case VAR_INPUTDOWNLEFT: scriptEng.operands[i] = inputDown.left; break;
+                    case VAR_INPUTDOWNRIGHT: scriptEng.operands[i] = inputDown.right; break;
+                    case VAR_INPUTDOWNBUTTONA: scriptEng.operands[i] = inputDown.A; break;
+                    case VAR_INPUTDOWNBUTTONB: scriptEng.operands[i] = inputDown.B; break;
+                    case VAR_INPUTDOWNBUTTONC: scriptEng.operands[i] = inputDown.C; break;
+                    case VAR_INPUTDOWNBUTTONX: scriptEng.operands[i] = inputDown.X; break;
+                    case VAR_INPUTDOWNBUTTONY: scriptEng.operands[i] = inputDown.Y; break;
+                    case VAR_INPUTDOWNBUTTONZ: scriptEng.operands[i] = inputDown.Z; break;
+                    case VAR_INPUTDOWNBUTTONL: scriptEng.operands[i] = inputDown.L; break;
+                    case VAR_INPUTDOWNBUTTONR: scriptEng.operands[i] = inputDown.R; break;
+                    case VAR_INPUTDOWNSTART: scriptEng.operands[i] = inputDown.start; break;
+                    case VAR_INPUTDOWNSELECT: scriptEng.operands[i] = inputDown.select; break;
+                    case VAR_INPUTPRESSUP: scriptEng.operands[i] = inputPress.up; break;
+                    case VAR_INPUTPRESSDOWN: scriptEng.operands[i] = inputPress.down; break;
+                    case VAR_INPUTPRESSLEFT: scriptEng.operands[i] = inputPress.left; break;
+                    case VAR_INPUTPRESSRIGHT: scriptEng.operands[i] = inputPress.right; break;
+                    case VAR_INPUTPRESSBUTTONA: scriptEng.operands[i] = inputPress.A; break;
+                    case VAR_INPUTPRESSBUTTONB: scriptEng.operands[i] = inputPress.B; break;
+                    case VAR_INPUTPRESSBUTTONC: scriptEng.operands[i] = inputPress.C; break;
+                    case VAR_INPUTPRESSBUTTONX: scriptEng.operands[i] = inputPress.X; break;
+                    case VAR_INPUTPRESSBUTTONY: scriptEng.operands[i] = inputPress.Y; break;
+                    case VAR_INPUTPRESSBUTTONZ: scriptEng.operands[i] = inputPress.Z; break;
+                    case VAR_INPUTPRESSBUTTONL: scriptEng.operands[i] = inputPress.L; break;
+                    case VAR_INPUTPRESSBUTTONR: scriptEng.operands[i] = inputPress.R; break;
+                    case VAR_INPUTPRESSSTART: scriptEng.operands[i] = inputPress.start; break;
+                    case VAR_INPUTPRESSSELECT: scriptEng.operands[i] = inputPress.select; break;
                     case VAR_MENU1SELECTION: scriptEng.operands[i] = gameMenu[0].selection1; break;
                     case VAR_MENU2SELECTION: scriptEng.operands[i] = gameMenu[1].selection1; break;
                     case VAR_TILELAYERXSIZE: scriptEng.operands[i] = stageLayouts[arrayVal].xsize; break;
@@ -4100,89 +4047,42 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     case VAR_ENGINEONLINEACTIVE: scriptEng.operands[i] = Engine.onlineActive; break;
                     case VAR_ENGINESFXVOLUME: scriptEng.operands[i] = sfxVolume; break;
                     case VAR_ENGINEBGMVOLUME: scriptEng.operands[i] = bgmVolume; break;
-#if RETRO_REV00
                     case VAR_ENGINEPLATFORMID: scriptEng.operands[i] = RETRO_GAMEPLATFORMID; break;
-#endif
                     case VAR_ENGINETRIALMODE: scriptEng.operands[i] = Engine.trialMode; break;
-#if !RETRO_REV00
                     case VAR_ENGINEDEVICETYPE: scriptEng.operands[i] = RETRO_DEVICETYPE; break;
-#endif
-
-#if RETRO_REV03
-                    // Origins Extras
-                    // Due to using regular v4, these don't support array values like origins expects, so its always screen[0]
-                    case VAR_SCREENCURRENTID: scriptEng.operands[i] = 0; break;
-                    case VAR_CAMERAENABLED:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraEnabled;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-                    case VAR_CAMERATARGET:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraTarget;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-                    case VAR_CAMERASTYLE:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraStyle;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-                    case VAR_CAMERAXPOS:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraXPos;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-                    case VAR_CAMERAYPOS:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraYPos;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-                    case VAR_CAMERAADJUSTY:
-                        if (arrayVal == 0)
-                            scriptEng.operands[i] = cameraAdjustY;
-                        else
-                            scriptEng.operands[i] = 0;
-                        break;
-#endif
-
 #if RETRO_USE_HAPTICS
                     case VAR_HAPTICSENABLED: scriptEng.operands[i] = Engine.hapticsEnabled; break;
 #endif
                 }
             }
             else if (opcodeType == SCRIPTVAR_INTCONST) { // int constant
-                scriptEng.operands[i] = scriptCode[scriptCodePtr++];
+                scriptEng.operands[i] = scriptData[scriptDataPtr++];
             }
             else if (opcodeType == SCRIPTVAR_STRCONST) { // string constant
-                int strLen         = scriptCode[scriptCodePtr++];
+                int strLen         = scriptData[scriptDataPtr++];
                 scriptText[strLen] = 0;
                 for (int c = 0; c < strLen; ++c) {
                     switch (c % 4) {
-                        case 0: 
-                            scriptText[c] = scriptCode[scriptCodePtr] >> 24;
+                        case 0: {
+                            scriptText[c] = scriptData[scriptDataPtr] >> 24;
                             break;
-
-                        case 1: 
-                            scriptText[c] = (0xFFFFFF & scriptCode[scriptCodePtr]) >> 16;
+                        }
+                        case 1: {
+                            scriptText[c] = (0xFFFFFF & scriptData[scriptDataPtr]) >> 16;
                             break;
-
-                        case 2: 
-                            scriptText[c] = (0xFFFF & scriptCode[scriptCodePtr]) >> 8;
+                        }
+                        case 2: {
+                            scriptText[c] = (0xFFFF & scriptData[scriptDataPtr]) >> 8;
                             break;
-
-                        case 3: 
-                            scriptText[c] = scriptCode[scriptCodePtr++];
+                        }
+                        case 3: {
+                            scriptText[c] = scriptData[scriptDataPtr++];
                             break;
-
+                        }
                         default: break;
                     }
                 }
-                scriptCodePtr++;
+                scriptDataPtr++;
             }
         }
 
@@ -4226,43 +4126,43 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 break;
             case FUNC_IFEQUAL:
                 if (scriptEng.operands[1] != scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_IFGREATER:
                 if (scriptEng.operands[1] <= scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_IFGREATEROREQUAL:
                 if (scriptEng.operands[1] < scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_IFLOWER:
                 if (scriptEng.operands[1] >= scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_IFLOWEROREQUAL:
                 if (scriptEng.operands[1] > scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_IFNOTEQUAL:
                 if (scriptEng.operands[1] == scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0]];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0]];
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize                          = 0;
                 break;
             case FUNC_ELSE:
                 opcodeSize    = 0;
-                scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + jumpTableStack[jumpTableStackPos--] + 1];
+                scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + jumpTableStack[jumpTableStackPos--] + 1];
                 break;
             case FUNC_ENDIF:
                 opcodeSize = 0;
@@ -4270,49 +4170,49 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 break;
             case FUNC_WEQUAL:
                 if (scriptEng.operands[1] != scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_WGREATER:
                 if (scriptEng.operands[1] <= scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_WGREATEROREQUAL:
                 if (scriptEng.operands[1] < scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_WLOWER:
                 if (scriptEng.operands[1] >= scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_WLOWEROREQUAL:
                 if (scriptEng.operands[1] > scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_WNOTEQUAL:
                 if (scriptEng.operands[1] == scriptEng.operands[2])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 else
                     jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
                 opcodeSize = 0;
                 break;
             case FUNC_LOOP:
                 opcodeSize    = 0;
-                scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + jumpTableStack[jumpTableStackPos--]];
+                scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + jumpTableStack[jumpTableStackPos--]];
                 break;
             case FUNC_FOREACHACTIVE: {
                 int groupID = scriptEng.operands[1];
@@ -4322,7 +4222,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     if (loop >= objectTypeGroupList[groupID].listSize) {
                         opcodeSize                      = 0;
                         foreachStack[foreachStackPos--] = -1;
-                        scriptCodePtr                   = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                        scriptDataPtr                   = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                         break;
                     }
                     else {
@@ -4332,7 +4232,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 }
                 else {
                     opcodeSize    = 0;
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 }
                 break;
             }
@@ -4347,7 +4247,8 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                             if (loop >= TEMPENTITY_START) {
                                 opcodeSize                      = 0;
                                 foreachStack[foreachStackPos--] = -1;
-                                scriptCodePtr                   = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                                int off                         = jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
+                                scriptDataPtr                   = scriptCodePtr + off;
                                 break;
                             }
                             else if (objType == objectEntityList[loop].type) {
@@ -4365,7 +4266,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                             if (loop >= ENTITY_COUNT) {
                                 opcodeSize                      = 0;
                                 foreachStack[foreachStackPos--] = -1;
-                                scriptCodePtr                   = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                                scriptDataPtr                   = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                                 break;
                             }
                             else if (objType == objectEntityList[loop].type) {
@@ -4381,29 +4282,29 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 }
                 else {
                     opcodeSize    = 0;
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 1];
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1];
                 }
                 break;
             }
             case FUNC_NEXT:
                 opcodeSize    = 0;
-                scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + jumpTableStack[jumpTableStackPos--]];
+                scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + jumpTableStack[jumpTableStackPos--]];
                 --foreachStackPos;
                 break;
             case FUNC_SWITCH:
                 jumpTableStack[++jumpTableStackPos] = scriptEng.operands[0];
-                if (scriptEng.operands[1] < jumpTable[jumpTableStart + scriptEng.operands[0]]
-                    || scriptEng.operands[1] > jumpTable[jumpTableStart + scriptEng.operands[0] + 1])
-                    scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + scriptEng.operands[0] + 2];
+                if (scriptEng.operands[1] < jumpTableData[jumpTablePtr + scriptEng.operands[0]]
+                    || scriptEng.operands[1] > jumpTableData[jumpTablePtr + scriptEng.operands[0] + 1])
+                    scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 2];
                 else
-                    scriptCodePtr = scriptCodeStart
-                                    + jumpTable[jumpTableStart + scriptEng.operands[0] + 4
-                                                    + (scriptEng.operands[1] - jumpTable[jumpTableStart + scriptEng.operands[0]])];
+                    scriptDataPtr = scriptCodePtr
+                                    + jumpTableData[jumpTablePtr + scriptEng.operands[0] + 4
+                                                    + (scriptEng.operands[1] - jumpTableData[jumpTablePtr + scriptEng.operands[0]])];
                 opcodeSize = 0;
                 break;
             case FUNC_BREAK:
                 opcodeSize    = 0;
-                scriptCodePtr = scriptCodeStart + jumpTable[jumpTableStart + jumpTableStack[jumpTableStackPos--] + 3];
+                scriptDataPtr = scriptCodePtr + jumpTableData[jumpTablePtr + jumpTableStack[jumpTableStackPos--] + 3];
                 break;
             case FUNC_ENDSWITCH:
                 opcodeSize = 0;
@@ -4506,20 +4407,69 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
             case FUNC_DRAWACTNAME: {
                 opcodeSize = 0;
                 int charID = 0;
+				int wordoffset = 0;
                 switch (scriptEng.operands[3]) { // Draw Mode
-                    case 0:                      // Draw Word 1 (but aligned from the right instead of left)
+                    case 0: // Draw Word 1 right aligned
                         charID = 0;
+						
+						//Do a dummy run to get the length
+                        if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0) {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = -1;
+                            if (character == '-')
+                                character = 0;
+                            if (character >= '0' && character <= '9')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
+
+                            if (character <= -1) {
+                                wordoffset += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                wordoffset += spriteFrame->width + scriptEng.operands[6];
+                            }
+
+                            scriptEng.operands[0] += 26;
+                            charID++;
+                        }
+
+                        while (titleCardText[charID] != 0 && titleCardText[charID] != '-') {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = -1;
+                            if (character == '-')
+                                character = 0;
+                            if (character > '/' && character < ':')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
 
-                        for (charID = 0;; ++charID) {
-                            int nextChar = titleCardText[charID + 1];
-                            if (nextChar == '-' || !nextChar)
-                                break;
+                            if (character <= -1) {
+                                wordoffset += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                wordoffset += spriteFrame->width + scriptEng.operands[6];
+                            }
+                            charID++;
                         }
-
-                        while (charID >= 0) {
+						//Shift left by the calculated amount, and reset for the next run
+						scriptEng.operands[1] -= wordoffset;
+						charID = 0;
+						if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0)
+							scriptEng.operands[0] -= 26;
+						
+                        // Draw the first letter as a capital letter, the rest are lowercase (if scriptEng.operands[4] is true, otherwise they're all
+                        // uppercase)
+                        if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0) {
                             int character = titleCardText[charID];
                             if (character == ' ')
-                                character = -1; // special space char
+                                character = -1;
                             if (character == '-')
                                 character = 0;
                             if (character >= '0' && character <= '9')
@@ -4528,22 +4478,46 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                 character -= 'A';
 
                             if (character <= -1) {
-                                scriptEng.operands[1] -= scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                                scriptEng.operands[1] += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
                             }
                             else {
                                 character += scriptEng.operands[0];
                                 spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                DrawSprite(scriptEng.operands[1] + spriteFrame->pivotX, scriptEng.operands[2] + spriteFrame->pivotY,
+                                           spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+                                scriptEng.operands[1] += spriteFrame->width + scriptEng.operands[6];
+                            }
+
+                            scriptEng.operands[0] += 26;
+                            charID++;
+                        }
 
-                                scriptEng.operands[1] -= spriteFrame->width + scriptEng.operands[6];
+                        while (titleCardText[charID] != 0 && titleCardText[charID] != '-') {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = -1;
+                            if (character == '-')
+                                character = 0;
+                            if (character > '/' && character < ':')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
 
+                            if (character <= -1) {
+                                scriptEng.operands[1] += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
                                 DrawSprite(scriptEng.operands[1] + spriteFrame->pivotX, scriptEng.operands[2] + spriteFrame->pivotY,
                                            spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+                                scriptEng.operands[1] += spriteFrame->width + scriptEng.operands[6];
                             }
-                            charID--;
+                            charID++;
                         }
                         break;
 
-                    case 1: // Draw Word 1
+                    case 1: // Draw Word 1 left aligned
                         charID = 0;
 
                         // Draw the first letter as a capital letter, the rest are lowercase (if scriptEng.operands[4] is true, otherwise they're all
@@ -4599,8 +4573,115 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                         }
                         break;
 
-                    case 2: // Draw Word 2
+                    case 2: // Draw Word 2 left aligned
+                        charID = titleCardWord2;
+
+                        // Draw the first letter as a capital letter, the rest are lowercase (if scriptEng.operands[4] is true, otherwise they're all
+                        // uppercase)
+                        if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0) {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = 0;
+                            if (character == '-')
+                                character = 0;
+                            if (character >= '0' && character <= '9')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
+
+                            if (character <= -1) {
+                                scriptEng.operands[1] += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                DrawSprite(scriptEng.operands[1] + spriteFrame->pivotX, scriptEng.operands[2] + spriteFrame->pivotY,
+                                           spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+                                scriptEng.operands[1] += spriteFrame->width + scriptEng.operands[6];
+                            }
+                            scriptEng.operands[0] += 26;
+                            charID++;
+                        }
+
+                        while (titleCardText[charID] != 0) {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = 0;
+                            if (character == '-')
+                                character = 0;
+                            if (character >= '0' && character <= '9')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
+
+                            if (character <= -1) {
+                                scriptEng.operands[1] += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                DrawSprite(scriptEng.operands[1] + spriteFrame->pivotX, scriptEng.operands[2] + spriteFrame->pivotY,
+                                           spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+                                scriptEng.operands[1] += spriteFrame->width + scriptEng.operands[6];
+                            }
+                            charID++;
+                        }
+                        break;
+
+                    case 3: // Draw Word 2 right aligned
                         charID = titleCardWord2;
+						
+						//another dummy run for the length
+						if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0) {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = 0;
+                            if (character == '-')
+                                character = 0;
+                            if (character >= '0' && character <= '9')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
+
+                            if (character <= -1) {
+                                wordoffset += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                wordoffset += spriteFrame->width + scriptEng.operands[6];
+                            }
+                            scriptEng.operands[0] += 26;
+                            charID++;
+                        }
+
+                        while (titleCardText[charID] != 0) {
+                            int character = titleCardText[charID];
+                            if (character == ' ')
+                                character = 0;
+                            if (character == '-')
+                                character = 0;
+                            if (character >= '0' && character <= '9')
+                                character -= 22;
+                            if (character > '9' && character < 'f')
+                                character -= 'A';
+
+                            if (character <= -1) {
+                                wordoffset += scriptEng.operands[5] + scriptEng.operands[6]; // spaceWidth + spacing
+                            }
+                            else {
+                                character += scriptEng.operands[0];
+                                spriteFrame = &scriptFrames[scriptInfo->frameListOffset + character];
+                                wordoffset += spriteFrame->width + scriptEng.operands[6];
+                            }
+                            charID++;
+                        }
+						
+						//Shift left by the calculated amount, and reset for the next run
+						scriptEng.operands[1] -= wordoffset;
+						charID = titleCardWord2;
+						if (scriptEng.operands[4] == 1 && titleCardText[charID] != 0)
+							scriptEng.operands[0] -= 26;
 
                         // Draw the first letter as a capital letter, the rest are lowercase (if scriptEng.operands[4] is true, otherwise they're all
                         // uppercase)
@@ -4694,7 +4775,11 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 break;
             case FUNC_SETSCREENFADE:
                 opcodeSize = 0;
-                SetFade(scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]);
+                SetFade(1, scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]);
+                break;
+            case FUNC_SETCLASSICFADE:
+                opcodeSize = 0;
+                SetFade(2, scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]);
                 break;
             case FUNC_SETACTIVEPALETTE:
                 opcodeSize = 0;
@@ -4722,8 +4807,14 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
             case FUNC_DRAWSPRITEFX:
                 opcodeSize  = 0;
                 spriteFrame = &scriptFrames[scriptInfo->frameListOffset + scriptEng.operands[0]];
+                
                 switch (scriptEng.operands[1]) {
-                    default: break;
+					case 0: //No FX Flags, just draw the sprite
+						DrawSprite((scriptEng.operands[2] >> 16) - xScrollOffset + spriteFrame->pivotX,
+								   (scriptEng.operands[3] >> 16) - yScrollOffset + spriteFrame->pivotY, spriteFrame->width,
+								   spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+						break;
+						//If only one FX flag (or rotozoom) use the pre-existing functions
                     case FX_SCALE:
                         DrawSpriteScaled(entity->direction, (scriptEng.operands[2] >> 16) - xScrollOffset,
                                          (scriptEng.operands[3] >> 16) - yScrollOffset, -spriteFrame->pivotX, -spriteFrame->pivotY, entity->scale,
@@ -4774,6 +4865,8 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                 break;
                         }
                         break;
+					//Removed because unused
+					/*
                     case FX_TINT:
                         if (entity->inkEffect == INK_ALPHA) {
                             DrawScaledTintMask(entity->direction, (scriptEng.operands[2] >> 16) - xScrollOffset,
@@ -4788,6 +4881,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                              scriptInfo->spriteSheetID);
                         }
                         break;
+					*/
                     case FX_FLIP:
                         switch (entity->direction) {
                             default:
@@ -4815,13 +4909,25 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                 break;
                         }
                         break;
+                    default: //Anything those can't handle goes to the all-in-one function
+						DrawSpriteAllFX(entity->direction, (scriptEng.operands[2] >> 16) - xScrollOffset,
+									     (scriptEng.operands[3] >> 16) - yScrollOffset, -spriteFrame->pivotX, -spriteFrame->pivotY,
+									     spriteFrame->sprX, spriteFrame->sprY, spriteFrame->width, spriteFrame->height, entity->rotation,
+									     entity->scale, scriptInfo->spriteSheetID, entity->alpha, entity->inkEffect, scriptEng.operands[1]);
+					    break;
                 }
                 break;
+                
             case FUNC_DRAWSPRITESCREENFX:
                 opcodeSize  = 0;
                 spriteFrame = &scriptFrames[scriptInfo->frameListOffset + scriptEng.operands[0]];
+                
                 switch (scriptEng.operands[1]) {
-                    default: break;
+					case 0: //No FX Flags, just draw the sprite
+						DrawSprite(scriptEng.operands[2] + spriteFrame->pivotX, scriptEng.operands[3] + spriteFrame->pivotY,
+								   spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
+						break;
+						//If only one FX flag (or rotozoom) use the pre-existing functions
                     case FX_SCALE:
                         DrawSpriteScaled(entity->direction, scriptEng.operands[2], scriptEng.operands[3], -spriteFrame->pivotX, -spriteFrame->pivotY,
                                          entity->scale, entity->scale, spriteFrame->width, spriteFrame->height, spriteFrame->sprX, spriteFrame->sprY,
@@ -4865,6 +4971,8 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                 break;
                         }
                         break;
+					//Removed because unused
+					/*
                     case FX_TINT:
                         if (entity->inkEffect == INK_ALPHA) {
                             DrawScaledTintMask(entity->direction, scriptEng.operands[2], scriptEng.operands[3], -spriteFrame->pivotX,
@@ -4877,6 +4985,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                              spriteFrame->sprX, spriteFrame->sprY, scriptInfo->spriteSheetID);
                         }
                         break;
+					*/
                     case FX_FLIP:
                         switch (entity->direction) {
                             default:
@@ -4902,8 +5011,14 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                 break;
                         }
                         break;
+                    default: //Anything those can't handle goes to the all-in-one function
+						DrawSpriteAllFX(entity->direction, scriptEng.operands[2], scriptEng.operands[3], -spriteFrame->pivotX,
+									     -spriteFrame->pivotY, spriteFrame->sprX, spriteFrame->sprY, spriteFrame->width, spriteFrame->height,
+									     entity->rotation, entity->scale, scriptInfo->spriteSheetID, entity->alpha, entity->inkEffect, scriptEng.operands[1]);
+						break;
                 }
                 break;
+                
             case FUNC_LOADANIMATION:
                 opcodeSize           = 0;
                 scriptInfo->animFile = AddAnimationFile(scriptText);
@@ -4939,6 +5054,11 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 DrawRectangle(scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3], scriptEng.operands[4],
                               scriptEng.operands[5], scriptEng.operands[6], scriptEng.operands[7]);
                 break;
+			case FUNC_CLASSICTINT:
+                opcodeSize = 0;
+                DrawClassicFade(scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3], scriptEng.operands[4],
+                              scriptEng.operands[5], scriptEng.operands[6], scriptEng.operands[7]);
+                break;			
             case FUNC_RESETOBJECTENTITY: {
                 opcodeSize     = 0;
                 Entity *newEnt = &objectEntityList[scriptEng.operands[0]];
@@ -4948,7 +5068,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 newEnt->xpos               = scriptEng.operands[3];
                 newEnt->ypos               = scriptEng.operands[4];
                 newEnt->direction          = FLIP_NONE;
-                newEnt->priority           = PRIORITY_BOUNDS;
+                newEnt->priority           = PRIORITY_ACTIVE_BOUNDS;
                 newEnt->drawOrder          = 3;
                 newEnt->scale              = 512;
                 newEnt->inkEffect          = INK_NONE;
@@ -4966,12 +5086,12 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                                        scriptEng.operands[5], &objectEntityList[scriptEng.operands[6]], scriptEng.operands[7], scriptEng.operands[8],
                                        scriptEng.operands[9], scriptEng.operands[10]);
                         break;
-                    case C_SOLID:
+                    case C_BOX:
                         BoxCollision(&objectEntityList[scriptEng.operands[1]], scriptEng.operands[2], scriptEng.operands[3], scriptEng.operands[4],
                                      scriptEng.operands[5], &objectEntityList[scriptEng.operands[6]], scriptEng.operands[7], scriptEng.operands[8],
                                      scriptEng.operands[9], scriptEng.operands[10]);
                         break;
-                    case C_SOLID2:
+                    case C_BOX2:
                         BoxCollision2(&objectEntityList[scriptEng.operands[1]], scriptEng.operands[2], scriptEng.operands[3], scriptEng.operands[4],
                                       scriptEng.operands[5], &objectEntityList[scriptEng.operands[6]], scriptEng.operands[7], scriptEng.operands[8],
                                       scriptEng.operands[9], scriptEng.operands[10]);
@@ -5074,13 +5194,8 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     default: break;
                     case CSIDE_FLOOR: ObjectFloorCollision(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
                     case CSIDE_LWALL: ObjectLWallCollision(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
-                    case CSIDE_RWALL: ObjectRWallCollision(scriptEng.operands[1] - 1, scriptEng.operands[2], scriptEng.operands[3]); break;
-                    case CSIDE_ROOF: ObjectRoofCollision(scriptEng.operands[1], scriptEng.operands[2] - 1, scriptEng.operands[3]); break;
-#if RETRO_REV03
-                    // Yes, the right side also calls for LWall
-                    case CSIDE_LENTITY: ObjectLWallCollision(scriptEng.operands[2], 0, objectEntityList[scriptEng.operands[1]].collisionPlane); break;
-                    case CSIDE_RENTITY: ObjectLWallCollision(scriptEng.operands[2] - 1, 0, objectEntityList[scriptEng.operands[1]].collisionPlane); break;
-#endif
+                    case CSIDE_RWALL: ObjectRWallCollision(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
+                    case CSIDE_ROOF: ObjectRoofCollision(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
                 }
                 break;
             case FUNC_OBJECTTILEGRIP:
@@ -5089,13 +5204,25 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     default: break;
                     case CSIDE_FLOOR: ObjectFloorGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
                     case CSIDE_LWALL: ObjectLWallGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
-                    case CSIDE_RWALL: ObjectRWallGrip(scriptEng.operands[1] - 1, scriptEng.operands[2], scriptEng.operands[3]); break;
-                    case CSIDE_ROOF: ObjectRoofGrip(scriptEng.operands[1], scriptEng.operands[2] - 1, scriptEng.operands[3]); break;
-#if RETRO_REV03
-                    case CSIDE_LENTITY: ObjectLEntityGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
-                    case CSIDE_RENTITY: ObjectREntityGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
-#endif
+                    case CSIDE_RWALL: ObjectRWallGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
+                    case CSIDE_ROOF: ObjectRoofGrip(scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]); break;
+                }
+                break;
+            case FUNC_LOADVIDEO:
+                opcodeSize = 0;
+                PauseSound();
+
+                if (FindStringToken(scriptText, ".rsv", 1) <= -1) {
+                    PlayVideoFile(scriptText);
+                } else {
+                    scriptInfo->spriteSheetID = AddGraphicsFile(scriptText);
                 }
+
+                ResumeSound();
+                break;
+            case FUNC_NEXTVIDEOFRAME:
+                opcodeSize = 0;
+                UpdateVideoFrame();
                 break;
             case FUNC_NOT: scriptEng.operands[0] = ~scriptEng.operands[0]; break;
             case FUNC_DRAW3DSCENE:
@@ -5206,12 +5333,12 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 break;
             case FUNC_CALLFUNCTION: {
                 opcodeSize                        = 0;
+                functionStack[functionStackPos++] = scriptDataPtr;
+                functionStack[functionStackPos++] = jumpTablePtr;
                 functionStack[functionStackPos++] = scriptCodePtr;
-                functionStack[functionStackPos++] = jumpTableStart;
-                functionStack[functionStackPos++] = scriptCodeStart;
-                scriptCodeStart                   = scriptFunctionList[scriptEng.operands[0]].ptr.scriptCodePtr;
-                jumpTableStart                    = scriptFunctionList[scriptEng.operands[0]].ptr.jumpTablePtr;
-                scriptCodePtr                     = scriptCodeStart;
+                scriptCodePtr                     = functionScriptList[scriptEng.operands[0]].scriptCodePtr;
+                jumpTablePtr                      = functionScriptList[scriptEng.operands[0]].jumpTablePtr;
+                scriptDataPtr                     = scriptCodePtr;
                 break;
             }
             case FUNC_RETURN:
@@ -5220,9 +5347,9 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     running = false;
                 }
                 else { // function, jump out
-                    scriptCodeStart = functionStack[--functionStackPos];
-                    jumpTableStart  = functionStack[--functionStackPos];
-                    scriptCodePtr   = functionStack[--functionStackPos];
+                    scriptCodePtr = functionStack[--functionStackPos];
+                    jumpTablePtr  = functionStack[--functionStackPos];
+                    scriptDataPtr = functionStack[--functionStackPos];
                 }
                 break;
             case FUNC_SETLAYERDEFORMATION:
@@ -5232,7 +5359,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 break;
             case FUNC_CHECKTOUCHRECT: opcodeSize = 0; scriptEng.checkResult = -1;
 #if !RETRO_USE_ORIGINAL_CODE
-                AddDebugHitbox(H_TYPE_FINGER, NULL, scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]);
+                addDebugHitbox(H_TYPE_FINGER, NULL, scriptEng.operands[0], scriptEng.operands[1], scriptEng.operands[2], scriptEng.operands[3]);
 #endif
                 for (int f = 0; f < touches; ++f) {
                     if (touchDown[f] && touchX[f] > scriptEng.operands[0] && touchX[f] < scriptEng.operands[2] && touchY[f] > scriptEng.operands[1]
@@ -5333,7 +5460,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 opcodeSize            = 0;
                 scriptEng.checkResult = WriteSaveRAMData();
                 break;
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
             case FUNC_LOADTEXTFONT: {
                 opcodeSize = 0;
                 LoadFontFile(scriptText);
@@ -5343,7 +5470,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
             case FUNC_LOADTEXTFILE: {
                 opcodeSize     = 0;
                 TextMenu *menu = &gameMenu[scriptEng.operands[0]];
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
                 LoadTextFile(menu, scriptText, scriptEng.operands[2] != 0);
 #else
                 LoadTextFile(menu, scriptText, false);
@@ -5361,7 +5488,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 }
                 break;
             }
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
             case FUNC_DRAWTEXT: {
                 opcodeSize        = 0;
                 textMenuSurfaceNo = scriptInfo->spriteSheetID;
@@ -5382,9 +5509,9 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 int arrPos = scriptEng.operands[1];
                 if (arrPos >= 0) {
                     int pos     = scriptEng.operands[2];
-                    int arrSize = scriptCode[pos];
+                    int arrSize = scriptData[pos];
                     if (arrPos < arrSize)
-                        scriptEng.operands[0] = scriptCode[pos + arrPos + 1];
+                        scriptEng.operands[0] = scriptData[pos + arrPos + 1];
                 }
                 break;
             }
@@ -5393,26 +5520,15 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 int arrPos = scriptEng.operands[1];
                 if (arrPos >= 0) {
                     int pos     = scriptEng.operands[2];
-                    int arrSize = scriptCode[pos];
+                    int arrSize = scriptData[pos];
                     if (arrPos < arrSize)
-                        scriptCode[pos + arrPos + 1] = scriptEng.operands[0];
+                        scriptData[pos + arrPos + 1] = scriptEng.operands[0];
                 }
                 break;
             }
             case FUNC_CHECKCURRENTSTAGEFOLDER:
                 opcodeSize            = 0;
                 scriptEng.checkResult = StrComp(stageList[activeStageList][stageListPosition].folder, scriptText);
-#if RETRO_REV03
-                // Mission Mode stuff
-                if (!scriptEng.checkResult) {
-                    int targetLength  = strlen(stageList[activeStageList][stageListPosition].folder);
-                    int currentLength = strlen(scriptText);
-                    if (targetLength > currentLength) {
-                        scriptEng.checkResult =
-                            StrComp(&stageList[activeStageList][stageListPosition].folder[targetLength - currentLength], scriptText);
-                    }
-                }
-#endif
                 break;
             case FUNC_ABS: {
                 scriptEng.operands[0] = abs(scriptEng.operands[0]);
@@ -5455,9 +5571,6 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 }
                 break;
             case FUNC_SETOBJECTRANGE: {
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = range
-
                 opcodeSize       = 0;
                 int offset       = (scriptEng.operands[0] >> 1) - SCREEN_CENTERX;
                 OBJECT_BORDER_X1 = offset + 0x80;
@@ -5466,34 +5579,20 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 OBJECT_BORDER_X4 = scriptEng.operands[0] + 0x20 - offset;
                 break;
             }
-#if RETRO_REV02
+#if !RETRO_REV00 && !RETRO_REV01
             case FUNC_GETOBJECTVALUE: {
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = result
-                // scriptEng.operands[1] = valueID
-                // scriptEng.operands[2] = entitySlot
-
                 if (scriptEng.operands[1] < 48)
                     scriptEng.operands[0] = objectEntityList[scriptEng.operands[2]].values[scriptEng.operands[1]];
                 break;
             }
             case FUNC_SETOBJECTVALUE: {
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = value
-                // scriptEng.operands[1] = valueID
-                // scriptEng.operands[2] = entitySlot
-
                 opcodeSize = 0;
                 if (scriptEng.operands[1] < 48)
                     objectEntityList[scriptEng.operands[2]].values[scriptEng.operands[1]] = scriptEng.operands[0];
                 break;
             }
             case FUNC_COPYOBJECT: {
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = destSlot
-                // scriptEng.operands[1] = srcSlot
-                // scriptEng.operands[2] = count
-
+                // dstID, srcID, count
                 Entity *dstList = &objectEntityList[scriptEng.operands[0]];
                 Entity *srcList = &objectEntityList[scriptEng.operands[1]];
                 for (int i = 0; i < scriptEng.operands[2]; ++i) memcpy(&dstList[i], &srcList[i], sizeof(Entity));
@@ -5501,11 +5600,6 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
             }
 #endif
             case FUNC_PRINT: {
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = message (can be a regular value or a string depending on scriptEng.operands[1])
-                // scriptEng.operands[1] = isInt
-                // scriptEng.operands[2] = useEndLine
-
                 endLine = false;
                 if (scriptEng.operands[1])
                     PrintLog("%d", scriptEng.operands[0]);
@@ -5517,172 +5611,40 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                 endLine = true;
                 break;
             }
-
-#if RETRO_REV03
-                // Extras for origins 2PVS,
-                // most of these aren't (and won't be) implemented here because they rely on v5 tech that isn't part of the scope of this project
-            case FUNC_CHECKCAMERAPROXIMITY:
-                scriptEng.checkResult = false;
-
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = pos.x
-                // scriptEng.operands[1] = pos.y
-                // scriptEng.operands[2] = range.x
-                // scriptEng.operands[3] = range.y
-                //
-                // FUNCTION NOTES:
-                // - Sets scriptEng.checkResult
-
-                if (scriptEng.operands[2] > 0 && scriptEng.operands[3] > 0) {
-                    int sx = abs(scriptEng.operands[0] - cameraXPos);
-                    int sy = abs(scriptEng.operands[1] - cameraYPos);
-
-                    if (sx < scriptEng.operands[2] && sy < scriptEng.operands[3]) {
-                        scriptEng.checkResult = true;
-                        break;
-                    }
-                }
-                else {
-                    if (scriptEng.operands[2] > 0) {
-                        int sx = abs(scriptEng.operands[0] - cameraXPos);
-
-                        if (sx < scriptEng.operands[2]) {
-                            scriptEng.checkResult = true;
-                            break;
-                        }
-                    }
-                    else if (scriptEng.operands[3] > 0) {
-                        int sy = abs(scriptEng.operands[1] - cameraYPos);
-
-                        if (sy < scriptEng.operands[3]) {
-                            scriptEng.checkResult = true;
-                            break;
-                        }
-                    }
-                }
-                break;
-
-            case FUNC_SETSCREENCOUNT:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = screenCount
-
-                break;
-
-            case FUNC_SETSCREENVERTICES:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = startVert2P_S1
-                // scriptEng.operands[1] = startVert2P_S2
-                // scriptEng.operands[2] = startVert3P_S1
-                // scriptEng.operands[3] = startVert3P_S2
-                // scriptEng.operands[4] = startVert3P_S3
-
-                break;
-
-            case FUNC_GETINPUTDEVICEID:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = deviceID
-                // scriptEng.operands[1] = inputSlot
-                //
-                // FUNCTION NOTES:
-                // - Assigns the device's id to scriptEng.operands[0]
-
-                break;
-
-            case FUNC_GETFILTEREDINPUTDEVICEID:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = deviceID
-                // scriptEng.operands[1] = confirmOnly
-                // scriptEng.operands[2] = unassignedOnly
-                // scriptEng.operands[3] = maxInactiveTimer
-                //
-                // FUNCTION NOTES:
-                // - Assigns the filtered device's id to scriptEng.operands[0]
-
-                break;
-
-            case FUNC_GETINPUTDEVICETYPE:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = deviceType
-                // scriptEng.operands[1] = deviceID
-                //
-                // FUNCTION NOTES:
-                // - Assigns the device's type to scriptEng.operands[0]
-
-                break;
-
-            case FUNC_ISINPUTDEVICEASSIGNED:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = deviceID
-
-                break;
-
-            case FUNC_ASSIGNINPUTSLOTTODEVICE:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = inputSlot
-                // scriptEng.operands[1] = deviceID
-
-                break;
-
-            case FUNC_ISSLOTASSIGNED:
-                // FUNCTION PARAMS:
-                // scriptEng.operands[0] = inputSlot
-                //
-                // FUNCTION NOTES:
-                // - Sets scriptEng.checkResult
-
-                break;
-
-            case FUNC_RESETINPUTSLOTASSIGNMENTS:
-                // FUNCTION PARAMS:
-                // None
-
-                break;
-#endif
         }
 
         // Set Values
         if (opcodeSize > 0)
-            scriptCodePtr -= scriptCodePtr - scriptCodeOffset;
+            scriptDataPtr -= scriptDataPtr - scriptCodeOffset;
         for (int i = 0; i < opcodeSize; ++i) {
-            int opcodeType = scriptCode[scriptCodePtr++];
+            int opcodeType = scriptData[scriptDataPtr++];
             if (opcodeType == SCRIPTVAR_VAR) {
                 int arrayVal = 0;
-                switch (scriptCode[scriptCodePtr++]) { // variable
+                switch (scriptData[scriptDataPtr++]) { // variable
                     case VARARR_NONE: arrayVal = objectEntityPos; break;
-
                     case VARARR_ARRAY:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = scriptEng.arrayPosition[scriptCode[scriptCodePtr++]];
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = scriptEng.arrayPosition[scriptData[scriptDataPtr++]];
                         else
-                            arrayVal = scriptCode[scriptCodePtr++];
+                            arrayVal = scriptData[scriptDataPtr++];
                         break;
-
                     case VARARR_ENTNOPLUS1:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = objectEntityPos + scriptEng.arrayPosition[scriptCode[scriptCodePtr++]];
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = objectEntityPos + scriptEng.arrayPosition[scriptData[scriptDataPtr++]];
                         else
-                            arrayVal = objectEntityPos + scriptCode[scriptCodePtr++];
+                            arrayVal = objectEntityPos + scriptData[scriptDataPtr++];
                         break;
-
                     case VARARR_ENTNOMINUS1:
-                        if (scriptCode[scriptCodePtr++] == 1)
-                            arrayVal = objectEntityPos - scriptEng.arrayPosition[scriptCode[scriptCodePtr++]];
+                        if (scriptData[scriptDataPtr++] == 1)
+                            arrayVal = objectEntityPos - scriptEng.arrayPosition[scriptData[scriptDataPtr++]];
                         else
-                            arrayVal = objectEntityPos - scriptCode[scriptCodePtr++];
+                            arrayVal = objectEntityPos - scriptData[scriptDataPtr++];
                         break;
-
                     default: break;
                 }
 
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-                bool inputCheck = true; // Default to true for mobile bytecode
-                // If we're using the scripts or an Origins datafile, check the array value
-                if (forceUseScripts || Engine.usingOrigins)
-                    inputCheck = arrayVal <= 1;
-#endif
-
                 // Variables
-                switch (scriptCode[scriptCodePtr++]) {
+                switch (scriptData[scriptDataPtr++]) {
                     default: break;
                     case VAR_TEMP0: scriptEng.temp[0] = scriptEng.operands[i]; break;
                     case VAR_TEMP1: scriptEng.temp[1] = scriptEng.operands[i]; break;
@@ -5702,7 +5664,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     case VAR_ARRAYPOS6: scriptEng.arrayPosition[6] = scriptEng.operands[i]; break;
                     case VAR_ARRAYPOS7: scriptEng.arrayPosition[7] = scriptEng.operands[i]; break;
                     case VAR_GLOBAL: globalVariables[arrayVal] = scriptEng.operands[i]; break;
-                    case VAR_LOCAL: scriptCode[arrayVal] = scriptEng.operands[i]; break;
+                    case VAR_LOCAL: scriptData[arrayVal] = scriptEng.operands[i]; break;
                     case VAR_OBJECTENTITYPOS: break;
                     case VAR_OBJECTGROUPID: {
                         objectEntityList[arrayVal].groupID = scriptEng.operands[i];
@@ -6106,26 +6068,7 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                         break;
                     }
                     case VAR_STAGESTATE: stageMode = scriptEng.operands[i]; break;
-                    case VAR_STAGEACTIVELIST:
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-                        // BONUS_STAGE and SPECIAL_STAGE are swapped on Origins bytecode, so correct it here
-                        if (Engine.usingOrigins && !forceUseScripts) {
-                            int listSlots[] = { 0, 1, 3, 2 };
-
-                            int listID = scriptEng.operands[i];
-                            if (listID <= 3)
-                                listID = listSlots[listID];
-                            else
-                                listID = 2; // BONUS_STAGE
-
-                            activeStageList = listID;
-                        }
-                        else
-                            activeStageList = scriptEng.operands[i];
-#else
-                        activeStageList = scriptEng.operands[i];
-#endif
-                        break;
+                    case VAR_STAGEACTIVELIST: activeStageList = scriptEng.operands[i]; break;
                     case VAR_STAGELISTPOS: stageListPosition = scriptEng.operands[i]; break;
                     case VAR_STAGETIMEENABLED: timeEnabled = scriptEng.operands[i]; break;
                     case VAR_STAGEMILLISECONDS: stageMilliseconds = scriptEng.operands[i]; break;
@@ -6193,149 +6136,34 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                     case VAR_MUSICVOLUME: SetMusicVolume(scriptEng.operands[i]); break;
                     case VAR_MUSICCURRENTTRACK: break;
                     case VAR_MUSICPOSITION: break;
-#if RETRO_REV03 && !RETRO_USE_ORIGINAL_CODE
-                    case VAR_KEYDOWNUP:
-                        if (inputCheck)
-                            keyDown.up = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNDOWN:
-                        if (inputCheck)
-                            keyDown.down = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNLEFT:
-                        if (inputCheck)
-                            keyDown.left = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNRIGHT:
-                        if (inputCheck)
-                            keyDown.right = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONA:
-                        if (inputCheck)
-                            keyDown.A = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONB:
-                        if (inputCheck)
-                            keyDown.B = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONC:
-                        if (inputCheck)
-                            keyDown.C = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONX:
-                        if (inputCheck)
-                            keyDown.X = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONY:
-                        if (inputCheck)
-                            keyDown.Y = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONZ:
-                        if (inputCheck)
-                            keyDown.Z = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONL:
-                        if (inputCheck)
-                            keyDown.L = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNBUTTONR:
-                        if (inputCheck)
-                            keyDown.R = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNSTART:
-                        if (inputCheck)
-                            keyDown.start = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYDOWNSELECT:
-                        if (inputCheck)
-                            keyDown.select = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSUP:
-                        if (inputCheck)
-                            keyPress.up = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSDOWN:
-                        if (inputCheck)
-                            keyPress.down = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSLEFT:
-                        if (inputCheck)
-                            keyPress.left = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSRIGHT:
-                        if (inputCheck)
-                            keyPress.right = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONA:
-                        if (inputCheck)
-                            keyPress.A = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONB:
-                        if (inputCheck)
-                            keyPress.B = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONC:
-                        if (inputCheck)
-                            keyPress.C = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONX:
-                        if (inputCheck)
-                            keyPress.X = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONY:
-                        if (inputCheck)
-                            keyPress.Y = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONZ:
-                        if (inputCheck)
-                            keyPress.Z = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONL:
-                        if (inputCheck)
-                            keyPress.L = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSBUTTONR:
-                        if (inputCheck)
-                            keyPress.R = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSSTART:
-                        if (inputCheck)
-                            keyPress.start = scriptEng.operands[i];
-                        break;
-                    case VAR_KEYPRESSSELECT:
-                        if (inputCheck)
-                            keyPress.select = scriptEng.operands[i];
-                        break;
-#else
-                    case VAR_KEYDOWNUP: keyDown.up = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNDOWN: keyDown.down = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNLEFT: keyDown.left = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNRIGHT: keyDown.right = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONA: keyDown.A = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONB: keyDown.B = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONC: keyDown.C = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONX: keyDown.X = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONY: keyDown.Y = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONZ: keyDown.Z = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONL: keyDown.L = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNBUTTONR: keyDown.R = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNSTART: keyDown.start = scriptEng.operands[i]; break;
-                    case VAR_KEYDOWNSELECT: keyDown.select = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSUP: keyPress.up = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSDOWN: keyPress.down = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSLEFT: keyPress.left = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSRIGHT: keyPress.right = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONA: keyPress.A = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONB: keyPress.B = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONC: keyPress.C = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONX: keyPress.X = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONY: keyPress.Y = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONZ: keyPress.Z = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONL: keyPress.L = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSBUTTONR: keyPress.R = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSSTART: keyPress.start = scriptEng.operands[i]; break;
-                    case VAR_KEYPRESSSELECT: keyPress.select = scriptEng.operands[i]; break;
-#endif
+                    case VAR_INPUTDOWNUP: inputDown.up = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNDOWN: inputDown.down = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNLEFT: inputDown.left = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNRIGHT: inputDown.right = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONA: inputDown.A = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONB: inputDown.B = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONC: inputDown.C = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONX: inputDown.X = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONY: inputDown.Y = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONZ: inputDown.Z = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONL: inputDown.L = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNBUTTONR: inputDown.R = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNSTART: inputDown.start = scriptEng.operands[i]; break;
+                    case VAR_INPUTDOWNSELECT: inputDown.select = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSUP: inputPress.up = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSDOWN: inputPress.down = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSLEFT: inputPress.left = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSRIGHT: inputPress.right = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONA: inputPress.A = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONB: inputPress.B = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONC: inputPress.C = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONX: inputPress.X = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONY: inputPress.Y = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONZ: inputPress.Z = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONL: inputPress.L = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSBUTTONR: inputPress.R = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSSTART: inputPress.start = scriptEng.operands[i]; break;
+                    case VAR_INPUTPRESSSELECT: inputPress.select = scriptEng.operands[i]; break;
                     case VAR_MENU1SELECTION: gameMenu[0].selection1 = scriptEng.operands[i]; break;
                     case VAR_MENU2SELECTION: gameMenu[1].selection1 = scriptEng.operands[i]; break;
                     case VAR_TILELAYERXSIZE: stageLayouts[arrayVal].xsize = scriptEng.operands[i]; break;
@@ -6396,64 +6224,31 @@ void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent)
                         bgmVolume = scriptEng.operands[i];
                         SetGameVolumes(bgmVolume, sfxVolume);
                         break;
-#if RETRO_REV00
                     case VAR_ENGINEPLATFORMID: break;
-#endif
                     case VAR_ENGINETRIALMODE: Engine.trialMode = scriptEng.operands[i]; break;
 #if !RETRO_REV00
                     case VAR_ENGINEDEVICETYPE: break;
 #endif
-
-#if RETRO_REV03
-                    // Origins Extras
-                    // Due to using regular v4, these don't support array values like origins expects, so its always screen[0]
-                    case VAR_SCREENCURRENTID: break;
-                    case VAR_CAMERAENABLED:
-                        if (arrayVal == 0)
-                            cameraEnabled = scriptEng.operands[i];
-                        break;
-                    case VAR_CAMERATARGET:
-                        if (arrayVal == 0)
-                            cameraTarget = scriptEng.operands[i];
-                        break;
-                    case VAR_CAMERASTYLE:
-                        if (arrayVal == 0)
-                            cameraStyle = scriptEng.operands[i];
-                        break;
-                    case VAR_CAMERAXPOS:
-                        if (arrayVal == 0)
-                            cameraXPos = scriptEng.operands[i];
-                        break;
-                    case VAR_CAMERAYPOS:
-                        if (arrayVal == 0)
-                            cameraYPos = scriptEng.operands[i];
-                        break;
-                    case VAR_CAMERAADJUSTY:
-                        if (arrayVal == 0)
-                            cameraAdjustY = scriptEng.operands[i];
-                        break;
-#endif
-
 #if RETRO_USE_HAPTICS
                     case VAR_HAPTICSENABLED: Engine.hapticsEnabled = scriptEng.operands[i]; break;
 #endif
                 }
             }
             else if (opcodeType == SCRIPTVAR_INTCONST) { // int constant
-                scriptCodePtr++;
+                scriptDataPtr++;
             }
             else if (opcodeType == SCRIPTVAR_STRCONST) { // string constant
-                int strLen = scriptCode[scriptCodePtr++];
+                int strLen = scriptData[scriptDataPtr++];
                 for (int c = 0; c < strLen; ++c) {
                     switch (c % 4) {
                         case 0: break;
                         case 1: break;
                         case 2: break;
-                        case 3: ++scriptCodePtr; break;
+                        case 3: ++scriptDataPtr; break;
                         default: break;
                     }
                 }
-                scriptCodePtr++;
+                scriptDataPtr++;
             }
         }
     }
diff --git a/RSDKv4/Script.hpp b/RSDKv4/Script.hpp
index b845880..11ad8c9 100644
--- a/RSDKv4/Script.hpp
+++ b/RSDKv4/Script.hpp
@@ -1,7 +1,7 @@
 #ifndef SCRIPT_H
 #define SCRIPT_H
 
-#define SCRIPTCODE_COUNT (0x40000)
+#define SCRIPTDATA_COUNT (0x40000)
 #define JUMPTABLE_COUNT  (0x4000)
 #define FUNCTION_COUNT   (0x200)
 
@@ -16,19 +16,10 @@ struct ScriptPtr {
     int jumpTablePtr;
 };
 
-struct ScriptFunction {
-
-    byte access;
-#if RETRO_USE_COMPILER
-    char name[0x20];
-#endif
-    ScriptPtr ptr;
-};
-
 struct ObjectScript {
     int frameCount;
     int spriteSheetID;
-    ScriptPtr eventUpdate;
+    ScriptPtr eventMain;
     ScriptPtr eventDraw;
     ScriptPtr eventStartup;
     int frameListOffset;
@@ -42,22 +33,80 @@ struct ScriptEngine {
     int checkResult;
 };
 
+#if RETRO_USE_COMPILER
+#define TABLE_COUNT       (0x200)
+#define TABLE_ENTRY_COUNT (0x400)
+
+struct StaticInfo {
+    StaticInfo()
+    {
+        StrCopy(name, "");
+        value   = 0;
+        dataPos = SCRIPTDATA_COUNT - 1;
+    }
+    StaticInfo(const char *aliasName, int val)
+    {
+        StrCopy(name, aliasName);
+        value   = val;
+        dataPos = SCRIPTDATA_COUNT - 1;
+    }
+
+    char name[0x20];
+    int value;
+    int dataPos;
+};
+
+struct TableValue {
+    TableValue()
+    {
+        value   = 0;
+        dataPos = SCRIPTDATA_COUNT - 1;
+    }
+    TableValue(const char *aliasName, int val)
+    {
+        value   = val;
+        dataPos = SCRIPTDATA_COUNT - 1;
+    }
+
+    int value;
+    int dataPos;
+};
+
+struct TableInfo {
+    TableInfo()
+    {
+        StrCopy(name, "");
+        valueCount = 0;
+        dataPos    = SCRIPTDATA_COUNT - 1;
+    }
+    TableInfo(const char *aliasName, int valCnt)
+    {
+        StrCopy(name, aliasName);
+        valueCount = valCnt;
+        dataPos    = SCRIPTDATA_COUNT - 1;
+    }
+
+    char name[0x20];
+    int valueCount;
+    TableValue values[TABLE_ENTRY_COUNT];
+    int dataPos;
+};
+#endif
+
 enum ScriptSubs { EVENT_MAIN = 0, EVENT_DRAW = 1, EVENT_SETUP = 2 };
 
 extern ObjectScript objectScriptList[OBJECT_COUNT];
-extern ScriptFunction scriptFunctionList[FUNCTION_COUNT];
+extern ScriptPtr functionScriptList[FUNCTION_COUNT];
 
-extern int scriptCode[SCRIPTCODE_COUNT];
-extern int jumpTable[JUMPTABLE_COUNT];
+extern int scriptData[SCRIPTDATA_COUNT];
+extern int jumpTableData[JUMPTABLE_COUNT];
 
 extern int jumpTableStack[JUMPSTACK_COUNT];
 extern int functionStack[FUNCSTACK_COUNT];
 extern int foreachStack[FORSTACK_COUNT];
 
-extern int scriptCodePos;
-extern int scriptCodeOffset;
-extern int jumpTablePos;
-extern int jumpTableOffset;
+extern int scriptCodePos; // Bytecode reading offset
+extern int jumpTablePos;  // Bytecode reading offset
 extern int jumpTableStackPos;
 extern int functionStackPos;
 extern int foreachStackPos;
@@ -65,6 +114,11 @@ extern int foreachStackPos;
 extern ScriptEngine scriptEng;
 extern char scriptText[0x4000];
 
+extern int scriptDataPos;
+extern int scriptDataOffset;
+extern int jumpTableDataPos;
+extern int jumpTableDataOffset;
+
 bool ConvertStringToInteger(const char *text, int *value);
 
 #if RETRO_USE_COMPILER
@@ -75,9 +129,10 @@ extern int lineID;
 
 void CheckAliasText(char *text);
 void CheckStaticText(char *text);
-bool CheckTableText(char *text);
+TableInfo *CheckTableText(char *text);
 void ConvertArithmaticSyntax(char *text);
-void ConvertConditionalStatement(char *text);
+void ConvertIfWhileStatement(char *text);
+void ConvertForeachStatement(char *text);
 bool ConvertSwitchStatement(char *text);
 void ConvertFunctionText(char *text);
 void CheckCaseNumber(char *text);
@@ -92,7 +147,7 @@ void ParseScriptFile(char *scriptName, int scriptID);
 #endif
 void LoadBytecode(int stageListID, int scriptID);
 
-void ProcessScript(int scriptCodeStart, int jumpTableStart, byte scriptEvent);
+void ProcessScript(int scriptCodePtr, int jumpTablePtr, byte scriptSub);
 
 void ClearScriptData(void);
 
diff --git a/RSDKv4/String.hpp b/RSDKv4/String.hpp
index b524d0e..63e42ed 100644
--- a/RSDKv4/String.hpp
+++ b/RSDKv4/String.hpp
@@ -324,44 +324,36 @@ inline void ReadStringLine(char *text)
 
 inline void ReadStringLineUnicode(ushort *text)
 {
-    bool lineEnding;
-    ushort curChar = 0;
+    int curChar = 0;
     byte fileBuffer[2];
 
     int textPos = 0;
     while (true) {
         FileRead(fileBuffer, 2);
         curChar = fileBuffer[0] + (fileBuffer[1] << 8);
-        lineEnding = false;
-
-        switch (curChar) {
-            case '\t':
-            case ' ':
-                break;
-
-            case '\n':
-            case '\r':
-                lineEnding = true;
-                text[textPos] = 0;
-                break;
-
-            case ';':
-                break;
-
-            default:
+        if (curChar != ' ' && curChar != '\t') {
+            if (curChar == '\r') {
+                int pos = (int)GetFilePosition();
+                FileRead(fileBuffer, 2);
+                curChar = fileBuffer[0] + (fileBuffer[1] << 8);
+                if (curChar == '\n')
+                    break;
+                SetFilePosition(pos);
+            }
+            if (curChar != ';')
                 text[textPos++] = curChar;
-                break;
         }
+        else if (curChar == '\n' || curChar == '\r')
+            break;
 
         if (ReachedEndOfFile()) {
             text[textPos] = 0;
             return;
         }
-
-        if (lineEnding) {
-            return;
-        }
     }
+    text[textPos] = 0;
+    if (ReachedEndOfFile())
+        text[textPos] = 0;
 }
 
 void ReadCreditsList(const char *filePath);
diff --git a/RSDKv4/Text.cpp b/RSDKv4/Text.cpp
index 583ab9b..13e7453 100644
--- a/RSDKv4/Text.cpp
+++ b/RSDKv4/Text.cpp
@@ -7,7 +7,7 @@ char playerListText[0x80][0x20];
 
 BitmapFont fontList[FONTLIST_COUNT];
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 FontCharacter fontCharacterList[FONTCHAR_COUNT];
 
 void LoadFontFile(const char *filePath)
@@ -99,7 +99,7 @@ void LoadTextFile(TextMenu *menu, const char *filePath, byte mapCode)
         menu->entryStart[menu->rowCount] = menu->textDataPos;
         menu->entrySize[menu->rowCount]  = 0;
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
         bool flag = false;
         FileRead(&fileBuffer, 1);
         if (fileBuffer == 0xFF) {
@@ -248,6 +248,7 @@ void AddTextMenuEntry(TextMenu *menu, const char *text)
 {
     menu->entryStart[menu->rowCount]     = menu->textDataPos;
     menu->entrySize[menu->rowCount]      = 0;
+    menu->entryHighlight[menu->rowCount] = false;
     int textLength                       = StrLength(text);
     for (int i = 0; i < textLength;) {
         if (text[i] != '\0') {
@@ -265,6 +266,7 @@ void AddTextMenuEntryW(TextMenu *menu, const ushort *text)
 {
     menu->entryStart[menu->rowCount]     = menu->textDataPos;
     menu->entrySize[menu->rowCount]      = 0;
+    menu->entryHighlight[menu->rowCount] = false;
     int textLength                       = StrLengthW(text);
     for (int i = 0; i < textLength;) {
         if (text[i] != '\0') {
@@ -282,6 +284,7 @@ void SetTextMenuEntry(TextMenu *menu, const char *text, int rowID)
 {
     menu->entryStart[rowID]              = menu->textDataPos;
     menu->entrySize[rowID]               = 0;
+    menu->entryHighlight[menu->rowCount] = false;
     int textLength                       = StrLength(text);
     for (int i = 0; i < textLength;) {
         if (text[i] != '\0') {
@@ -298,6 +301,7 @@ void SetTextMenuEntryW(TextMenu *menu, const ushort *text, int rowID)
 {
     menu->entryStart[rowID]              = menu->textDataPos;
     menu->entrySize[rowID]               = 0;
+    menu->entryHighlight[menu->rowCount] = false;
     int textLength                       = StrLengthW(text);
     for (int i = 0; i < textLength;) {
         if (text[i] != '\0') {
@@ -314,6 +318,7 @@ void EditTextMenuEntry(TextMenu *menu, const char *text, int rowID)
 {
     int entryPos                         = menu->entryStart[rowID];
     menu->entrySize[rowID]               = 0;
+    menu->entryHighlight[menu->rowCount] = false;
     int textLength                       = StrLength(text);
     for (int i = 0; i < textLength;) {
         if (text[i] != '\0') {
diff --git a/RSDKv4/Text.hpp b/RSDKv4/Text.hpp
index ca79f3f..8c7f493 100644
--- a/RSDKv4/Text.hpp
+++ b/RSDKv4/Text.hpp
@@ -3,7 +3,7 @@
 
 #define TEXTDATA_COUNT  (0x2800)
 #define TEXTENTRY_COUNT (0x200)
-#define TEXTMENU_COUNT  (0x2)
+#define TEXTMENU_COUNT  (0x5)
 
 #define FONTLIST_CHAR_COUNT (0x1000)
 #define FONTLIST_COUNT      (0x4)
@@ -26,7 +26,7 @@ struct TextMenu {
     sbyte timer;
 };
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 #define FONTCHAR_COUNT (0x400)
 
 struct FontCharacter {
@@ -73,7 +73,7 @@ extern char playerListText[0x80][0x20];
 
 extern BitmapFont fontList[FONTLIST_COUNT];
 
-#if !RETRO_REV02
+#if RETRO_REV00 || RETRO_REV01
 extern FontCharacter fontCharacterList[FONTCHAR_COUNT];
 
 void LoadFontFile(const char *filePath);
diff --git a/RSDKv4/Userdata.cpp b/RSDKv4/Userdata.cpp
index 1e2ce8c..d2696db 100644
--- a/RSDKv4/Userdata.cpp
+++ b/RSDKv4/Userdata.cpp
@@ -1,5 +1,12 @@
 #include "RetroEngine.hpp"
 
+// Your guess is as good as mine
+#if RETRO_PLATFORM == RETRO_SWITCH
+long pathconf (const char *__path, int __name) {
+    return 0;
+}
+#endif
+
 int globalVariablesCount;
 int globalVariables[GLOBALVAR_COUNT];
 char globalVariableNames[GLOBALVAR_COUNT][0x20];
@@ -33,12 +40,13 @@ int sendCounter = 0;
 #endif
 
 #if !RETRO_USE_ORIGINAL_CODE
-bool forceUseScripts         = false;
-bool forceUseScripts_Config  = false;
-bool skipStartMenu           = false;
-bool skipStartMenu_Config    = false;
-int disableFocusPause        = 0;
-int disableFocusPause_Config = 0;
+
+bool forceUseScripts          = true;
+bool forceUseScripts_Config   = true;
+bool skipStartMenu            = true;
+bool skipStartMenu_Config     = true;
+int disableFocusPause         = 3;
+int disableFocusPause_Config  = 3;
 
 bool useSGame = false;
 
@@ -194,8 +202,10 @@ void InitUserdata()
 #endif
 
 #if RETRO_PLATFORM == RETRO_OSX
-    sprintf(gamePath, "%s/RSDKv4", getResourcesPath());
-    sprintf(modsPath, "%s/RSDKv4/", getResourcesPath());
+    char macBuffer[0x100];
+    getResourcesPath(macBuffer, sizeof(macBuffer));
+    snprintf(gamePath, sizeof(macBuffer), "%s/", macBuffer);
+    snprintf(modsPath, sizeof(macBuffer), "%s/", macBuffer);
 
     mkdir(gamePath, 0777);
 #elif RETRO_PLATFORM == RETRO_ANDROID
@@ -249,11 +259,16 @@ void InitUserdata()
 
         ini.SetBool("Dev", "UseHQModes", Engine.useHQModes = true);
         ini.SetString("Dev", "DataFile", (char *)"Data.rsdk");
+		
         StrCopy(Engine.dataFile[0], "Data.rsdk");
-        if (!StrComp(Engine.dataFile[1], "")) {
-            ini.SetString("Dev", "DataFile2", (char *)"Data2.rsdk");
-            StrCopy(Engine.dataFile[1], "Data2.rsdk");
-        }
+
+        //if (!StrComp(Engine.dataFile[1], "")) {
+            ini.SetString("Dev", "DataFile2", (char *)"Data.rsdk.xmf");
+            StrCopy(Engine.dataFile[1], "Data.rsdk.xmf");
+        //}
+		
+		
+		/*
         if (!StrComp(Engine.dataFile[2], "")) {
             ini.SetString("Dev", "DataFile3", (char *)"Data3.rsdk");
             StrCopy(Engine.dataFile[2], "Data3.rsdk");
@@ -262,12 +277,12 @@ void InitUserdata()
             ini.SetString("Dev", "DataFile4", (char *)"Data4.rsdk");
             StrCopy(Engine.dataFile[3], "Data4.rsdk");
         }
+		*/
 
         ini.SetInteger("Game", "Language", Engine.language = RETRO_EN);
-        ini.SetInteger("Game", "GameType", Engine.gameTypeID = 0);
-        ini.SetBool("Game", "SkipStartMenu", skipStartMenu = false);
+        ini.SetBool("Game", "SkipStartMenu", skipStartMenu = true);
         skipStartMenu_Config = skipStartMenu;
-        ini.SetInteger("Game", "DisableFocusPause", disableFocusPause = 0);
+        ini.SetInteger("Game", "DisableFocusPause", disableFocusPause = 3);
         disableFocusPause_Config = disableFocusPause;
 
 #if RETRO_USE_NETWORKING
@@ -278,12 +293,14 @@ void InitUserdata()
 
         ini.SetBool("Window", "FullScreen", Engine.startFullScreen = DEFAULT_FULLSCREEN);
         ini.SetBool("Window", "Borderless", Engine.borderless = false);
-        ini.SetBool("Window", "VSync", Engine.vsync = false);
+        ini.SetBool("Window", "VSync", Engine.vsync = true);
         ini.SetInteger("Window", "ScalingMode", Engine.scalingMode = 0);
         ini.SetInteger("Window", "WindowScale", Engine.windowScale = 2);
         ini.SetInteger("Window", "ScreenWidth", SCREEN_XSIZE_CONFIG = DEFAULT_SCREEN_XSIZE);
         SCREEN_XSIZE = SCREEN_XSIZE_CONFIG;
         ini.SetInteger("Window", "RefreshRate", Engine.refreshRate = 60);
+	    if (Engine.refreshRate > 60)
+	        Engine.refreshRate = 60;
         ini.SetInteger("Window", "DimLimit", Engine.dimLimit = 300);
         Engine.dimLimit *= Engine.refreshRate;
 
@@ -295,14 +312,14 @@ void InitUserdata()
         ini.SetInteger("Keyboard 1", "Down", inputDevice[INPUT_DOWN].keyMappings = SDL_SCANCODE_DOWN);
         ini.SetInteger("Keyboard 1", "Left", inputDevice[INPUT_LEFT].keyMappings = SDL_SCANCODE_LEFT);
         ini.SetInteger("Keyboard 1", "Right", inputDevice[INPUT_RIGHT].keyMappings = SDL_SCANCODE_RIGHT);
-        ini.SetInteger("Keyboard 1", "A", inputDevice[INPUT_BUTTONA].keyMappings = SDL_SCANCODE_Z);
-        ini.SetInteger("Keyboard 1", "B", inputDevice[INPUT_BUTTONB].keyMappings = SDL_SCANCODE_X);
-        ini.SetInteger("Keyboard 1", "C", inputDevice[INPUT_BUTTONC].keyMappings = SDL_SCANCODE_C);
-        ini.SetInteger("Keyboard 1", "X", inputDevice[INPUT_BUTTONX].keyMappings = SDL_SCANCODE_A);
-        ini.SetInteger("Keyboard 1", "Y", inputDevice[INPUT_BUTTONY].keyMappings = SDL_SCANCODE_S);
-        ini.SetInteger("Keyboard 1", "Z", inputDevice[INPUT_BUTTONZ].keyMappings = SDL_SCANCODE_D);
-        ini.SetInteger("Keyboard 1", "L", inputDevice[INPUT_BUTTONL].keyMappings = SDL_SCANCODE_Q);
-        ini.SetInteger("Keyboard 1", "R", inputDevice[INPUT_BUTTONR].keyMappings = SDL_SCANCODE_E);
+        ini.SetInteger("Keyboard 1", "A", inputDevice[INPUT_BUTTONA].keyMappings = SDL_SCANCODE_A);
+        ini.SetInteger("Keyboard 1", "B", inputDevice[INPUT_BUTTONB].keyMappings = SDL_SCANCODE_S);
+        ini.SetInteger("Keyboard 1", "C", inputDevice[INPUT_BUTTONC].keyMappings = SDL_SCANCODE_D);
+        ini.SetInteger("Keyboard 1", "X", inputDevice[INPUT_BUTTONX].keyMappings = SDL_SCANCODE_Q);
+        ini.SetInteger("Keyboard 1", "Y", inputDevice[INPUT_BUTTONY].keyMappings = SDL_SCANCODE_W);
+        ini.SetInteger("Keyboard 1", "Z", inputDevice[INPUT_BUTTONZ].keyMappings = SDL_SCANCODE_E);
+        ini.SetInteger("Keyboard 1", "L", inputDevice[INPUT_BUTTONL].keyMappings = SDL_SCANCODE_1);
+        ini.SetInteger("Keyboard 1", "R", inputDevice[INPUT_BUTTONR].keyMappings = SDL_SCANCODE_4);
         ini.SetInteger("Keyboard 1", "Start", inputDevice[INPUT_START].keyMappings = SDL_SCANCODE_RETURN);
         ini.SetInteger("Keyboard 1", "Select", inputDevice[INPUT_SELECT].keyMappings = SDL_SCANCODE_TAB);
 
@@ -313,11 +330,11 @@ void InitUserdata()
         ini.SetInteger("Controller 1", "A", inputDevice[INPUT_BUTTONA].contMappings = SDL_CONTROLLER_BUTTON_A);
         ini.SetInteger("Controller 1", "B", inputDevice[INPUT_BUTTONB].contMappings = SDL_CONTROLLER_BUTTON_B);
         ini.SetInteger("Controller 1", "C", inputDevice[INPUT_BUTTONC].contMappings = SDL_CONTROLLER_BUTTON_X);
-        ini.SetInteger("Controller 1", "X", inputDevice[INPUT_BUTTONX].contMappings = SDL_CONTROLLER_BUTTON_Y);
-        ini.SetInteger("Controller 1", "Y", inputDevice[INPUT_BUTTONY].contMappings = SDL_CONTROLLER_BUTTON_ZL);
-        ini.SetInteger("Controller 1", "Z", inputDevice[INPUT_BUTTONZ].contMappings = SDL_CONTROLLER_BUTTON_ZR);
-        ini.SetInteger("Controller 1", "L", inputDevice[INPUT_BUTTONL].contMappings = SDL_CONTROLLER_BUTTON_LEFTSHOULDER);
-        ini.SetInteger("Controller 1", "R", inputDevice[INPUT_BUTTONR].contMappings = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER);
+        ini.SetInteger("Controller 1", "X", inputDevice[INPUT_BUTTONX].contMappings = SDL_CONTROLLER_BUTTON_LEFTSHOULDER);
+        ini.SetInteger("Controller 1", "Y", inputDevice[INPUT_BUTTONY].contMappings = SDL_CONTROLLER_BUTTON_Y);
+        ini.SetInteger("Controller 1", "Z", inputDevice[INPUT_BUTTONZ].contMappings = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER);
+        ini.SetInteger("Controller 1", "L", inputDevice[INPUT_BUTTONL].contMappings = SDL_CONTROLLER_BUTTON_ZL);
+        ini.SetInteger("Controller 1", "R", inputDevice[INPUT_BUTTONR].contMappings = SDL_CONTROLLER_BUTTON_ZR);
         ini.SetInteger("Controller 1", "Start", inputDevice[INPUT_START].contMappings = SDL_CONTROLLER_BUTTON_START);
         ini.SetInteger("Controller 1", "Select", inputDevice[INPUT_SELECT].contMappings = SDL_CONTROLLER_BUTTON_GUIDE);
 
@@ -375,7 +392,7 @@ void InitUserdata()
         if (!ini.GetBool("Dev", "EngineDebugMode", &engineDebugMode))
             engineDebugMode = false;
         if (!ini.GetBool("Dev", "TxtScripts", &forceUseScripts))
-            forceUseScripts = false;
+            forceUseScripts = true;
         forceUseScripts_Config = forceUseScripts;
         if (!ini.GetInteger("Dev", "StartingCategory", &Engine.startList))
             Engine.startList = 255;
@@ -394,11 +411,15 @@ void InitUserdata()
         Engine.startStage_Game = Engine.startStage;
 
         if (!ini.GetString("Dev", "DataFile", Engine.dataFile[0]))
-            StrCopy(Engine.dataFile[0], "Data.rsdk");
-        if (!StrComp(Engine.dataFile[1], "")) {
+        StrCopy(Engine.dataFile[0], "Data.rsdk");
+		
+		
+        //if (!StrComp(Engine.dataFile[1], "")) {
             if (!ini.GetString("Dev", "DataFile2", Engine.dataFile[1]))
-                StrCopy(Engine.dataFile[1], "");
-        }
+                StrCopy(Engine.dataFile[1], "Data.rsdk.xmf");
+        //}
+		
+		/*
         if (!StrComp(Engine.dataFile[2], "")) {
             if (!ini.GetString("Dev", "DataFile3", Engine.dataFile[2]))
                 StrCopy(Engine.dataFile[2], "");
@@ -407,18 +428,14 @@ void InitUserdata()
             if (!ini.GetString("Dev", "DataFile4", Engine.dataFile[3]))
                 StrCopy(Engine.dataFile[3], "");
         }
+		*/
 
         if (!ini.GetInteger("Game", "Language", &Engine.language))
             Engine.language = RETRO_EN;
-        if (!ini.GetInteger("Game", "GameType", &Engine.gameTypeID))
-            Engine.gameTypeID = 0;
-        Engine.releaseType = Engine.gameTypeID ? "USE_ORIGINS" : "USE_STANDALONE";
-
         if (!ini.GetBool("Game", "SkipStartMenu", &skipStartMenu))
-            skipStartMenu = false;
+            skipStartMenu = true;
         skipStartMenu_Config = skipStartMenu;
-        if (!ini.GetInteger("Game", "DisableFocusPause", &disableFocusPause))
-            disableFocusPause = false;
+        disableFocusPause = 3;
         disableFocusPause_Config = disableFocusPause;
 
 #if RETRO_USE_NETWORKING
@@ -433,7 +450,7 @@ void InitUserdata()
         if (!ini.GetBool("Window", "Borderless", &Engine.borderless))
             Engine.borderless = false;
         if (!ini.GetBool("Window", "VSync", &Engine.vsync))
-            Engine.vsync = false;
+            Engine.vsync = true;
         if (!ini.GetInteger("Window", "ScalingMode", &Engine.scalingMode))
             Engine.scalingMode = 0;
         if (!ini.GetInteger("Window", "WindowScale", &Engine.windowScale))
@@ -442,6 +459,8 @@ void InitUserdata()
             SCREEN_XSIZE_CONFIG = DEFAULT_SCREEN_XSIZE;
         SCREEN_XSIZE = SCREEN_XSIZE_CONFIG;
         if (!ini.GetInteger("Window", "RefreshRate", &Engine.refreshRate))
+            Engine.refreshRate = 60;		
+        if (Engine.refreshRate > 60)
             Engine.refreshRate = 60;
         if (!ini.GetInteger("Window", "DimLimit", &Engine.dimLimit))
             Engine.dimLimit = 300; // 5 mins
@@ -450,9 +469,9 @@ void InitUserdata()
 
         float bv = 0, sv = 0;
         if (!ini.GetFloat("Audio", "BGMVolume", &bv))
-            bv = 1.0f;
+            bv = 0.4f;
         if (!ini.GetFloat("Audio", "SFXVolume", &sv))
-            sv = 1.0f;
+            sv = 0.4f;
 
         bgmVolume = bv * MAX_VOLUME;
         sfxVolume = sv * MAX_VOLUME;
@@ -477,21 +496,21 @@ void InitUserdata()
         if (!ini.GetInteger("Keyboard 1", "Right", &inputDevice[INPUT_RIGHT].keyMappings))
             inputDevice[INPUT_RIGHT].keyMappings = SDL_SCANCODE_RIGHT;
         if (!ini.GetInteger("Keyboard 1", "A", &inputDevice[INPUT_BUTTONA].keyMappings))
-            inputDevice[INPUT_BUTTONA].keyMappings = SDL_SCANCODE_Z;
+            inputDevice[INPUT_BUTTONA].keyMappings = SDL_SCANCODE_A;
         if (!ini.GetInteger("Keyboard 1", "B", &inputDevice[INPUT_BUTTONB].keyMappings))
-            inputDevice[INPUT_BUTTONB].keyMappings = SDL_SCANCODE_X;
+            inputDevice[INPUT_BUTTONB].keyMappings = SDL_SCANCODE_S;
         if (!ini.GetInteger("Keyboard 1", "C", &inputDevice[INPUT_BUTTONC].keyMappings))
-            inputDevice[INPUT_BUTTONC].keyMappings = SDL_SCANCODE_C;
+            inputDevice[INPUT_BUTTONC].keyMappings = SDL_SCANCODE_D;
         if (!ini.GetInteger("Keyboard 1", "X", &inputDevice[INPUT_BUTTONX].keyMappings))
-            inputDevice[INPUT_BUTTONX].keyMappings = SDL_SCANCODE_A;
+            inputDevice[INPUT_BUTTONX].keyMappings = SDL_SCANCODE_Q;
         if (!ini.GetInteger("Keyboard 1", "Y", &inputDevice[INPUT_BUTTONY].keyMappings))
-            inputDevice[INPUT_BUTTONY].keyMappings = SDL_SCANCODE_S;
+            inputDevice[INPUT_BUTTONY].keyMappings = SDL_SCANCODE_W;
         if (!ini.GetInteger("Keyboard 1", "Z", &inputDevice[INPUT_BUTTONZ].keyMappings))
-            inputDevice[INPUT_BUTTONZ].keyMappings = SDL_SCANCODE_D;
+            inputDevice[INPUT_BUTTONZ].keyMappings = SDL_SCANCODE_E;
         if (!ini.GetInteger("Keyboard 1", "L", &inputDevice[INPUT_BUTTONL].keyMappings))
-            inputDevice[INPUT_BUTTONL].keyMappings = SDL_SCANCODE_Q;
+            inputDevice[INPUT_BUTTONL].keyMappings = SDL_SCANCODE_1;
         if (!ini.GetInteger("Keyboard 1", "R", &inputDevice[INPUT_BUTTONR].keyMappings))
-            inputDevice[INPUT_BUTTONR].keyMappings = SDL_SCANCODE_E;
+            inputDevice[INPUT_BUTTONR].keyMappings = SDL_SCANCODE_4;
         if (!ini.GetInteger("Keyboard 1", "Start", &inputDevice[INPUT_START].keyMappings))
             inputDevice[INPUT_START].keyMappings = SDL_SCANCODE_RETURN;
         if (!ini.GetInteger("Keyboard 1", "Select", &inputDevice[INPUT_SELECT].keyMappings))
@@ -512,15 +531,15 @@ void InitUserdata()
         if (!ini.GetInteger("Controller 1", "C", &inputDevice[INPUT_BUTTONC].contMappings))
             inputDevice[INPUT_BUTTONC].contMappings = SDL_CONTROLLER_BUTTON_X;
         if (!ini.GetInteger("Controller 1", "X", &inputDevice[INPUT_BUTTONX].contMappings))
-            inputDevice[INPUT_BUTTONX].contMappings = SDL_CONTROLLER_BUTTON_Y;
+            inputDevice[INPUT_BUTTONX].contMappings = SDL_CONTROLLER_BUTTON_LEFTSHOULDER;
         if (!ini.GetInteger("Controller 1", "Y", &inputDevice[INPUT_BUTTONY].contMappings))
-            inputDevice[INPUT_BUTTONY].contMappings = SDL_CONTROLLER_BUTTON_ZL;
+            inputDevice[INPUT_BUTTONY].contMappings = SDL_CONTROLLER_BUTTON_Y;
         if (!ini.GetInteger("Controller 1", "Z", &inputDevice[INPUT_BUTTONZ].contMappings))
-            inputDevice[INPUT_BUTTONZ].contMappings = SDL_CONTROLLER_BUTTON_ZR;
+            inputDevice[INPUT_BUTTONZ].contMappings = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER;
         if (!ini.GetInteger("Controller 1", "L", &inputDevice[INPUT_BUTTONL].contMappings))
-            inputDevice[INPUT_BUTTONL].contMappings = SDL_CONTROLLER_BUTTON_LEFTSHOULDER;
+            inputDevice[INPUT_BUTTONL].contMappings = SDL_CONTROLLER_BUTTON_ZL;
         if (!ini.GetInteger("Controller 1", "R", &inputDevice[INPUT_BUTTONR].contMappings))
-            inputDevice[INPUT_BUTTONR].contMappings = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER;
+            inputDevice[INPUT_BUTTONR].contMappings = SDL_CONTROLLER_BUTTON_ZR;
         if (!ini.GetInteger("Controller 1", "Start", &inputDevice[INPUT_START].contMappings))
             inputDevice[INPUT_START].contMappings = SDL_CONTROLLER_BUTTON_START;
         if (!ini.GetInteger("Controller 1", "Select", &inputDevice[INPUT_SELECT].contMappings))
@@ -676,10 +695,12 @@ void WriteSettings()
 
     ini.SetComment("Dev", "DataFileComment", "Determines where the first RSDK file will be loaded from");
     ini.SetString("Dev", "DataFile", Engine.dataFile[0]);
-    if (!StrComp(Engine.dataFile[1], "")) {
-        ini.SetComment("Dev", "DataFileComment2", "Determines where the second RSDK file will be loaded from");
-        ini.SetString("Dev", "DataFile2", Engine.dataFile[1]);
-    }
+	
+	
+    ini.SetComment("Dev", "DataFileComment2", "Determines where the second RSDK file will be loaded from");
+    ini.SetString("Dev", "DataFile2", Engine.dataFile[1]);
+	
+	/*
     if (!StrComp(Engine.dataFile[2], "")) {
         ini.SetComment("Dev", "DataFileComment3", "Determines where the third RSDK file will be loaded from (normally unused)");
         ini.SetString("Dev", "DataFile3", Engine.dataFile[2]);
@@ -688,18 +709,13 @@ void WriteSettings()
         ini.SetComment("Dev", "DataFileComment4", "Determines where the fourth RSDK file will be loaded from (normally unused)");
         ini.SetString("Dev", "DataFile4", Engine.dataFile[3]);
     }
+	*/
 
     ini.SetComment("Game", "LangComment",
                    "Sets the game language (0 = EN, 1 = FR, 2 = IT, 3 = DE, 4 = ES, 5 = JP, 6 = PT, 7 = RU, 8 = KO, 9 = ZH, 10 = ZS)");
     ini.SetInteger("Game", "Language", Engine.language);
-    ini.SetComment("Game", "GameTypeComment", "Determines game type in scripts (0 = Standalone/Original releases, 1 = Origins release)");
-    ini.SetInteger("Game", "GameType", Engine.gameTypeID);
     ini.SetComment("Game", "SSMenuComment", "If set to true, disables the start menu");
     ini.SetBool("Game", "SkipStartMenu", skipStartMenu_Config);
-    ini.SetComment("Game", "DFPMenuComment",
-                   "Handles pausing behaviour when focus is lost\n; 0 = Game focus enabled, engine focus enabled\n; 1 = Game focus disabled, "
-                   "engine focus enabled\n; 2 = Game focus enabled, engine focus disabled\n; 3 = Game focus disabled, engine focus disabled");
-    ini.SetInteger("Game", "DisableFocusPause", disableFocusPause_Config);
 
 #if RETRO_USE_NETWORKING
     ini.SetComment("Network", "HostComment", "The host (IP address or \"URL\") that the game will try to connect to.");
@@ -715,13 +731,13 @@ void WriteSettings()
     ini.SetComment("Window", "VSComment",
                    "Determines if VSync will be active or not (not recommended as the engine is built around running at 60 FPS)");
     ini.SetBool("Window", "VSync", Engine.vsync);
-    ini.SetComment("Window", "SMComment", "Determines what scaling is used. 0 is nearest neighbour, 1 is linear.");
+    ini.SetComment("Window", "SMComment", "Determines what scaling is used. 0 is nearest neighbour, 1 is integer scaling, 2 is sharp bilinear, 3 is bilinear.");
     ini.SetInteger("Window", "ScalingMode", Engine.scalingMode);
     ini.SetComment("Window", "WSComment", "How big the window will be");
     ini.SetInteger("Window", "WindowScale", Engine.windowScale);
     ini.SetComment("Window", "SWComment", "How wide the base screen will be in pixels");
     ini.SetInteger("Window", "ScreenWidth", SCREEN_XSIZE_CONFIG);
-    ini.SetComment("Window", "RRComment", "Determines the target FPS");
+    ini.SetComment("Window", "RRComment", "Determines the target FPS (capped at 60)");
     ini.SetInteger("Window", "RefreshRate", Engine.refreshRate);
     ini.SetComment("Window", "DLComment", "Determines the dim timer in seconds, set to -1 to disable dimming");
     ini.SetInteger("Window", "DimLimit", Engine.dimLimit >= 0 ? Engine.dimLimit / Engine.refreshRate : -1);
@@ -731,10 +747,10 @@ void WriteSettings()
 
 #if RETRO_USING_SDL2
     ini.SetComment("Keyboard 1", "IK1Comment",
-                   "Keyboard Mappings for P1 (Based on: https://wiki.libsdl.org/SDL2/SDLScancodeLookup)");
+                   "Keyboard Mappings for P1 (Based on: https://github.com/libsdl-org/sdlwiki/blob/main/SDLScancodeLookup.mediawiki)");
 #endif
 #if RETRO_USING_SDL1
-    ini.SetComment("Keyboard 1", "IK1Comment", "Keyboard Mappings for P1 (Based on: https://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlkey.html)");
+    ini.SetComment("Keyboard 1", "IK1Comment", "Keyboard Mappings for P1 (Based on: https://wiki.libsdl.org/SDLKeycodeLookup)");
 #endif
     ini.SetInteger("Keyboard 1", "Up", inputDevice[INPUT_UP].keyMappings);
     ini.SetInteger("Keyboard 1", "Down", inputDevice[INPUT_DOWN].keyMappings);
@@ -753,10 +769,18 @@ void WriteSettings()
 
 #if RETRO_USING_SDL2
     ini.SetComment("Controller 1", "IC1Comment",
-                   "Controller Mappings for P1 (Based on: https://rsdkmodding.com/RSDKv4/Decompilation/SettingsINI/#controller-buttons)");
-#else
-    ini.SetComment("Controller 1", "IC1Comment",
-                   "Controller Mappings for P1");
+                   "Controller Mappings for P1 (Based on: https://github.com/libsdl-org/sdlwiki/blob/main/SDL_GameControllerButton.mediawiki)");
+    ini.SetComment("Controller 1", "IC1Comment2", "Extra buttons can be mapped with the following IDs:");
+    ini.SetComment("Controller 1", "IC1Comment3", "CONTROLLER_BUTTON_ZL             = 16");
+    ini.SetComment("Controller 1", "IC1Comment4", "CONTROLLER_BUTTON_ZR             = 17");
+    ini.SetComment("Controller 1", "IC1Comment5", "CONTROLLER_BUTTON_LSTICK_UP      = 18");
+    ini.SetComment("Controller 1", "IC1Comment6", "CONTROLLER_BUTTON_LSTICK_DOWN    = 19");
+    ini.SetComment("Controller 1", "IC1Comment7", "CONTROLLER_BUTTON_LSTICK_LEFT    = 20");
+    ini.SetComment("Controller 1", "IC1Comment8", "CONTROLLER_BUTTON_LSTICK_RIGHT   = 21");
+    ini.SetComment("Controller 1", "IC1Comment9", "CONTROLLER_BUTTON_RSTICK_UP      = 22");
+    ini.SetComment("Controller 1", "IC1Comment10", "CONTROLLER_BUTTON_RSTICK_DOWN    = 23");
+    ini.SetComment("Controller 1", "IC1Comment11", "CONTROLLER_BUTTON_RSTICK_LEFT    = 24");
+    ini.SetComment("Controller 1", "IC1Comment12", "CONTROLLER_BUTTON_RSTICK_RIGHT   = 25");
 #endif
     ini.SetInteger("Controller 1", "Up", inputDevice[INPUT_UP].contMappings);
     ini.SetInteger("Controller 1", "Down", inputDevice[INPUT_DOWN].contMappings);
@@ -920,13 +944,7 @@ void SetAchievement(int *achievementID, int *status)
 }
 #if RETRO_USE_MOD_LOADER
 void AddGameAchievement(int *unused, const char *name) { StrCopy(achievements[achievementCount++].name, name); }
-void SetAchievementDescription(uint *id, const char *desc)
-{
-    if (*id >= achievementCount)
-        return;
-
-    StrCopy(achievements[*id].desc, desc);
-}
+void SetAchievementDescription(int *id, const char *desc) { StrCopy(achievements[*id].desc, desc); }
 void ClearAchievements() { achievementCount = 0; }
 void GetAchievementCount() { scriptEng.checkResult = achievementCount; }
 void GetAchievementName(uint *id, int *textMenu)
@@ -1173,122 +1191,6 @@ void ShowWebsite(int websiteID)
     }
 }
 
-#if RETRO_REV03
-enum NotifyCallbackIDs {
-    NOTIFY_DEATH_EVENT         = 128,
-    NOTIFY_TOUCH_SIGNPOST      = 129,
-    NOTIFY_HUD_ENABLE          = 130,
-    NOTIFY_ADD_COIN            = 131,
-    NOTIFY_KILL_ENEMY          = 132,
-    NOTIFY_SAVESLOT_SELECT     = 133,
-    NOTIFY_FUTURE_PAST         = 134,
-    NOTIFY_GOTO_FUTURE_PAST    = 135,
-    NOTIFY_BOSS_END            = 136,
-    NOTIFY_SPECIAL_END         = 137,
-    NOTIFY_DEBUGPRINT          = 138,
-    NOTIFY_KILL_BOSS           = 139,
-    NOTIFY_TOUCH_EMERALD       = 140,
-    NOTIFY_STATS_ENEMY         = 141,
-    NOTIFY_STATS_CHARA_ACTION  = 142,
-    NOTIFY_STATS_RING          = 143,
-    NOTIFY_STATS_MOVIE         = 144,
-    NOTIFY_STATS_PARAM_1       = 145,
-    NOTIFY_STATS_PARAM_2       = 146,
-    NOTIFY_CHARACTER_SELECT    = 147,
-    NOTIFY_SPECIAL_RETRY       = 148,
-    NOTIFY_TOUCH_CHECKPOINT    = 149,
-    NOTIFY_ACT_FINISH          = 150,
-    NOTIFY_1P_VS_SELECT        = 151,
-    NOTIFY_CONTROLLER_SUPPORT  = 152,
-    NOTIFY_STAGE_RETRY         = 153,
-    NOTIFY_SOUND_TRACK         = 154,
-    NOTIFY_GOOD_ENDING         = 155,
-    NOTIFY_BACK_TO_MAINMENU    = 156,
-    NOTIFY_LEVEL_SELECT_MENU   = 157,
-    NOTIFY_PLAYER_SET          = 158,
-    NOTIFY_EXTRAS_MODE         = 159,
-    NOTIFY_SPIN_DASH_TYPE      = 160,
-    NOTIFY_TIME_OVER           = 161,
-    NOTIFY_TIMEATTACK_MODE     = 162,
-    NOTIFY_STATS_BREAK_OBJECT  = 163,
-    NOTIFY_STATS_SAVE_FUTURE   = 164,
-    NOTIFY_STATS_CHARA_ACTION2 = 165,
-};
-
-void NotifyCallback(int *callback, int *param1, int *param2, int *param3)
-{
-    if (!callback || !param1)
-        return;
-
-    switch (*callback) {
-        default: PrintLog("NOTIFY: Unknown Callback -> %d", *param1); break;
-        case NOTIFY_DEATH_EVENT: PrintLog("NOTIFY: DeathEvent() -> %d", *param1); break;
-        case NOTIFY_TOUCH_SIGNPOST: PrintLog("NOTIFY: TouchSignPost() -> %d", *param1); break;
-        case NOTIFY_HUD_ENABLE: PrintLog("NOTIFY: HUDEnable() -> %d", *param1); break;
-        case NOTIFY_ADD_COIN:
-            PrintLog("NOTIFY: AddCoin() -> %d", *param1);
-            SetGlobalVariableByName("game.coinCount", GetGlobalVariableByName("game.coinCount") + *param1);
-            break;
-        case NOTIFY_KILL_ENEMY: PrintLog("NOTIFY: KillEnemy() -> %d", *param1); break;
-        case NOTIFY_SAVESLOT_SELECT: PrintLog("NOTIFY: SaveSlotSelect() -> %d", *param1); break;
-        case NOTIFY_FUTURE_PAST: PrintLog("NOTIFY: FuturePast() -> %d", *param1); break;
-        case NOTIFY_GOTO_FUTURE_PAST: PrintLog("NOTIFY: GotoFuturePast() -> %d", *param1); break;
-        case NOTIFY_BOSS_END: PrintLog("NOTIFY: BossEnd() -> %d", *param1); break;
-        case NOTIFY_SPECIAL_END: PrintLog("NOTIFY: SpecialEnd() -> %d", *param1); break;
-        case NOTIFY_DEBUGPRINT:
-            // Although there are instances of this being called from both CallNativeFunction2 and CallNativeFunction4 in Origins' scripts, there's no way we can tell which one was used here to handle possible errors
-            // Due to this, we'll only print param1 regardless of the opcode used
-            PrintLog("NOTIFY: DebugPrint() -> %d", *param1);
-            break;
-        case NOTIFY_KILL_BOSS: PrintLog("NOTIFY: KillBoss() -> %d", *param1); break;
-        case NOTIFY_TOUCH_EMERALD: PrintLog("NOTIFY: TouchEmerald() -> %d", *param1); break;
-        case NOTIFY_STATS_ENEMY: PrintLog("NOTIFY: StatsEnemy() -> %d, %d, %d", *param1, *param2, *param3); break;
-        case NOTIFY_STATS_CHARA_ACTION: PrintLog("NOTIFY: StatsCharaAction() -> %d, %d, %d", *param1, *param2, *param3); break;
-        case NOTIFY_STATS_RING: PrintLog("NOTIFY: StatsRing() -> %d", *param1); break;
-        case NOTIFY_STATS_MOVIE:
-            PrintLog("NOTIFY: StatsMovie() -> %d", *param1);
-            ClearGraphicsData();
-            ClearAnimationData();
-            activeStageList   = 0;
-            stageMode         = STAGEMODE_LOAD;
-            Engine.gameMode   = ENGINE_MAINGAME;
-            stageListPosition = 0;
-            break;
-        case NOTIFY_STATS_PARAM_1: PrintLog("NOTIFY: StatsParam1() -> %d, %d, %d", *param1, *param2, *param3); break;
-        case NOTIFY_STATS_PARAM_2: PrintLog("NOTIFY: StatsParam2() -> %d", *param1); break;
-        case NOTIFY_CHARACTER_SELECT:
-            PrintLog("NOTIFY: CharacterSelect() -> %d", *param1);
-            SetGlobalVariableByName("game.callbackResult", 1);
-            SetGlobalVariableByName("game.continueFlag", 0);
-            break;
-        case NOTIFY_SPECIAL_RETRY:
-            PrintLog("NOTIFY: SpecialRetry() -> %d, %d, %d", *param1, *param2, *param3);
-            SetGlobalVariableByName("game.callbackResult", 1);
-            break;
-        case NOTIFY_TOUCH_CHECKPOINT: PrintLog("NOTIFY: TouchCheckpoint() -> %d", *param1); break;
-        case NOTIFY_ACT_FINISH: PrintLog("NOTIFY: ActFinish() -> %d", *param1); break;
-        case NOTIFY_1P_VS_SELECT: PrintLog("NOTIFY: 1PVSSelect() -> %d", *param1); break;
-        case NOTIFY_CONTROLLER_SUPPORT:
-            PrintLog("NOTIFY: ControllerSupport() -> %d", *param1);
-            SetGlobalVariableByName("game.callbackResult", 1);
-            break;
-        case NOTIFY_STAGE_RETRY: PrintLog("NOTIFY: StageRetry() -> %d", *param1); break;
-        case NOTIFY_SOUND_TRACK: PrintLog("NOTIFY: SoundTrack() -> %d", *param1); break;
-        case NOTIFY_GOOD_ENDING: PrintLog("NOTIFY: GoodEnding() -> %d", *param1); break;
-        case NOTIFY_BACK_TO_MAINMENU: PrintLog("NOTIFY: BackToMainMenu() -> %d", *param1); break;
-        case NOTIFY_LEVEL_SELECT_MENU: PrintLog("NOTIFY: LevelSelectMenu() -> %d", *param1); break;
-        case NOTIFY_PLAYER_SET: PrintLog("NOTIFY: PlayerSet() -> %d", *param1); break;
-        case NOTIFY_EXTRAS_MODE: PrintLog("NOTIFY: ExtrasMode() -> %d", *param1); break;
-        case NOTIFY_SPIN_DASH_TYPE: PrintLog("NOTIFY: SpindashType() -> %d", *param1); break;
-        case NOTIFY_TIME_OVER: PrintLog("NOTIFY: TimeOver() -> %d", *param1); break;
-        case NOTIFY_TIMEATTACK_MODE: PrintLog("NOTIFY: TimeAttackMode() -> %d", *param1); break;
-        case NOTIFY_STATS_BREAK_OBJECT: PrintLog("NOTIFY: StatsBreakObject() -> %d, %d", *param1, *param2); break;
-        case NOTIFY_STATS_SAVE_FUTURE: PrintLog("NOTIFY: StatsSaveFuture() -> %d", *param1); break;
-        case NOTIFY_STATS_CHARA_ACTION2: PrintLog("NOTIFY: StatsCharaAction2() -> %d, %d, %d", *param1, *param2, *param3); break;
-    }
-}
-#endif
-
 void ExitGame() { Engine.running = false; }
 
 void FileExists(int *unused, const char *filePath)
@@ -1308,15 +1210,15 @@ void GetWindowScaleMode() { scriptEng.checkResult = Engine.scalingMode; }
 void GetWindowFullScreen() { scriptEng.checkResult = Engine.isFullScreen; }
 void GetWindowBorderless() { scriptEng.checkResult = Engine.borderless; }
 void GetWindowVSync() { scriptEng.checkResult = Engine.vsync; }
+void GetFrameRate() { scriptEng.checkResult = Engine.refreshRate; }
 
-bool changedScreenWidth = false;
 void SetScreenWidth(int *width, int *unused)
 {
-    if (!width)
-        return;
-
-    SCREEN_XSIZE_CONFIG = *width;
-    changedScreenWidth  = SCREEN_XSIZE_CONFIG != SCREEN_XSIZE;
+	if (!width)
+	return;
+	SCREEN_XSIZE_CONFIG = *width;
+	SCREEN_XSIZE        = SCREEN_XSIZE_CONFIG;
+	ApplyWindowChanges();
 }
 
 void SetWindowScale(int *scale, int *unused)
@@ -1325,6 +1227,7 @@ void SetWindowScale(int *scale, int *unused)
         return;
 
     Engine.windowScale = *scale;
+	ApplyWindowChanges();
 }
 
 void SetWindowScaleMode(int *mode, int *unused)
@@ -1333,6 +1236,7 @@ void SetWindowScaleMode(int *mode, int *unused)
         return;
 
     Engine.scalingMode = *mode;
+	//ApplyWindowChanges();
 }
 
 void SetWindowFullScreen(int *fullscreen, int *unused)
@@ -1342,6 +1246,7 @@ void SetWindowFullScreen(int *fullscreen, int *unused)
 
     Engine.isFullScreen    = *fullscreen;
     Engine.startFullScreen = *fullscreen;
+	ApplyWindowChanges();
 }
 
 void SetWindowBorderless(int *borderless, int *unused)
@@ -1350,6 +1255,7 @@ void SetWindowBorderless(int *borderless, int *unused)
         return;
 
     Engine.borderless = *borderless;
+	ApplyWindowChanges();
 }
 
 void SetWindowVSync(int *enabled, int *unused)
@@ -1358,9 +1264,23 @@ void SetWindowVSync(int *enabled, int *unused)
         return;
 
     Engine.vsync = *enabled;
+	ApplyWindowChanges();
+}
+
+void SetFrameRate(int *enabled, int *unused)
+{
+    if (!enabled)
+        return;
+
+    Engine.refreshRate = *enabled;
+    if (Engine.refreshRate > 60)
+        Engine.refreshRate = 60;
+	//ApplyWindowChanges();
 }
+
 void ApplyWindowChanges()
 {
+	
 #if RETRO_USING_OPENGL
     for (int i = 0; i < TEXTURE_COUNT; ++i) {
         glDeleteTextures(1, &textureList[i].id);
@@ -1382,11 +1302,6 @@ void ApplyWindowChanges()
             mesh->vertexCount = 0;
         }
     }
-
-    if (changedScreenWidth)
-        SCREEN_XSIZE = SCREEN_XSIZE_CONFIG;
-    changedScreenWidth = false;
-
     ReleaseRenderDevice(true);
     InitRenderDevice();
 
@@ -1410,4 +1325,6 @@ void ApplyWindowChanges()
         }
     }
 }
+
+
 #endif
diff --git a/RSDKv4/Userdata.hpp b/RSDKv4/Userdata.hpp
index 121e628..e6117fe 100644
--- a/RSDKv4/Userdata.hpp
+++ b/RSDKv4/Userdata.hpp
@@ -1,6 +1,8 @@
 #ifndef USERDATA_H
 #define USERDATA_H
 
+#include "Networking.hpp"
+
 #define GLOBALVAR_COUNT (0x100)
 
 #define ACHIEVEMENT_COUNT (0x40)
@@ -20,37 +22,35 @@
 #define unused(x) (void)x
 
 struct SaveFile {
-    int characterID;    // Value 0/8/16/24
-    int lives;          // Value 1/9/17/25
-    int score;          // Value 2/10/18/26
-    int scoreBonus;     // Value 3/11/19/27
-    int stageID;        // Value 4/12/20/28
-    int emeralds;       // Value 5/13/21/29
-    int specialStageID; // Value 6/14/22/30
-    int unused;         // Value 7/15/23/31
+    int characterID;
+    int lives;
+    int score;
+    int scoreBonus;
+    int stageID;
+    int emeralds;
+    int specialStageID;
+    int unused;
 };
 
 struct SaveGame {
-    SaveFile files[4];   // Values 0-31
-    int saveInitialized; // Value 32
-    int musVolume;       // Value 33
-    int sfxVolume;       // Value 34
-    int spindashEnabled; // Value 35
-    int boxRegion;       // Value 36
-    int vDPadSize;       // Value 37
-    int vDPadOpacity;    // Value 38
-    int vDPadX_Move;     // Value 39
-    int vDPadY_Move;     // Value 40
-    int vDPadX_Jump;     // Value 41
-    int vDPadY_Jump;     // Value 42
-    int tailsUnlocked;   // Value 43
-    int knuxUnlocked;    // Value 44
-    int unlockedActs;    // Value 45
-    int unlockedHPZ;     // Value 46
-    int unused[17];      // Values 47-63
-    int records[0x80];   // Values 64-192
-    int padding[0x73F];  // Values 193-2047
-    int customSS[0x400]; // Values 2048-3072
+    SaveFile files[4];
+    int saveInitialized;
+    int musVolume;
+    int sfxVolume;
+    int spindashEnabled;
+    int boxRegion;
+    int vDPadSize;
+    int vDPadOpacity;
+    int vDPadX_Move;
+    int vDPadY_Move;
+    int vDPadX_Jump;
+    int vDPadY_Jump;
+    int tailsUnlocked;
+    int knuxUnlocked;
+    int unlockedActs;
+    int unlockedHPZ;
+    int unused[17];
+    int records[0x80];
 };
 
 enum OnlineMenuTypes {
@@ -68,12 +68,6 @@ struct LeaderboardEntry {
     int score;
 };
 
-#ifndef NETWORKING_H
-struct MultiplayerData {
-    int type;
-    int data[0x1FF];
-};
-#endif
 
 extern void *nativeFunction[NATIIVEFUNCTION_COUNT];
 extern int nativeFunctionCount;
@@ -167,7 +161,7 @@ void SetAchievement(int *achievementID, int *status);
 void AwardAchievement(int id, int status);
 #if RETRO_USE_MOD_LOADER
 void AddGameAchievement(int *unused, const char *name);
-void SetAchievementDescription(uint *id, const char *desc);
+void SetAchievementDescription(int *id, const char *desc);
 void ClearAchievements();
 void GetAchievementCount();
 void GetAchievementName(uint *id, int *textMenu);
@@ -208,15 +202,6 @@ void ShowSegaIDPopup();
 void ShowOnlineSignIn();
 void ShowWebsite(int websiteID);
 
-// In the Sega Forever versions of S1 & S2, there's a feature where you can choose to watch an ad to continue from a Game Over
-// We obviously can't do that here, so let's just take the L
-inline void NativePlayerWaitingAds() { SetGlobalVariableByName("waitingAds.result", 2); }
-inline void NativeWaterPlayerWaitingAds() { SetGlobalVariableByName("waitingAds.water", 2); }
-
-#if RETRO_REV03
-void NotifyCallback(int *callback, int *param1, int *param2, int *param3);
-#endif
-
 void ExitGame();
 void FileExists(int *unused, const char *filePath);
 
@@ -233,8 +218,9 @@ void GetWindowBorderless();
 void SetWindowBorderless(int *borderless, int *unused);
 void GetWindowVSync();
 void SetWindowVSync(int *enabled, int *unused);
+void GetFrameRate();
+void SetFrameRate(int *enabled, int *unused);
 void ApplyWindowChanges();
-
 #endif
 
 #endif //! USERDATA_H
diff --git a/RSDKv4/fcaseopen.c b/RSDKv4/fcaseopen.c
index 3e10f86..5b0a23b 100644
--- a/RSDKv4/fcaseopen.c
+++ b/RSDKv4/fcaseopen.c
@@ -30,7 +30,7 @@ THE SOFTWARE.
 #include <errno.h>
 #include <unistd.h>
 
-// r must have strlen(path) + 3 bytes
+// r must have strlen(path) + 2 bytes
 static int casepath(char const *path, char *r)
 {
     size_t l = strlen(path);
@@ -109,7 +109,7 @@ FILE *fcaseopen(char const *path, char const *mode)
 #if !defined(_WIN32)
     if (!f)
     {	    
-        char *r = (char*)alloca(strlen(path) + 3);
+        char *r = (char*)alloca(strlen(path) + 2);
         if (casepath(path, r))
         {
             f = fopen(r, mode);
@@ -122,7 +122,7 @@ FILE *fcaseopen(char const *path, char const *mode)
 void casechdir(char const *path)
 {
 #if !defined(_WIN32)
-    char *r = (char*)alloca(strlen(path) + 3);
+    char *r = (char*)alloca(strlen(path) + 2);
     if (casepath(path, r))
     {
         chdir(r);
diff --git a/RSDKv4/main.cpp b/RSDKv4/main.cpp
index 9a16d9b..0959c11 100644
--- a/RSDKv4/main.cpp
+++ b/RSDKv4/main.cpp
@@ -48,8 +48,37 @@ void parseArguments(int argc, char *argv[])
 }
 #endif
 
+#ifdef NXLINK
+#include <switch.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/errno.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+
+static int s_nxlinkSock = -1;
+
+static void initNxLink()
+{
+    if (R_FAILED(socketInitializeDefault()))
+        return;
+
+    s_nxlinkSock = nxlinkStdio();
+    if (s_nxlinkSock >= 0)
+        printf("printf output now goes to nxlink server\n");
+    else
+        socketExit();
+}
+#endif
+
 int main(int argc, char *argv[])
 {
+#ifdef NXLINK
+    initNxLink();
+#endif
+
 #if !RETRO_USE_ORIGINAL_CODE
     parseArguments(argc, argv);
 #endif
@@ -62,9 +91,13 @@ int main(int argc, char *argv[])
     if (Engine.consoleEnabled) {
 #if RETRO_PLATFORM == RETRO_WIN
         FreeConsole();
-#endif
+#endif //! RETRO_PLATFORM == RETRO_WIN
     }
-#endif
+#endif //! !RETRO_USE_ORIGINAL_CODE
+
+#ifdef NXLINK
+    socketExit();
+#endif //! NXLINK
 
     return 0;
 }
